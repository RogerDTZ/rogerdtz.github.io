---
title: 子区间
mathjax: true
date: 2019-04-17 09:42:40
tags: [扫描线]
---

# Description

有一个以区间为元素的可重集合$S$

你需要支持$Q$次操作：

1. 向$S$中加入一个区间$[L,R]$

2. 从$S​$中删除第$x​$个加入的区间

3. 给定参数$l,r$，求
   $$
   \max\{ (l-L)(R-r)\mid [L,R]\in S\land[l,r] \in [L,R] \}
   $$

$Q \le 2 \times 10^5$，$1 \le L \le R \le 10^9$

<!-- more -->

# Solution

首先用线段树按时间分治来处理元素的加入和删除，这样总共有$O(Q \log Q)$个元素和询问。最后在每个区间上进行一次贡献计算即可。下面考虑如何计算若干个元素对若干个询问的贡献

我们把元素和询问抽象成二维平面上的一个点，以左端点为横坐标，以右端点为纵坐标。那么一个询问相当于求左上方所有元素的点和自己的点构成的最大矩形的面积

注意到如果一个元素的左上方有另一个元素，那么显然这个元素一定不可能是最优解。我们剔除掉这些点，那么剩余元素会呈从左到右逐渐上升的形态

考虑维护一条按横坐标从左到右的扫描线，逐渐加入元素，并回答询问。我们考虑一对相邻元素$a$和$b$（相邻可以定义为$x$坐标相邻），一个询问选$a$优还是选$b$优是怎么决定的呢？

列一下方程，就可以发现，一条经过$(a_x,b_y)$和$(b_x,a_y)$的直线就是决策点。考虑询问所在的平行$y$轴的直线$x=q_x$与该直线的交点，若询问在交点以下，则选$a$优，否则选$b$优

如果两条判别直线相交，则中间那个元素就不再可能作为最优解，我们把它和这些直线删除，然后维护其余两个元素新构成的判别直线

如何判别相交呢？可以发现一条直线若与其他直线有交，$x$坐标最小的交点一定是由它和某个**相邻直线**构成的（否则会存在更早的交点，而我们的维护方式已经保证了能及时处理这些交点，不可能）。因此加入直线时，可以直接与相邻的直线计算交点信息，用一个堆储存这些交点即可

我们维护这些判别直线与$x=q_x$的交。可以发现$x=q_x$被判别分割成了若干段，我们只需要知道询问点落在哪一段，就可以确定最优点是谁

实现上，用一个set维护存在的元素，用一个set维护交点（这个set比较特殊，因为在$x=q_x$向右移动时交点会移动，不好维护实际值。由于我们会及时删除并维护相交的直线，这些交点在$x=q_x$移动时仍保持有序，我们就先存下这些直线的索引，lower_bound时定义一个特殊的cmp函数即可），用一个优先队列维护交点信息

时间复杂度$O(Q \log^2 Q)$

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <utility>
#include <vector>
#include <queue>
#include <set>

#define MP make_pair
#define FR first
#define SE second

using std::max;
using std::sort;
using std::pair;
using std::make_pair;
using std::vector;
using std::priority_queue;
using std::set;

typedef long long LL;

const double EPS=1e-10;
const double DINF=1e40;
const int N=200000+10;

int n,m,q;
LL ans[N];

namespace IO{
	const int LEN=20000000;
	char *inBuf,*inPtr;
	void Init(){
		inBuf=new char[LEN];
	}
	void Load(){
		fread(inBuf,1,LEN,stdin);
		inPtr=inBuf;
	}
	char GetChar(){
		return *(inPtr++);
	}
	int GetInt(){
		int x=0,f=1;
		char c=GetChar();
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=GetChar();}
		while('0'<=c&&c<='9'){x=x*10+c-'0';c=GetChar();}
		return x*f;
	}
}
namespace Scan{
	struct Point{
		int x,y;
		int id;
		static bool Cmp(const Point &a,const Point &b){
			if(a.x!=b.x)
				return a.x<b.x;
			return a.id==0&&b.id!=0;
		}
	}p[N];
	struct Event{
		double x;
		int u,v,w;
		friend bool operator < (const Event &a,const Event &b){
			return a.x>b.x;
		}
	};
	struct Line{
		double k,b;
		Line(){}
		Line(double k,double b): k(k),b(b) {}
		Line(double x0,double y0,double x1,double y1){
			k=(y1-y0)/(x1-x0);
			b=y0-k*x0;
		}
		static double Cross(Line x,Line y){ // x:down y:up
			if(x.k<=y.k)
				return DINF;
			return (y.b-x.b)/(x.k-y.k);
		}
	};
	int n;
	Line line[N];
	int curx;
	struct Data{
		int u;
		Data(int u): u(u) {}
		friend bool operator < (const Data &a,const Data &b){
			if(curx==-1)
				return a.u<b.u;
			else
				return line[a.u].k*curx+line[a.u].b<line[b.u].k*curx+line[b.u].b;
		}
	};
	bool CmpLeft(const pair<int,int> &a,const pair<int,int> &b){
		if(a.SE!=b.SE)
			return a.SE<b.SE;
		return a.FR<b.FR;
	}
	vector<pair<int,int> > Arrange(vector<pair<int,int> > a){
		sort(a.begin(),a.end(),CmpLeft);
		vector<pair<int,int> > tmp;
		for(int i=0,j=0;i<int(a.size());i=j){
			tmp.push_back(a[i]);
			for(;j<int(a.size())&&a[i].SE==a[j].SE;j++);
		}
		a=tmp;
		tmp.clear();
		for(int i=0;i<int(a.size());i++){
			while(!tmp.empty()&&tmp.back().FR>=a[i].FR)
				tmp.pop_back();
			tmp.push_back(a[i]);
		}
		return tmp;
	}
	void Init(vector<pair<int,int> > a,vector<pair<int,pair<int,int> > > b){
		a=Arrange(a);
		n=0;
		for(int i=0;i<int(a.size());i++)
			p[++n]=(Point){a[i].FR,a[i].SE,0};
		for(int i=0;i<int(b.size());i++)
			p[++n]=(Point){b[i].SE.FR,b[i].SE.SE,b[i].FR};
		sort(p+1,p+n+1,Point::Cmp);
	}
	Line MakeLine(int u,int v){
		double x0=p[u].x,y0=p[v].y;
		double x1=p[v].x,y1=p[u].y;
		return Line(x0,y0,x1,y1);
	}
	void Run(){
		static priority_queue<Event> q;
		static set<int> s1;
		static set<Data> s2;
		static set<int>::iterator it1;
		static int nex[N];
		while(!q.empty()) q.pop();
		s1.clear();
		s2.clear();
		for(int i=1;i<=n;i++) nex[i]=-1;
		for(int i=1;i<=n;i++){
			for(;!q.empty()&&q.top().x-EPS<=p[i].x;q.pop()){
				Event e=q.top();
				if(nex[e.u]!=e.v||nex[e.v]!=e.w)
					continue;
				int u=e.u,v=e.v,w=e.w;
				s1.erase(s1.find(v));
				curx=-1;
				s2.erase(s2.find(Data(u)));
				s2.erase(s2.find(Data(v)));
				nex[u]=w;
				nex[v]=-1;
				line[u]=MakeLine(u,w);
				curx=-1; s2.insert(Data(u));
				set<int>::iterator it=s1.find(u);
				if(it!=s1.begin()){
					it--;
					int x=*it;
					q.push((Event){Line::Cross(line[x],line[u]),x,u,w});
				}
				if(nex[w]!=-1)
					q.push((Event){Line::Cross(line[u],line[w]),u,w,nex[w]});
			}
			if(!p[i].id){
				s1.insert(i);
				if(s1.size()>1){
					it1=s1.end();
					it1--; it1--;
					int j=*it1;
					nex[j]=i;
					line[j]=MakeLine(j,i);
					curx=-1; s2.insert(Data(j));
					if(s1.size()>2){
						it1--;
						int k=*it1;
						q.push((Event){Line::Cross(line[k],line[j]),k,j,i});
					}
				}
			}else{
				int who=-1;
				if(s1.empty())
					continue;
				if(s2.empty()){
					who=*s1.begin();
				}else{
					line[0]=Line(0,p[i].y);
					curx=p[i].x;
					set<Data>::iterator it=s2.upper_bound(Data(0));
					if(it==s2.end()){
						it1=s1.end();
						it1--;
						who=*it1;
					}else{
						who=it->u;
					}
				}
				if(p[who].y<p[i].y)
					continue;
				LL area=1ll*(p[i].x-p[who].x)*(p[who].y-p[i].y);
				ans[p[i].id]=max(ans[p[i].id],area);
			}
		}
	}
}
namespace Seg{/*{{{*/
	const int SIZE=(::N*2)*2;
	struct Node{
		int ch[2];
		vector<pair<int,int> > x;
		vector<pair<int,pair<int,int> > > y;
	}a[SIZE];
	int nodeCnt;
	int rt;
	void Build(int &u,int l,int r){
		u=++nodeCnt;
		if(l==r)
			return;
		int mid=(l+r)>>1;
		Build(a[u].ch[0],l,mid);
		Build(a[u].ch[1],mid+1,r);
	}
	void InsertPoint(int u,int l,int r,int ml,int mr,pair<int,int> p){
		if(ml<=l&&r<=mr){
			a[u].x.push_back(p);
			return;
		}
		int mid=(l+r)>>1;
		if(mr<=mid){
			InsertPoint(a[u].ch[0],l,mid,ml,mr,p);
		}else if(mid<ml){
			InsertPoint(a[u].ch[1],mid+1,r,ml,mr,p);
		}else{
			InsertPoint(a[u].ch[0],l,mid,ml,mid,p);
			InsertPoint(a[u].ch[1],mid+1,r,mid+1,mr,p);
		}
	}
	void InsertQuery(int u,int l,int r,int pos,pair<int,pair<int,int> > p){
		a[u].y.push_back(p);
		if(l==r)
			return;
		int mid=(l+r)>>1;
		if(pos<=mid)
			InsertQuery(a[u].ch[0],l,mid,pos,p);
		else
			InsertQuery(a[u].ch[1],mid+1,r,pos,p);
	}
	void Calc(int u,int l,int r){
		if(!a[u].x.empty()&&!a[u].y.empty()){
			Scan::Init(a[u].x,a[u].y);
			Scan::Run();
		}
		if(l==r)
			return;
		int mid=(l+r)>>1;
		Calc(a[u].ch[0],l,mid);
		Calc(a[u].ch[1],mid+1,r);
	}
}/*}}}*/
void ReadData(){/*{{{*/
	using IO::GetInt;
	int tot=GetInt();
	static int pos[N][2],tim[N][2],que[N][3];
	for(int i=1;i<=tot;i++){
		int opt,x,y;
		opt=GetInt();
		switch(opt){
			case 1: x=GetInt(); y=GetInt();
					n++;
					pos[n][0]=x; pos[n][1]=y;
					tim[n][0]=++m;
					break;
			case 2: x=GetInt();
					tim[x][1]=++m;
					break;
			case 3: x=GetInt(); y=GetInt();
					q++;
					que[q][0]=x; que[q][1]=y; que[q][2]=++m;
					break;
		}
	}
	for(int i=1;i<=n;i++)
		if(tim[i][1]==0)
			tim[i][1]=++m;
	Seg::Build(Seg::rt,1,m);
	for(int i=1;i<=n;i++)
		Seg::InsertPoint(Seg::rt,1,m,tim[i][0],tim[i][1],MP(pos[i][0],pos[i][1]));
	for(int i=1;i<=q;i++){
		Seg::InsertQuery(Seg::rt,1,m,que[i][2],MP(i,MP(que[i][0],que[i][1])));
		ans[i]=-1;
	}
}/*}}}*/
int main(){
	IO::Init();
	IO::Load();
	ReadData();
	Seg::Calc(Seg::rt,1,m);
	for(int i=1;i<=q;i++) printf("%lld\n",ans[i]);
	return 0;
}
```

