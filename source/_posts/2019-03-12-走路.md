---
title: 走路
date: 2019-03-08 15:18:46
tags: [DP---背包,DP---优化,好题]
mathjax: true
---

# Description

一开始，你在数轴上的$0$位置

在$1,2,\dots,n$位置上，分别有一个物品，第$i$个物品的重量为$a_i$

你每移动$1$个单位长度所需的体力，为携带物品重量之和加上$1$

初始时，你有$m$点体力。求在不透支体力的情况下（即体力大于等于零），你最多能携带多重的物品回到$0$位置？

$n \le 10^5, \ m \le 10^6$

<!-- more -->

# Solution

先分析策略：最优走法显然是先直接走到最远的某个地方，然后一路往回走，并拿上需要的物品

可以列出一个显然背包：$f_{i,j}​$表示考虑完前$i​$个物品，携带物品重量为$j​$时，最少消耗体力是多少。每个物品对体力的贡献显然可以分开考虑，则有：
$$
f_{i,j}=\min \{ f_{i-1,j}, f_{i-1,j-a_i}+i*a_i \}
$$
每计算完$f_i​$，我们都需要对每个$j​$判定$f_{i,j}​$是否可以考虑进答案。由于体力内还含有默认的$1​$的代价，所以判定条件就是$f_{i,j}+2i \le m​$

时间复杂度$O(nm)$

注意到背包是一个NPC问题，因此我们只能在去除冗杂转移的方面下功夫。注意到这个背包的特殊之处：物品代价、收益和编号被关联在了一起（$i*a_i$，$a_i$，$i$），如何利用？

我们按$i$从大到小转移，先列出DP式：
$$
f_{i,j}=\min \{ f_{i+1,j}, f_{i+1,j-a_i}+i*a_i \} \\
f_{i,a_i}=\min \{ f_{i,a_i}, 2i+ia_i \}
$$
第二个转移把答案贡献的判断也省了

这个DP显然可以滚动

打表找找有效转移，我们发现只有$ij \le m​$的$j​$能被更新，为什么呢？当$ij > m​$时，我们选取了总价值为$j​$的物品，不妨设选择物品下标为$i<p_1<p_2<\dots<p_k​$，且满足$\sum_{l=1}^ka_{p_l}=j​$，此时总代价为$\sum_{l=1}^kp_la_{p_l}​$。注意到代价的每一项$p_l a_{p_l}​$都大于等于$ia_{p_l}​$，因此代价$\sum_{l=1}^kp_la_{p_l} \ge \sum_{l=1}^k ia_{p_l}=ij​$。若$ij>m​$，总代价直接超出上界，显然不能转移。因此对于每一个$i​$，只有$j \le \frac mi​$的位置需要转移，其余直接继承

所以最后的时间复杂度将到了调和级数级别，一个$\log$出解

# Code

```c++
#include <cstdio>
#include <algorithm>
using std::max;
using std::min;
const int INF=1e9;
const int N=100000+10;
const int X=1000000+10;
int n,x;
int a[N];
void ReadData(){
	scanf("%d%d",&n,&x);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
}
void DP(){
	static int f[X];
	f[0]=0;
	for(int j=1;j<=x;j++) f[j]=INF;
	for(int i=n;i>=1;i--)
		if(1ll*i*a[i]<=x){
			for(int j=x/i;j>a[i];j--)
				f[j]=min(f[j],f[j-a[i]]+i*a[i]);
			f[a[i]]=min(f[a[i]],2*i+i*a[i]);
		}
	for(int j=x;j>=0;j--)
		if(f[j]<=x){
			printf("%d\n",j);
			return;
		}
}
int main(){
	ReadData();
	DP();
	return 0;
}
```

