---
title: 与运算
mathjax: true
date: 2019-03-23 11:01:53
tags: []
---

# Description

给定一个长度为$n$的序列$a_1,a_2,\dots,a_n$

定义$b_i$表示序列前$i$项依次进行二进制与运算后的结果

现在，你可以对$a_i$重新排列，请最大化$\sum_{i=1}^n b_i$

$n,a_i \le 10^6 $

<!-- more -->

# Solution

最终的序列肯定是选定了某些元素放在前面最大化价值，而让一些相对无用的元素放在后面

考虑两个元素$x​$和$y​$，若在二进制下$y \subseteq x​$，则若选择了$y​$放在前面，则将$x​$也排在$y​$前面一定不会更劣

从后往前DP“前面的元素”：设$f_{i}$表示从前往后的$b$刚好等于$i$时，之后的$b_i$之和最大为多少
$$
f_{i}=\max \left\{ f_j + j \times (cnt_j-cnt_i) \mid j \subset i \right \}
$$
其中$cnt_x​$表示有多少元素$a_i​$满足$x \subseteq a_i​$

时间复杂度$O(n^2)$

我们可以把$f_i$的定义改成“从前往后的$b$包含或等于$i$“，这样转移时就只需要枚举只比$i$少一位1的那些$j$即可

$cnt_i$用FWT算一下

时间复杂度$O(n \log n)$

~~上述纯属口胡，我自己都不太明白~~

# Code

```c++
#include <cstdio>
#include <algorithm>
using std::max;
typedef long long LL;
const int N=1000000+10;
const int B=20;
const int S=(1<<B);
inline int bit2(int s,int i){
    return (s>>i)&1;
}
inline int bas2(int i){
    return 1<<i;
}
namespace IO{
    const int LEN=20000000;
    char *inBuf,*inPtr;
    void Init(){
        inBuf=new char[LEN];
    }
    void Load(){
        fread(inBuf,1,LEN,stdin);
        inPtr=inBuf;
    }
    char GetChar(){
        return *(inPtr++);
    }
    int GetInt(){
        int x=0,f=1;
        char c=GetChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=GetChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=GetChar();}
        return x*f;
    }
}
int n;
LL a[S];
void ReadData(){
    using IO::GetInt;
    n=GetInt();
    for(int i=1;i<=n;i++) a[GetInt()]++;
}
void FWT(LL *a,int n){
    for(int i=2;i<=n;i<<=1)
        for(int j=0;j<n;j+=i)
            for(int k=0;k<(i>>1);k++)
                a[j+k]+=a[j+(i>>1)+k];
}
void Solve(){
    FWT(a,S);
    static LL f[S];
    for(int i=1;i<S;i++)
        for(int j=0;j<B;j++)
            if(bit2(i,j))
                f[i]=max(f[i],f[i^bas2(j)]+(a[i^bas2(j)]-a[i])*(i^bas2(j)));
    printf("%lld\n",f[S-1]);
}
int main(){
    IO::Init();
    IO::Load();
    ReadData();
    Solve();
    return 0;
}
```

