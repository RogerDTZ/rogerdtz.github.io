---
title: 毛毛虫
mathjax: true
date: 2019-03-24 10:37:21
tags: [树链剖分,适应,好题]
---

# Description

给一棵$n$个点的树，每个点$i$有点权，初始为$w_i$

你需要支持$q$次操作，每次操作为以下两种操作之一：

1. 将路径$(x,y)$上的点和路径$(x,y)$的相邻点的点权加上$c$
2. 询问路径$(x,y)$上的点和路径$(x,y)​$的相邻点的点权之和

$n \le 10^5$，$q \le 2 \times 10^5$，$w_i,c \le 10^6$

<!-- more -->

# Solution

猜测要使用树剖来维护，但使用一般的树剖序列并不能快速修改或查询一条重链及其相邻点的权值

考虑将所有点按“父亲的树剖序”为第一关键字从小到大、”自己的树剖序“为第二关键字从大到小排序，构成一个新序列

此时我们发现：对于一条重链及其相邻点，除了链顶和链顶父亲这两个点之外，其余所有点在新序列上都处于一段区间内。如果排序时不设置第二关键字，就无法保证一个父亲的重儿子排在轻儿子之后，会出现混乱

记$left_u$表示$u$的所有儿子在新序列上最早出现的位置，$right_u$表示$u$的所有儿子在新序列上最晚出现的位置。这样一来，查询和修改就可以像普通树剖一样在新序列上操作了。每次考虑一条重链时，没考虑到的链顶会在下次迭代时考虑到，最后单独考虑一下结束点及其父亲即可

注意：将查询或询问拆分成两条链后，$lca$的所有儿子会被多考虑一次，所以要抵消一下

时间复杂度$O(n \log^2 n)​$，用树状数组实现跑得飞快

# Code

```c++
#include <cstdio>
#include <algorithm>
using std::min;
using std::max;
using std::sort;
typedef long long LL;
const int INF=1e9;
const int N=100000+10;
int n;
int w[N];
int locCnt,loc[N],who[N],top[N],loc2[N],who2[N];
int left[N],right[N];
namespace BIT{/*{{{*/
	const int N=(::N);
	int n;
	LL c1[N],c2[N];
	void SetRange(int _n){
		n=_n;
		for(int i=1;i<=n;i++) c1[i]=c2[i]=0;
	}
	void Add(int x,LL y){
		for(int i=x;i&&i<=n;i+=i&-i){
			c1[i]+=y;
			c2[i]+=x*y;
		}
	}
	LL Que(int x){
		LL res=0;
		for(int i=x;i;i-=i&-i) res+=(x+1)*c1[i]-c2[i];
		return res;
	}
	void AddSeg(int l,int r,LL x){
		if(l>r)
			return;
		Add(l,+x);
		Add(r+1,-x);
	}
	LL QueSeg(int l,int r){
		if(l>r)
			return 0;
		return Que(r)-Que(l-1);
	}
}/*}}}*/
namespace Tree{
	const int N=(::N);
	int h[N],tot;
	struct Edge{
		int v,next;
	}e[N*2];
	int pre[N];
	int dep[N];
	int size[N];
	int son[N];
	void AddEdge(int u,int v){
		e[++tot]=(Edge){v,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,h[v]}; h[v]=tot;
	}
	void DissectionDFS1(int u,int fa){
		dep[u]=dep[fa]+1;
		pre[u]=fa;
		size[u]=1;
		son[u]=-1;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa){
				DissectionDFS1(v,u);
				size[u]+=size[v];
				if(son[u]==-1||size[v]>size[son[u]])
					son[u]=v;
			}
	}
	void DissectionDFS2(int u,int _top){
		locCnt++;
		loc[u]=locCnt;
		who[locCnt]=u;
		top[u]=_top;
		if(son[u]==-1)
			return;
		DissectionDFS2(son[u],top[u]);
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=pre[u]&&v!=son[u])
				DissectionDFS2(v,v);
	}
	bool CmpFa(const int &x,const int &y){
		return loc[pre[x]]!=loc[pre[y]]?loc[pre[x]]<loc[pre[y]]:loc[x]>loc[y];
	}
	void Dissection(){
		DissectionDFS1(1,0);
		DissectionDFS2(1,1);
		for(int i=1;i<=n;i++) who2[i]=i;
		sort(who2+1,who2+1+n,CmpFa);
		for(int i=1;i<=n;i++) loc2[who2[i]]=i;
		for(int u=1;u<=n;u++){
			left[u]=INF;
			right[u]=loc2[u];
			for(int i=h[u],v;i;i=e[i].next)
				if((v=e[i].v)!=pre[u]){
					left[u]=min(left[u],loc2[v]);
					right[u]=max(right[u],loc2[v]);
				}
		}
	}
	int GetLCA(int a,int b){
		for(;top[a]!=top[b];dep[top[a]]>dep[top[b]]?a=pre[top[a]]:b=pre[top[b]]);
		return dep[a]<dep[b]?a:b;
	}
	void ModifyChain(int a,int lca,int val){
		for(;dep[top[a]]>=dep[lca];a=pre[top[a]])
			BIT::AddSeg(left[top[a]],right[a],val);
		if(dep[a]>=dep[lca])
			BIT::AddSeg(left[lca],right[a],val);
	}
	void Modify(int a,int b,int c){
		int lca=GetLCA(a,b);
		ModifyChain(a,lca,c);
		ModifyChain(b,lca,c);
		BIT::AddSeg(left[lca],right[lca],-c);
		BIT::AddSeg(loc2[lca],loc2[lca],c);
		if(pre[lca])
			BIT::AddSeg(loc2[pre[lca]],loc2[pre[lca]],c);
	}
	LL QueryChain(int a,int lca){
		LL res=0;
		for(;dep[top[a]]>=dep[lca];a=pre[top[a]])
			res+=BIT::QueSeg(left[top[a]],right[a]);
		if(dep[a]>=dep[lca])
			res+=BIT::QueSeg(left[lca],right[a]);
		return res;
	}
	LL Query(int a,int b){
		int lca=GetLCA(a,b);
		LL res=0;
		res+=QueryChain(a,lca);
		res+=QueryChain(b,lca);
		res-=BIT::QueSeg(left[lca],right[lca]);
		res+=BIT::QueSeg(loc2[lca],loc2[lca]);
		if(pre[lca])
			res+=BIT::QueSeg(loc2[pre[lca]],loc2[pre[lca]]);
		return res;
	}
}
void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		Tree::AddEdge(u,v);
	}
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
}
void BuildBIT(){
	BIT::SetRange(n);
	for(int i=1;i<=n;i++)
		BIT::AddSeg(i,i,w[who2[i]]);
}
void AnswerQuery(){
	int q;
	int opt,a,b,c;
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		scanf("%d",&opt);
		switch(opt){
			case 1: scanf("%d%d%d",&a,&b,&c);
					Tree::Modify(a,b,c);
					break;
			case 2: scanf("%d%d",&a,&b);
					printf("%lld\n",Tree::Query(a,b));
					break;
		}
	}
}
int main(){
	ReadData();
	Tree::Dissection();
	BuildBIT();
	AnswerQuery();
	return 0;
}
```

