---
layout: post
mathjax: true
title: 数组
date: 2018-09-28 19:35:27
tag: [数据结构---维护题,数据结构---线段树,分类讨论]
category: 2016北京集训
---
# Description

　　给你一个数组，每个元素都有一个颜色。要求支持两种操作：

　　修改某个元素的颜色。

　　询问这个数组有多少个子区间内没有重复的颜色。

　　（只是为了凑摘要）



![](http://xsy.gdgzez.com.cn/JudgeOnline/upload/attachment/image/20160325/20160325103034_56635.jpg)


<!-- more -->
# Solution

　　[【BZOJ4059】](https://rogerdtz.github.io/2018/06/21/BZOJ4059/)是一道类似的题。由于那题是单次询问，所以可以化成平面染色覆盖问题，用扫描线求解

　　然而本题是动态询问，扫描线一类的东西难以支持实时查询。可是考场上我还是依着这个思路死磕了好一会

　　打完暴力后，我体会了一下统计答案的方式：对于每一个固定的右端点$i$，其左端点能往左走的最远位置应该是$\max (pre_j\mid 1 \le j \le i )+1$，其中$pre_i$表示上一个和$i​$颜色相同的位置

　　而答案也就可以表示成：

$$
\begin{aligned}
Ans&=\sum_{i=1}^n(i-\max\{pre_j\mid 1 \le j \le i\})\\
&=\sum_{i=1}^ni-\sum_{i=1}^n\max\{pre_j\mid 1 \le j \le i\}
\end{aligned}
$$

　　我们只需要专注维护后面一部分的值即可

　　这个问题要求我们提供一个能够维护每个前缀信息的算法。运用分治思想，我们尝试使用线段树合并两段信息，以达到维护的目的

　　一个线段树节点$[l,r]$记一个值$sum$，表示

$$
\sum_{i=l}^r\max\{pre_j\mid l \le j \le i\}
$$

　　即每一个位置到该段左端点的$\max$，之和

　　叶子节点的$sum$即该位置的$pre$

　　下面考虑上推$lc$、$rc$到父节点$u$，计算$u$的$sum$

　　$sum_{lc}$在新的线段中意义没有改变，我们将其直接加到$sum_u$上

　　而$sum_{rc}$的$\sum$中的每一个元素，都要继续$\max$上$lc$代表线段的各个位置的值，因此当下我们不能直接用$sum_{rc}$累加到$sum_u$

　　既然$n$的范围是$10^5$，我们完全受得住两个$\log$的算法。对于无法解决的信息，我们不妨使用多一个$\log$，递归右儿子解决

　　记$d=\max_{lc}$

　　递归直接调用$calc(rc)$，设当前递归节点为$u$，左右儿子为$lc$和$rc$，区间为$[l,r]$

- 如果$u$的整一段$[l,r]$的$\max$都不超过$d$，这意味着$\sum$中的每一个$\max$最终都会受$d$影响变成后者，因此返回$d * (r-l+1)$

- 套路：如果整段不满足，考虑左半边$[l,mid]$是否满足整段的值都不超过$d$

  - 若满足，则返回$d * (mid-l+1)$加上递归右半边的结果

  - 若不满足，左半边的结果递归计算；

    对于右半边的每一个位置，原本它们只$\max$到$mid+1$，现在一直$\max$到$l$

    由于从左往右看，每个位置计算的$\max$单调不减，因此当前的情形恰好为$d<\max_{lc}$，也就是右半边元素在往左扩展时，$lc$带来的影响已经大大超过$d$，后者不起作用。至于$d$对应区间的右边一直到$l$左边这段区间的每个位置的值，我们回头考虑递归过程：我们之所以往右递归，是因为左半边影响力都不及$d$，而当下$d$不及$\max_{lc}$，更可以忽略它们

    因此右半边的贡献其实就是每个元素在$[l,r]$意义下的结果之和：$sum_u-sum_{lc}$（之所以不用$sum_{rc}$，是因为$sum_{rc}$计算的是右半边每个元素在$(mid,r]$意义下的结果）

　　至此我们在$O(n \log ^2 n)$内解决了修改。至于外层的$pre$维护，只需要用set做一下就好了，其复杂度不是瓶颈

# Summary

　　扫描线做法一般只能处理单次总体询问的题目。因此如果题目涉及多次询问，那就换一个角度做吧

　　对于前缀信息问题或者区间信息问题，如果我们能够支持合并两段信息、或者两段要维护的东西，我们不妨直接用线段树套上这个合并过程来维护全局

　　这种做法中，分类讨论非常重要

　　在合并过程中，如果某一半遇到了难以考虑的情况，在时间允许的情况下（多一个$\log$），可以尝试递归并分类处理

　　线段树套路：若整段ok返回；左段ok的话利用左段信息加上右边递归计算的值；左段不ok就进去递归，并看看能不能直接考虑右段发生了生么变化

# Code

```c++
#include <cstdio>
#include <set>
#define FR first
#define SE second
using namespace std;
namespace IO{
    const int S=10000000;
    char buf[S];
    int pos;
    void load(){
        fread(buf,1,S,stdin);
        pos=0;
    }
    char getChar(){
        return buf[pos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
typedef long long ll;
const int N=100010;
int n;
int a[N];
int pre[N];
set<int> ps[N];
inline int max(int x,int y){
    return x>y?x:y;
}
namespace SEG{
    const int S=N*2;
    int rt,sz;
    int ch[S][2];
    int mxs[S];
    ll sum[S];
    ll calc(int u,int l,int r,int stdval){
        if(mxs[u]<=stdval)
            return 1ll*stdval*(r-l+1);
        if(l==r)
            return sum[u];
        int mid=(l+r)>>1;
        if(mxs[ch[u][0]]<=stdval)
            return 1ll*stdval*(mid-l+1)+calc(ch[u][1],mid+1,r,stdval);
        else
            return calc(ch[u][0],l,mid,stdval)+(sum[u]-sum[ch[u][0]]);
    }
    void pushup(int u,int l,int r){
        int mid=(l+r)>>1;
        mxs[u]=max(mxs[ch[u][0]],mxs[ch[u][1]]);
        sum[u]=sum[ch[u][0]]+calc(ch[u][1],mid+1,r,mxs[ch[u][0]]);
    }
    void build(int &u,int l,int r){
        u=++sz;
        if(l==r){
            mxs[u]=sum[u]=pre[l];
            return;
        }
        int mid=(l+r)>>1;
        build(ch[u][0],l,mid);
        build(ch[u][1],mid+1,r);
        pushup(u,l,r);
    }
    void modify(int u,int l,int r,int pos,int val){
        if(l==r){
            sum[u]=mxs[u]=val;
            return;
        }
        int mid=(l+r)>>1;
        if(pos<=mid)
            modify(ch[u][0],l,mid,pos,val);
        else
            modify(ch[u][1],mid+1,r,pos,val);
        pushup(u,l,r);
    }
    ll query(){
        return 1ll*n*(n+1)/2-sum[rt];
    }
}
void readData(){
    n=getInt();
    for(int i=1;i<=n;i++) a[i]=getInt();
}
void init(){
    for(int i=1;i<=n;i++) ps[a[i]].insert(i);
    static int last[N];
    for(int i=1;i<=n;i++){
        pre[i]=last[a[i]];
        last[a[i]]=i;
    }
}
void change(int x,int y){
    set<int>::iterator pos,mo;
    pos=ps[a[x]].find(x);
    pos++;
    ps[a[x]].erase(x);
    if(pos!=ps[a[x]].end()){
        int cur=(*pos);
        if(pos!=ps[a[x]].begin()){
            pos--;
            pre[cur]=(*pos);
        }
        else pre[cur]=0;
        SEG::modify(SEG::rt,1,n,cur,pre[cur]);
    }
    a[x]=y;
    mo=pos=ps[a[x]].insert(x).FR;
    if(pos==ps[a[x]].begin())
        pre[x]=0;
    else{
        pos--;
        pre[x]=(*pos);
    }
    SEG::modify(SEG::rt,1,n,x,pre[x]);
    mo++;
    if(mo!=ps[a[x]].end()){
        pre[(*mo)]=x;
        SEG::modify(SEG::rt,1,n,(*mo),x);
    }
}
void answerQuery(){
    int q,opt,x,y;
    q=getInt();
    while(q--){
        opt=getInt();
        if(!opt)
            printf("%lld\n",SEG::query());
        else{
            x=getInt(); y=getInt();
            change(x,y);
        }
    }
}
int main(){
    IO::load();
    readData();
    init();
    SEG::build(SEG::rt,1,n);
    answerQuery();
    return 0;
}
```

