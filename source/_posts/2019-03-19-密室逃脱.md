---
title: 密室逃脱
mathjax: true
date: 2019-03-19 08:52:09
tags: [DP]
---

# Description

有$n$个房间排成一排，相邻两个房间之间有一扇门关闭的门相隔

门是可以被打开的。对于连接第$i$个和第$i+1$个房间的门，若第$i$个房间有$a_i$个人按住开关，或第$i+1$个房间有$b_i$个人按住开关，则门会被打开。按开关的人不能执行诸如移动的其他操作，但其余的人可以通过这扇门前往其他房间

如果第$1$个房间聚集了$m$个或以上的人，参与者胜利。作为一个黑心经营者，你需要为每一个房间安排一定数目的人，使得在总人数最多的情况下，参与者永远不可能胜利。请求出这个人数最大值

$n \le 1000$，$1 \le m, a_i, b_i, \le 10000$

<!-- more -->

# Solution

设$f_{i,j}$表示：$i \dots n$这些房间的所有人，能到达房间$i$的最大人数恰好为$j$时，这些房间最多能安排多少人

初始有$f_{n,i}=i$

* 若$j < b_{i-1}$：
	* $f_{i,j}+k \rightarrow f_{i-1,k}, \ k \in [0,a_{i-1})$：对应房间$i-1$和$i$中的人都不能把第$i-1$扇门按开的情况，此时出现分隔
	* $f_{i,j}+a_{i-1} \rightarrow f_{i-1,j+a_{i-1}}$：对应房间$i-1$中的人能按开第$i-1$扇门并让$j$个人过来的情况。注意我们只新分配了恰好$a_{i-1}$个人按门，额外的人是在后续步骤中补上的
* 若$b_{i-1} \le j < b_{i-1}+a_{i-1}$：
	* $f_{i,j} \rightarrow f_{i-1,j-b_i}$：对应房间$i$中的人按开第$i-1$扇门并让其余人通过的情况
* 若$j \ge b_{i-1}+a_{i-1}$：
	* $f_{i,j} \rightarrow f_{i-1,j}$：对应房间$i$中的人可以全部移动到房间$i-1$的情况（先按右边，过去的人按左边，右边的再过来）

答案即$\max_{i=0}^{m-1} \{ f_{1,i} \}$

时间复杂度$O(n \max\{m,a_i,b_i\})$

# Code

这里写的是题解的奇怪DP方式，本质上和上述DP是一样的，不过是从前往后，理解起来非常奇怪。还是从后往前转移比较直观

```c++
#include <cstdio>
#include <cstring>
const int INF=1e9;
const int N=1000+10;
const int M=10000+10;
inline void applyMax(int &x,int y){
	x=(y>x)?y:x;
}
int n,m;
int a[N],b[N],maxs;
void ReadData(){
	scanf("%d%d",&n,&m);
	maxs=m;
	for(int i=1;i<n;i++){
		scanf("%d%d",&a[i],&b[i]);
		applyMax(maxs,a[i]+b[i]);
	}
}
void DP(){
	static int f[N][M*2];
	memset(f,0x80,sizeof(f));
	for(int j=0;j<m;j++) f[1][j]=j;
	for(int i=1;i<n;i++){
		int prefix=-INF;
		for(int j=0;j<=maxs;j++)
			if(f[i][j]>-INF){
				if(j<a[i]){
					applyMax(f[i+1][j+b[i]],f[i][j]+b[i]);
					applyMax(prefix,f[i][j]);
				}else if(j<a[i]+b[i]){
					applyMax(f[i+1][j-a[i]],f[i][j]);
				}else{
					applyMax(f[i+1][j],f[i][j]);
				}
			}
		for(int j=0;j<b[i];j++)
			applyMax(f[i+1][j],prefix+j);
	}
	int ans=0;
	for(int j=0;j<=maxs;j++) applyMax(ans,f[n][j]);
	printf("%d\n",ans);
}
int main(){
	ReadData();
	DP();
	return 0;
}
```

