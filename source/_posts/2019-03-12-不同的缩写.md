---
title: 不同的缩写
date: 2019-03-06 15:05:21
tags: [二分答案,二分图匹配]
mathjax: true
---

# Description

给定$n​$个字符串$a_1,a_2,\dots,a_n​$，你需要为每一个字符串$a_i​$定义一个缩写$b_i​$，使得所有$b_i​$互不相同，其中$b_i​$是$a_i​$的任意非空子序列

请最小化$b_i​$的最长长度

$n \le 300,\  \mid a_i \mid \le 300$

<!-- more -->

# Solution

显然要先二分答案$x$，判定只使用长度不超过$x$的子序列是否能满足要求

考虑一个$a_i$的所有长度不超过$x$的子序列构成的集合$S_i$，我们发现只要$\mid S_i \mid \ge n$，$a_i$一定可以从中选出一个$b_i$使得$b_i​$与他人不相冲突

我们不妨对于每一个$a_i$搜索出长度不超过$x$的不同子序列，搜够$n​$个就可以退出。实现上可以用一棵Trie判断是否重复

现在，由于题目要求一一对应不可重复，我们只需要把所有$a_i$和所有人搜出来的子序列的集合进行二分图匹配即可

时间复杂度$O(n^3)​$

# Summary

$n$个人，每个人都有大量选择，而两两选择不可相同时，注意到每个人只要准备$n$种不同的选择就可以应付所有情况

# Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using std::max;
using std::min;
const int INF=1e9;
const int N=300+10;
const int LEN=300+10;
int n;
char str[N][LEN];
int len[N],maxLen;
void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%s",str[i]+1);
		len[i]=strlen(str[i]+1);
		maxLen=max(maxLen,len[i]);
	}
}
namespace Flow{
	const int N=((::N)*(::N)+(::N))*3;
	const int M=((::N)*(::N)*2+(::N))*3;
	int h[N];
	struct Edge{
		int v,f,next;
	}e[M*2];
	int tot;
	int flowS,flowT;
	int dis[N],cur[N];
	void Init(){
		for(int i=1;i<=flowT;i++) h[i]=0;
		tot=1;
	}
	void SetST(int s,int t){
		flowS=s;
		flowT=t;
	}
	void AddEdge(int u,int v,int f){
		e[++tot]=(Edge){v,f,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,0,h[v]}; h[v]=tot;
	}
	void AddEdgeFromS(int u,int f){
		AddEdge(flowS,u,f);
	}
	void AddEdgeToT(int u,int f){
		AddEdge(u,flowT,f);
	}
	bool BFS(){
		static int q[N],head,tail;
		head=1; tail=0;
		for(int i=1;i<=flowT;i++){
			dis[i]=-1;
			cur[i]=h[i];
		}
		dis[flowS]=1;
		q[++tail]=flowS;
		while(head<=tail){
			int u=q[head++];
			for(int i=h[u],v;i;i=e[i].next)
				if(e[i].f&&dis[v=e[i].v]==-1){
					dis[v]=dis[u]+1;
					if(v==flowT)
						return true;
					q[++tail]=v;
				}
		}
		return dis[flowT]!=-1;
	}
	int DFS(int u,int flow){
		if(u==flowT)
			return flow;
		int res=0,x;
		for(int i=cur[u],v;i&&flow;i=e[i].next)
			if(e[i].f&&dis[v=e[i].v]==dis[u]+1){
				x=DFS(v,min(flow,e[i].f));
				e[i].f-=x;
				e[i^1].f+=x;
				if(e[i].f>0)
					cur[u]=i;
				flow-=x;
				res+=x;
			}
		if(res==0)
			dis[u]=-1;
		return res;
	}
	int Dinic(){
		int res=0;
		while(BFS())
			res+=DFS(flowS,INF);
		return res;
	}
}
int nodeCnt;
int ch[N*N][26];
int lastVis[N*N];
char seq[N*N][LEN];
int seqLen[N*N];
int totGet;
void DFS(int i,int x,int len,int limit,char *path,int u){
	if(x>0){
		if(seqLen[u]==0){
			memcpy(seq[u],path,sizeof(char)*len);
			seqLen[u]=len;
		}
		lastVis[u]=i;
		Flow::AddEdge(i,n+u,1);
		totGet++;
		if(totGet==n)
			return;
	}
	if(len==limit)
		return;
	for(int y=x+1;y<=::len[i];y++){
		int c=str[i][y]-'a';
		if(ch[u][c]==0||(ch[u][c]!=0&&lastVis[ch[u][c]]<i)){
			if(ch[u][c]==0)
				ch[u][c]=++nodeCnt;
			path[len]=str[i][y];
			DFS(i,y,len+1,limit,path,ch[u][c]);
			if(totGet==n)
				return;
		}
	}
}
bool Judge(int x){
	for(int i=0;i<=nodeCnt;i++){
		seqLen[i]=0;
		lastVis[i]=0;
		for(int j=0;j<26;j++)
			ch[i][j]=0;
	}
	nodeCnt=0;
	Flow::Init();
	for(int i=1;i<=n;i++){
		totGet=0;
		static char str[LEN];
		DFS(i,0,0,x,str,0);
	}
	Flow::SetST(n+nodeCnt+1,n+nodeCnt+2);
	for(int i=1;i<=n;i++) Flow::AddEdgeFromS(i,1);
	for(int i=1;i<=nodeCnt;i++) Flow::AddEdgeToT(n+i,1);
	return Flow::Dinic()==n;
}
void Solve(){
	int l=1,r=maxLen,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(Judge(mid))
			r=mid-1;
		else
			l=mid+1;
	}
	if(l<=maxLen){
		printf("%d\n",l);
		Judge(l);
		for(int i=1;i<=n;i++){
			for(int j=Flow::h[i];j;j=Flow::e[j].next)
				if(Flow::e[j].f==0&&Flow::e[j].v<=n+nodeCnt){
					int x=Flow::e[j].v-n;
					for(int k=0;k<seqLen[x];k++) putchar(seq[x][k]);
					puts("");
					break;
				}
		}
	}else{
		puts("-1");
	}
}
int main(){
	ReadData();
	Solve();
	return 0;
}
```

