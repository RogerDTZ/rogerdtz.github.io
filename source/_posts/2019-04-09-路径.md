---
title: 路径
mathjax: true
date: 2019-04-09 16:48:14
tags: [分数规划,随机化]
---

# Description

给定一棵$n$个点的点带权无根树，你要进行以下两步操作：

1. 选择一个$[0,T]$之间的整数$C$，并令所有点的点权$w_i$变为$(w_i + C) \bmod P$
2. 选择若干条点不相交路径。设选择的路径条数为$k$，覆盖的点的点权和为$S$，则收益为$\frac {S}{k+1}$

求最大收益

$n \le 5000$，$0 \le w_i,T < P\le 10^5$

<!-- more -->

# Solution

考虑枚举$C$，然后计算最大收益。注意到我们并不需要将$C$取遍$[0,T]$，因为贪心地使某个点的点权增大到$P-1$肯定是最优的策略，所以总共只有$O(n)$个值需要计算

看到收益表达式为分数，果断尝试分数规划。二分收益是否能大于等于$x$，则有
$$
\frac {S}{k+1}\ge x \\
S\ge x(k+1) \\
(S_1-x)+(S_2-x)+\dots+(S_k-x)\ge x
$$
即每一条路径都要额外付出$-x$的代价

在树上做一个$O(n)$DP就可以算出最大值，与$x$作比较即可

现在我们就有了一个$O(n^2 (-\log \varepsilon))​$的算法

接下来怎么优化呢？考虑到**随机序列的最长上升子序列的期望长度是$O(\log n)$**这个性质，我们不妨将待枚举的$C$的序列`random_shuffle`一下，这样每个$C$的最大收益构成的序列就是一个随机序列。在每次枚举时，先调用一次树型DP判断一下答案是否比当前最优值更优，如果可能再进行二分。这样一来，就只有$O(\log n)$个$C$需要二分计算，其余都是$O(n)$判断就退出。此时的复杂度变为$O(n^2 + n \log n (-\log \varepsilon))$

# Summary

分数规划的确能省掉不少信息维度，在放弃前多想想自己是不是没有仔细考虑它的可能性

随机序列的最长上升子序列的期望长度是$\log$的，求若干个元素的最大值但精细求解比较慢、判断比较快时可以考虑这个玄学算法

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <cmath>
using std::sort;
using std::unique;
using std::random_shuffle;
const double DINF=1e40;
const int N=100000+10;
inline double max(double x,double y){
	return x>y?x:y;
}
inline int min(int x,int y){
	return x<y?x:y;
}
int n;
int P,T;
int val0[N],val[N];
namespace Picker{
	double x0,x1;
	void Reset(){
		x0=x1=-DINF;
	}
	void Insert(double x){
		if(x>x0){
			x1=x0;
			x0=x;
		}else if(x>x1){
			x1=x; 
		}
	}
}
namespace Tree{
	const int N=(::N);
	int h[N],tot;
	struct Edge{
		int v,next;
	}e[N*2];
	double x;
	double f[N][2];
	void AddEdge(int u,int v){
		e[++tot]=(Edge){v,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,h[v]}; h[v]=tot;
	}
	void DP(int u,int fa){
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa)
				DP(v,u);
		static int son[N],scnt;
		static double sum;
		scnt=0;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa)
				son[++scnt]=v;
		sum=0;
		Picker::Reset();
		for(int i=1;i<=scnt;i++){
			sum+=f[son[i]][0];
			Picker::Insert(f[son[i]][1]-f[son[i]][0]);
		}
		f[u][0]=max(sum,val[u]-x);
		f[u][0]=max(f[u][0],sum+Picker::x0+val[u]);
		f[u][0]=max(f[u][0],sum+Picker::x0+Picker::x1+x+val[u]);
		f[u][1]=sum+(val[u]-x);
		f[u][1]=max(f[u][1],sum+Picker::x0+val[u]);
	}
	bool Judge(double x){
		Tree::x=x;
		DP(1,0);
		return max(f[1][0],f[1][1])>=x;
	}
}
void ReadData(){
	scanf("%d%d",&n,&P);
	for(int i=1;i<=n;i++) scanf("%d",&val0[i]);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		Tree::AddEdge(u,v);
	}
	scanf("%d",&T);
}
void Solve(){
	static int c[N],ccnt;
	for(int i=1;i<=n;i++)
		c[++ccnt]=min(T,P-1-val0[i]);
	c[++ccnt]=0;
	sort(c+1,c+ccnt+1);
	ccnt=unique(c+1,c+ccnt+1)-c-1;
	random_shuffle(c+1,c+ccnt+1);
	double ans=0;
	for(int i=1;i<=ccnt;i++){
		for(int j=1;j<=n;j++) val[j]=(val0[j]+c[i])%P;
		if(ans>0){
			if(!Tree::Judge(ans))
				continue;
		}
		const static double STOP=1e-8;
		double l=ans,r=250000000,mid;
		while(r-l>STOP){
			mid=(l+r)*0.5;
			if(Tree::Judge(mid))
				l=mid;
			else
				r=mid;
		}
		ans=l;
	}
	printf("%.10lf\n",ans);
}
int main(){
	ReadData();
	Solve();
	return 0;
}
```

