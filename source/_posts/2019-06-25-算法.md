---
title: 算法
mathjax: true
date: 2019-06-25 09:11:04
tags: [计数问题,方案特征,好题]
---

# Description

给定一张$n$个点的无向连通图

不断重复一下过程

1. 找到一个三元组$(a,b,c)$，满足$1 \le a < b < c \le n$，$ab,ac$有连边，而$bc$无连边
2. 连接$bc$

直至不存在三元组为止

称得到的图为闭包图

求用$n$种颜色给$n$个点染色的方案，使得任意一条边的两个端点异色

$n \le 3 \times 10^5$

<!-- more -->

# Solution

首先考虑如何计算一个闭包图的染色方案

记$g_i$为满足$j>i$且$i$和$j$相邻的$j$的个数。根据闭包图的性质，这些$j$在$i$的参与下一定构成了一个完全图

不妨从后往前染色，那么$i$选择方案就是$n-g_i$。答案即$\prod_i (n-g_i)$

问题转化为快速求$g$

考虑在闭包图中任一相邻的点对在原图中的特征：点对$(a,b)$在闭包图中相邻，当且仅当在原图中存在一条从$a$到$b$的路径，满足中途经过的节点编号都小于$a$和$b$。充分性证明：每次我们挑选路径中编号最小的节点，把相邻两个节点连起来，然后删去这个点，最后一定能连上$a$和$b$。必要性证明：不妨假设原图所有$a$到$b$的路径都不满足条件，那么$a$和$b$永远连不起来，矛盾

考虑从小到大枚举当前点$i$，并计算$g_i$

我们需要的信息是：

1. 与$i$连通的、由$[1,i)$构成的所有连通块（仅需知道索引，并查集维护）
2. 每个上述连通块连向$[i,n]$中的点的集合（需要知道具体集合，用set记录）

$g_i$就是从$i$出发，走向$[1,i)$中的点，然后走到$(i,n]$中的某个点并立即停止的方案数

直接启发式合并所有相关连通块的set，从中删去$i$，再加上$i$往$(i,n]$连接的点。此时set的大小就是$g_i$

时间复杂度$O(n \log^2 n)$

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <vector>
#include <set>
 
using std::swap;
using std::set;
using std::vector;
 
const int MOD=998244353;
const int N=300000+10;
 
int n,m;
vector<int> e1[N],e2[N];
set<int> s[N];
int dsu[N];
 
void ReadData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++){
        int u,v;
        scanf("%d%d",&u,&v);
        if(u>v)
            swap(u,v);
        e1[v].push_back(u);
        e2[u].push_back(v);
    }
}
 
int FindDSU(int x){
    return (dsu[x]==x)?x:(dsu[x]=FindDSU(dsu[x]));
}
 
void Merge(set<int> &a,set<int> &b){
    if(a.size()>=b.size()){
        for(set<int>::iterator it=b.begin();it!=b.end();it++)
            a.insert(*it);
    }else{
        for(set<int>::iterator it=a.begin();it!=a.end();it++)
            b.insert(*it);
        swap(a,b);
    }
}
 
void Solve(){
    int ans=1;
    for(int x=1;x<=n;x++){
        dsu[x]=x;
        for(int i=0;i<int(e1[x].size());i++){
            int y=e1[x][i];
            if(x!=FindDSU(y))
                Merge(s[x],s[FindDSU(y)]);
            dsu[FindDSU(y)]=x;
        }
        s[x].erase(x);
        for(int i=0;i<int(e2[x].size());i++) s[x].insert(e2[x][i]);
        ans=1ll*ans*(n-s[x].size())%MOD;
    }
    printf("%d\n",ans>=0?ans:ans+MOD);
}
 
int main(){
    ReadData();
    Solve();
    return 0;
}
```

