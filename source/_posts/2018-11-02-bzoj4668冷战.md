---
layout: post
mathjax: true
title: 【BZOJ4668】冷战
date: 2018-11-02 19:33:00
tag: [可做未做,并查集]
category: BZOJ
---
# Description

 　　有$n$个点，请在线支持下列两种操作，操作共有$q$个

* 添加一条无向边$(u,v)$
* 询问$u$和$v$最早在加入第几条边时连通

　　$n,q\le 5*10^5$


<!-- more -->
# Solution

　　一上场想都没想直接9min码了LCT，拿到范围为10w的80分，剩余数据过于卡常

　　然后我就什么也没想出来了......我一直在思考如何不使用LCT维护树上连通性，然而这做不了

　　之后想到了几天前刚学的Kruskal重构树，还是无果

　　可我就是没想到按秩合并的普通并查集啊！Kruskal虽然能把边权体现在点上，但其连边方向固定，不能用启发式保证深度；而使用按秩合并的并查集时，边权体现在边上，且可以使用启发式保证树的深度

　　按秩合并的并查集树高仅为$\log$，因此，对于单次询问，我们只需要在并查集构成的树上暴力跳边求最大值即可



# Summary

　　对于连通性问题，考虑能否利用按秩合并的并查集树高为$\log$的这一性质，暴力扫描树上路径并回答询问

　　并查集构成的树结构虽然和原树不太一样，但是有关连通性的触发问题，答案还是能在并查集的树上路径中体现出来的



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
namespace IO{
    const int L=50000000;
    char inBuf[L],outBuf[L];
    int inPos,outPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        char c=getChar();
        int x=0,f=1;
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
    void writeChar(char c){
        outBuf[outPos++]=c;
    }
    void writeInt(int x,char endc='\n'){
        static int sta[20],top;
        if(!x)
            writeChar('0');
        else{
            for(top=0;x;x/=10) sta[++top]=x%10;
            for(;top;top--) writeChar('0'+sta[top]);
        }
        writeChar(endc);
    }
    void flush(){
        fwrite(outBuf,1,outPos,stdout);
    }
}
using IO::getInt;
using IO::writeInt;
const int N=500010;
int bel[N],h[N];
int faEdge[N];
int find(int u){
    return bel[u]==u?u:find(bel[u]);
}
void merge(int u,int v,int id){
    int fu=find(u),fv=find(v);
    if(fu==fv)
        return;
    if(h[fu]>h[fv])
        swap(fu,fv);
    bel[fu]=fv;
    if(h[fu]==h[fv])
        h[fv]++;
    faEdge[fu]=id;
}
int query(int u,int v){
    static int a[N][2],b[N][2],acnt,bcnt;
    acnt=bcnt=0;
    for(;bel[u]!=u;u=bel[u]){
        acnt++;
        a[acnt][0]=u;
        a[acnt][1]=faEdge[u];
    }
    for(;bel[v]!=v;v=bel[v]){
        bcnt++;
        b[bcnt][0]=v;
        b[bcnt][1]=faEdge[v];
    }
    for(int i=0;;i++)
        if(a[acnt-i][0]!=b[bcnt-i][0]){
            int res=0;
            for(int j=acnt-i;j>=1;j--) res=max(res,a[j][1]);
            for(int j=bcnt-i;j>=1;j--) res=max(res,b[j][1]);
            return res;
        }
}
int main(){
    IO::load();
    int n,m,edgeCnt=0;
    int opt,u,v;
    int ans=0;
    n=getInt(); m=getInt();
    for(int i=1;i<=n;i++) bel[i]=i, h[i]=1;
    for(int i=1;i<=m;i++){
        opt=getInt(); u=getInt(); v=getInt();
        u^=ans; v^=ans;
        if(opt==0)
            merge(u,v,++edgeCnt);
        else{
            if(find(u)!=find(v))
                ans=0;
            else
                ans=query(u,v);
            writeInt(ans);
        }
    }
    IO::flush();
    return 0;
}
```

 