---
layout: post
mathjax: true
title: 排序
date: 2019-01-09 21:17:00
tag: [模拟]
---
# Description

　　给一个$1 \dots n$的排列$a$，并对其执行如下排序算法：

　　![]({{site.url}}/assets/images/排序/1.png)

　　给定$x$，求$cnt$刚刚变为$x$时的$a​$

　　$n \le 10^6$



　　
<!-- more -->
# Solution

　　考虑模拟出完整的若干轮算法，再暴力模拟最后几次枚举

　　设外层循环将要进行$k$轮，记$p_x$为原序列中$x$的下标

　　考虑模拟这样一个过程：初始时，我们只考虑$1 \dots k $所在的位置，称他们为关键位置，并假装其他位置不存在；排序算法执行时，$i$和$j$都只枚举关键位置。我们要维护的东西是当前意义下的排序算法执行完毕后$1 \dots k$所处的位置集合$S$

　　初始时，$S=\{ p_1,p_2,\dots,p_k\}$。接下来，逐个将$k+1,k+2,\dots$加入关键位置，并维护$1\dots k$的位置集合。记新加入的数位置为$x$，如果我们重新做一遍排序算法，我们会发现$S$中不超过$x$的位置仍然在$S$中，$x$被加入了$S$，且原来$S$的最大值消失了。$1 \dots k$中，原本位置超过$x$的那些会在排序执行过程中不断与新加入的数交换，最终结果就是后面的数往前平移了一格，而新加入的数停在原来$S$的最大值处

　　特别地，如果$x$大于$S$的任意一个元素，那么新加入的数的位置就是原位置

　　用一个堆维护这个过程即可，时间复杂度$O(n \log n)$，应该可以做到线性

　　

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <queue>
using std::swap;
using std::priority_queue;
typedef long long LL;
namespace IO{
    const int LEN=40000000;
    char *inBuf;
    char *outBuf,*outCur;
    void init(){
        inBuf=new char[LEN];
        outBuf=outCur=new char[LEN];
        fread(inBuf,1,LEN,stdin);
    }
    void flush(){
        fwrite(outBuf,1,outCur-outBuf,stdout);
    }
    char getChar(){
        return *(inBuf++);
    }
    void writeChar(char c){
        *(outCur++)=c;
    }
    LL getInt(){
        char c=getChar();
        LL x=0,f=1;
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
    void writeInt(int x,char end=' '){
        if(!x){
            writeChar('0');
        }else{
            static int d[20],cnt;
            for(cnt=0;x;x/=10) d[++cnt]=x%10;
            for(;cnt;cnt--) writeChar('0'+d[cnt]);
        }
        writeChar(end);
    }
    void Enter(){
        writeChar('\n');
    }
}
using IO::getInt;
using IO::writeInt;
const int N=1000000+10;
int n;
int a[N],b[N];
LL m;
void readData(){
    n=getInt(); m=getInt();
    for(int i=1;i<=n;i++){
        a[i]=getInt();
        b[a[i]]=i;
    }
}
int simulate(){
    int r;
    for(r=1;n-r<=m;m-=n-r,r++);
    r--;
    if(!r)
        return 0;
    static int pos[N];
    static priority_queue<int> q;
    for(int i=1;i<=r;i++){
        pos[i]=i;
        q.push(b[i]);
    }
    for(int i=r+1;i<=n;i++){
        if(b[i]<q.top()){
            pos[i]=q.top();
            q.pop();
            q.push(b[i]);
        }else{
            pos[i]=b[i];
        }
    }
    for(int i=1;i<=n;i++) a[pos[i]]=i;
    return r;
}
void bruteforce(int start=1){
    if(!m)
        return;
    for(int i=start;i<n;i++)
        for(int j=i+1;j<=n;j++){
            if(a[j]<a[i])
                swap(a[i],a[j]);
            m--;
            if(!m)
                return;
        }
}
void printAnswer(){
    for(int i=1;i<=n;i++) writeInt(a[i]);
    IO::Enter();
}
int main(){
    IO::init();
    readData();
    int round=simulate();
    bruteforce(round+1);
    printAnswer();
    IO::flush();
    return 0;
}
```

