---
title: 标记的连接图
mathjax: true
date: 2019-06-25 07:39:40
tags: [DP---计数,图论,简化]
---

# Description

求在所有可能的$n$个点的无向连通图中，点1到点2的最短距离之和取模后的结果

$n \le 400$ 

<!-- more -->

# Solution

由于点与点之间没有明显区别，因此我们不妨求所有图中从1号点出发走向其他所有点的最短路径长度之和的总和，最后同时除以$n-1$即可

既然要统计的是最短路径长度，我们考虑分层DP，每层的点到1的最短距离相同，每一层的最短距离逐渐递增

显然同层内的节点可以互相连边，方案数为$2^x$；而下一层的每一个节点要与上一层的至少一个节点连边，可以预处理二维数组$g_{x,y}$表示上一层大小为$x$、这一层大小为$y$时的连边方案

设$f_{i,j,k}$表示已经考虑了前$i$个点，当前是第$j$层，且第$j$层恰好有$k$个点时，1到$1 \dots i$的最短距离之和

注意到我们可以用全局统计的思路优化掉第二维：每扩展一层，总的距离之和就加上$n-i$

设$f_{i,j}$表示已经考虑了前$i$个点，最后一层恰好有$j$个点时，点1到所有点的最短距离之和目前是多少。还未考虑到的点，我们只计算目前已考虑到的部分路径

转移时枚举新一层的节点数

时间复杂度$O(n^3)$

# Summary

<!-- summary_start -->

如果要统计的元素没有明显区别，可以考虑直接统计所有元素，最后答案除以一个常数

善用整体统计思想，可以将还未考虑到的元素的贡献预先计算

<!-- summary_end -->

# Code

```c++
#include <cstdio>

#define INV(x) FastPow(x,MOD-2)

const int N=400+10;

int n,MOD;
int c[N][N];
int h[N][N];

inline void apply(int &x,const int &y){
	(x+=y)%=MOD;
}
int FastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}

void ReadData(){
	scanf("%d%d",&n,&MOD);
}

void InitC(){
	c[0][0]=1;
	for(int i=1;i<=n;i++){
		c[i][0]=1;
		for(int j=1;j<=i;j++)
			c[i][j]=(c[i-1][j]+c[i-1][j-1])%MOD;
	}
}

void InitH(){
	for(int a=1;a<n;a++)
		for(int b=1;b<=n-a;b++)
			h[a][b]=1ll*FastPow(2,b*(b-1)>>1)*FastPow(FastPow(2,a)-1,b)%MOD;
}

void Calc(){
	static int f[N][N],g[N][N];
	f[1][1]=1;
	g[1][1]=0;
	for(int i=1;i<n;i++)
		for(int j=1;j<=i;j++)
			for(int k=1;k<=n-i;k++){
				int coef=1ll*h[j][k]*c[n-i][k]%MOD;
				apply(f[i+k][k],1ll*coef*f[i][j]%MOD);
				apply(g[i+k][k],1ll*coef*((g[i][j]+1ll*(n-i)*f[i][j])%MOD)%MOD);
			}
	int ans=0;
	for(int i=1;i<=n;i++) apply(ans,g[n][i]);
	ans=1ll*ans*INV(n-1)%MOD;
	printf("%d\n",ans>=0?ans:ans+MOD);
}

int main(){
	ReadData();
	InitC();
	InitH();
	Calc();
	return 0;
}
```

