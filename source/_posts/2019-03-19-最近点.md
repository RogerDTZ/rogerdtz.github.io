---
title: 最近点
mathjax: true
date: 2019-03-19 10:09:19
tags: [点分治,数据结构---平衡树]
---

# Description

有一棵树，初始时每个节点都为白色

有$m$次操作，每次操作为下列三种中的一种：

* $1\ x$：若$x$为白色，将其变为黑色；否则将其变为白色
* $2\ x$：询问点$x$到任意黑点的最小距离。若当前无黑点，输出$10^9$
* $3\ t$：回到进行第$t$次"$1\ x$"操作后的状态

本题强制在线

$n,m \le 10^5$

<!-- more -->

# Solution

点分治

每个重心用一棵可持久化Treap维护管辖范围内所有黑点到它的距离

用一棵可持久化线段树维护不同时刻每一个重心对应的Treap根

时间复杂度$O(n \log^2 n)$

# Code

```c++
#include <cstdio>
#include <utility>
#include <vector>
#include <cstdlib>
#include <algorithm>
#define MP make_pair
#define FR first
#define SE second
using std::vector;
using std::pair;
using std::make_pair;
using std::sort;
using std::lower_bound;
const int INF=1e9;
const int N=100000+10;
inline int max(int x,int y){
	return x>y?x:y;
}
inline int min(int x,int y){
	return x<y?x:y;
}
namespace IO{
	const int LEN=20000000;
	char *inBuf,*inPtr;
	void Init(){
		inBuf=new char[LEN];
	}
	void Load(){
		fread(inBuf,1,LEN,stdin);
		inPtr=inBuf;
	}
	char GetChar(){
		return *(inPtr++);
	}
	int GetInt(){
		int x=0,f=1;
		char c=GetChar();
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=GetChar();}
		while('0'<=c&&c<='9'){x=x*10+c-'0';c=GetChar();}
		return x*f;
	}
}
int n;
int lastTime;
struct Opt{
	int type,pos,val;
	static bool Cmp(const Opt &a,const Opt &b){
		return a.pos<b.pos;
	}
};
namespace Treap{/*{{{*/
	const int SIZE=20000000;
	struct Node{
		int ch[2];
		int size;
		int val,minVal;
	}a[SIZE];
	int nodeCnt;
	inline int NewNode(int val){
		a[++nodeCnt]=(Node){0,0,1,val,val};
		return nodeCnt;
	}
	inline int CopyNode(int u){
		a[++nodeCnt]=a[u];
		return nodeCnt;
	}
	inline void Pushup(int u){
		a[u].size=a[a[u].ch[0]].size+a[a[u].ch[1]].size+1;
		a[u].minVal=min(a[u].val,min(a[u].ch[0]?a[a[u].ch[0]].minVal:INF,a[u].ch[1]?a[a[u].ch[1]].minVal:INF));
	}
	void Split(int u,int k,int &x,int &y){
		if(!u){
			x=y=0;
			return;
		}
		if(k<a[u].val){
			y=CopyNode(u);
			Split(a[y].ch[0],k,x,a[y].ch[0]);
		}else{
			x=CopyNode(u);
			Split(a[x].ch[1],k,a[x].ch[1],y);
		}
		if(x)
			Pushup(x);
		if(y)
			Pushup(y);
	}
	void SplitSize(int u,int k,int &x,int &y){
		if(!u){
			x=y=0;
			return;
		}
		int cmp=a[a[u].ch[0]].size+1;
		if(k<cmp){
			y=CopyNode(u);
			SplitSize(a[y].ch[0],k,x,a[y].ch[0]);
		}else{
			x=CopyNode(u);
			SplitSize(a[x].ch[1],k-cmp,a[x].ch[1],y);
		}
		if(x)
			Pushup(x);
		if(y)
			Pushup(y);
	}
	int Merge(int x,int y){
		if(!x||!y)
			return x+y;
		int u;
		if(rand()%(a[x].size+a[y].size)<a[x].size){
			u=CopyNode(x);
			a[u].ch[1]=Merge(a[u].ch[1],y);
		}else{
			u=CopyNode(y);
			a[u].ch[0]=Merge(x,a[u].ch[0]);
		}
		Pushup(u);
		return u;
	}
	int Insert(int rt,int val){
		int x=0,y=0;
		Split(rt,val,x,y);
		int u=NewNode(val);
		return Merge(Merge(x,u),y);
	}
	int Delete(int rt,int val){
		int x=0,y=0,x0=0,y0=0;
		Split(rt,val,x,y);
		SplitSize(x,a[x].size-1,x0,y0);
		return Merge(x0,y);
	}
}/*}}}*/
namespace Tree{/*{{{*/
	const int N=(::N);
	int h[N],tot;
	struct Edge{
		int v,next;
	}e[N*2];
	int pre[N];
	int dep[N];
	int size[N];
	int son[N];
	int top[N];
	void AddEdge(int u,int v){
		e[++tot]=(Edge){v,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,h[v]}; h[v]=tot;
	}
	void DissectionDFS1(int u,int fa){
		pre[u]=fa;
		dep[u]=dep[fa]+1;
		size[u]=1;
		son[u]=-1;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa){
				DissectionDFS1(v,u);
				size[u]+=size[v];
				if(son[u]==-1||size[v]>size[son[u]])
					son[u]=v;
			}
	}
	void DissectionDFS2(int u,int _top){
		top[u]=_top;
		if(son[u]==-1)
			return;
		DissectionDFS2(son[u],top[u]);
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=pre[u]&&v!=son[u])
				DissectionDFS2(v,v);
	}
	void Dissection(){
		DissectionDFS1(1,0);
		DissectionDFS2(1,1);
	}
	inline int GetLCA(int a,int b){
		for(;top[a]!=top[b];dep[top[a]]>dep[top[b]]?a=pre[top[a]]:b=pre[top[b]]);
		return dep[a]<dep[b]?a:b;
	}
	inline int GetDis(int a,int b){
		return dep[a]+dep[b]-2*dep[GetLCA(a,b)];
	}
}/*}}}*/
namespace Seg{/*{{{*/
	const int VER=(::N);
	const int SIZE=N*295;
	struct Node{
		int ch[2];
		int val[2];
	}a[SIZE];
	int nodeCnt;
	int rt[VER];
	inline int CopyNode(int u){
		a[++nodeCnt]=a[u];
		return nodeCnt;
	}
	void Insert(int u,int &v,int l,int r,int &p,int cnt,Opt *opt){
		v=CopyNode(u);
		if(l==r){
			while(p<=cnt&&opt[p].pos==l){
				a[v].val[opt[p].type]=opt[p].val;
				p++;
			}
			return;
		}
		int mid=(l+r)>>1;
		if(p<=cnt&&l<=opt[p].pos&&opt[p].pos<=mid)
			Insert(a[u].ch[0],a[v].ch[0],l,mid,p,cnt,opt);
		if(p<=cnt&&mid<opt[p].pos&&opt[p].pos<=r)
			Insert(a[u].ch[1],a[v].ch[1],mid+1,r,p,cnt,opt);
	}
	int Query(int u,int l,int r,int pos,int type){
		if(!u)
			return 0;
		if(l==r)
			return a[u].val[type];
		int mid=(l+r)>>1;
		if(pos<=mid)
			return Query(a[u].ch[0],l,mid,pos,type);
		else
			return Query(a[u].ch[1],mid+1,r,pos,type);
	}
}/*}}}*/
namespace PDTree{/*{{{*/
	const int N=(::N);
	using Tree::h;
	using Tree::e;
	bool cut[N];
	int curRoot,curVal;
	int size[N];
	int pre[N];
	void FindRootDFS(int u,int fa,int curSize){
		size[u]=1;
		int maxSub=0;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa&&!cut[v=e[i].v]){
				FindRootDFS(v,u,curSize);
				size[u]+=size[v];
				maxSub=max(maxSub,size[v]);
			}
		maxSub=max(maxSub,curSize-size[u]);
		if(maxSub<curVal){
			curRoot=u;
			curVal=maxSub;
		}
	}
	int FindRoot(int u,int curSize){
		curRoot=-1;
		curVal=INF;
		FindRootDFS(u,0,curSize);
		return curRoot;
	}
	int Divide(int x,int curSize){
		int u=FindRoot(x,curSize);
		cut[u]=true;
		for(int i=h[u],v;i;i=e[i].next)
			if(!cut[v=e[i].v]){
				int p=Divide(v,size[v]<size[u]?size[v]:curSize-size[u]);
				pre[p]=u;
			}
		return u;
	}
	int GetTreapRoot(int u){
		return Seg::Query(Seg::rt[lastTime],1,n,u,1);
	}
	void Modify(int t,int x){
		bool st=Seg::Query(Seg::rt[lastTime],1,n,x,0);
		int opt=st^1;
		static int p,cnt;
		static Opt arr[100];
		p=1; cnt=0;
		for(int u=x;u;u=pre[u]){
			int rt=GetTreapRoot(u);
			if(opt==1)
				rt=Treap::Insert(rt,Tree::GetDis(u,x));
			else
				rt=Treap::Delete(rt,Tree::GetDis(u,x));
			arr[++cnt]=(Opt){1,u,rt};
		}
		arr[++cnt]=(Opt){0,x,st^1};
		sort(arr+1,arr+cnt+1,Opt::Cmp);
		Seg::Insert(Seg::rt[lastTime],Seg::rt[t],1,n,p,cnt,arr);
		lastTime=t;
	}
	int Query(int x){
		int res=INF;
		for(int u=x;u;u=pre[u]){
			int rt=GetTreapRoot(u);
			if(rt)
				res=min(res,Tree::GetDis(u,x)+Treap::a[rt].minVal);
		}
		return res;
	}
}/*}}}*/
void ReadData(){
	using IO::GetInt;
	n=GetInt();
	for(int i=1;i<n;i++)
		Tree::AddEdge(GetInt(),GetInt());
}
void AnswerQuery(){
	using IO::GetInt;
	int m;
	int ans=0;
	int tot=0;
	m=GetInt();
	for(int i=1;i<=m;i++){
		int opt,x;
		opt=GetInt(); x=GetInt();
		x^=ans; // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		switch(opt){
			case 1: PDTree::Modify(++tot,x);
					break;
			case 2: ans=PDTree::Query(x);
					printf("%d\n",ans);
					break;
			case 3: lastTime=x;
					break;
		}
	}
}
int main(){
	// online !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	IO::Init();
	IO::Load();
	ReadData();
	Tree::Dissection();
	PDTree::Divide(1,n);
	AnswerQuery();
	return 0;
}
```

