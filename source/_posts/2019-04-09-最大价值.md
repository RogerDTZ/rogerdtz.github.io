---
title: 最大价值
mathjax: true
date: 2019-04-09 15:58:32
tags: [DP---优化,数据结构---平衡树]
---

# Description

有$n$个物品，每个物品$i$有两个属性值$a_i$和$b_i$

你需要从中挑选出$k$个物品，并构造它们的某个排列。若一个物品$i$在排列中的位置为$j$，则它有$a_i(j-1)+b_i$的贡献。一个排列的价值为所有物品的贡献之和

请对于$[1,n]$中的每一个$k$，求出排列的最大价值是多少

$n \le 3 \times 10^5$，$0 \le a_i \le 10^6$，$0 \le b_i \le 10^{12}$

<!-- more -->

# Solution

可以观察到一个简单的性质：若确定了物品集合，则最优排列一定是所有物品按$a_i$从小到大排序后的结果

所以我们先把所有物品按$a_i$排序，然后做一个$O(n^2)$的DP

设$f_{i,j}$表示对于前$i$个物品，已经选择了$j$个物品时，构成排列的最大价值是多少。显然有转移：
$$
f_{i,j}=\max \{f_{i-1,j},f_{i-1,j-1}+a_i(j-1)+b_i \}
$$
接下来就只能考虑如何优化这个DP了

前一个转移是继承，后一个转移是更新。通过打表可以发现，进行每层转移时，总是存在一个分界点$x$，满足$f_{i,1 \dots x}$选择继承，而$f_{i,x+1 \dots i}$选择更新。为什么？

有一个结论：如果某个物品存在于选择物品个数为$k$时的某个最优方案中，那么它也一定存在于选择物品个数大于$k$时的某个最优方案中；否则，“当前最优”或“$k$时最优”会出现矛盾。因此，更新生效的范围是一个后缀

考虑二分出这个分界点在哪里。为此我们量化两个选择的比较：若选择继承，则
$$
f_{i-1,j}\ge f_{i-1,j-1}+a_i(j-1)+b_i\\f_{i-1,j}-f_{i-1,j-1} \ge a_i(j-1)+b_i
$$
既然这里可以用差分表示，我们不妨直接维护原数组的差分$g_{i,j}=f_{i,j}-f_{i,j-1}$，则上式变为：
$$
g_{i-1,j} \ge a_i(j-1)+b_i
$$
得到$x$之后，考虑$f$发生的变化，再考虑差分数组$g$发生的变化：
$$
\begin{aligned}
j \in [1,x]:& \ f_{i,j}=f_{i-1,j} \\
j \in (x,i]:& \ f_{i,j}=f_{i-1,j-1}+a_i(j-1)+b_i \\
\\
j \in [1,x):& \ g_{i,j}=g_{i-1,j} \\
j = x:& \ g_{i,x}=a_i(j-1)+b_i \\
j \in (x,i]:& \ g_{i,j}=(f_{i-1,j-1}+a_i(j-1)+b_i)-(f_{i-1,j-2}+a_i(j-2)+b_i) =g_{i-1,j-1}+a_i
\end{aligned}
$$
那么$g_{i-1}$变化到$g_i$的操作就是：

* $[1,x)$继承结果
* $[x,i-1]$向右平移一位并加上$a_i$
* $x$处设置为$a_i(j-1)+b_i$

用一棵平衡树就可以方便地实现这些操作

最后在平衡树上做一次中序遍历，输出前缀和

时间复杂度$O(n \log n)$

# Code

```c++
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using std::sort;
typedef long long LL;
const int N=300000+10;
namespace IO{
	const int LEN=20000000;
	char *inBuf,*inPtr;
	void Init(){
		inBuf=new char[LEN];
	}
	void Load(){
		fread(inBuf,1,LEN,stdin);
		inPtr=inBuf;
	}
	char GetChar(){
		return *(inPtr++);
	}
	LL GetInt(){
		LL x=0,f=1;
		char c=GetChar();
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=GetChar();}
		while('0'<=c&&c<='9'){x=x*10+c-'0';c=GetChar();}
		return x*f;
	}
}
int n;
struct Object{
	LL a,b;
	static bool CmpA(const Object &x,const Object &y){
		return x.a!=y.a?x.a<y.a:x.b<y.b;
	}
}s[N];
namespace Treap{
	const int SIZE=(::N);
	struct Node{
		int ch[2];
		int size;
		LL val;
		LL addTag;
	}node[SIZE];
	int nodeCnt;
	int rt;
	int NewNode(LL val){
		int u=++nodeCnt;
		node[u]=(Node){0,0,1,val,0};
		return u;
	}
	void MakeAddTag(int u,LL x){
		if(!u)
			return;
		node[u].addTag+=x;
		node[u].val+=x;
	}
	void Pushup(int u){
		node[u].size=node[node[u].ch[0]].size+node[node[u].ch[1]].size+1;
	}
	void Pushdown(int u){
		if(node[u].addTag){
			if(node[u].ch[0])
				MakeAddTag(node[u].ch[0],node[u].addTag);
			if(node[u].ch[1])
				MakeAddTag(node[u].ch[1],node[u].addTag);
			node[u].addTag=0;
		}
	}
	void Split(int u,int k,int &x,int &y){
		if(!u){
			x=y=0;
			return;
		}
		Pushdown(u);
		int cmp=node[node[u].ch[0]].size+1;
		if(k<cmp){
			y=u;
			Split(node[u].ch[0],k,x,node[y].ch[0]);
		}else{
			x=u;
			Split(node[u].ch[1],k-cmp,node[x].ch[1],y);
		}
		if(x)
			Pushup(x);
		if(y)
			Pushup(y);
	}
	int Merge(int x,int y){
		if(!x||!y)
			return x+y;
		Pushdown(x);
		Pushdown(y);
		if(rand()%(node[x].size+node[y].size)<node[x].size){
			node[x].ch[1]=Merge(node[x].ch[1],y);
			Pushup(x);
			return x;
		}else{
			node[y].ch[0]=Merge(x,node[y].ch[0]);
			Pushup(y);
			return y;
		}
	}
	int MergeSeg(int x,int y,int z){
		return Merge(Merge(x,y),z);
	}
	int Find(int u,LL a,LL b,int left=0){
		if(!u)
			return left;
		Pushdown(u);
		LL cmp=a*(left+node[node[u].ch[0]].size)+b;
		if(node[u].val>=cmp)
			return Find(node[u].ch[1],a,b,left+node[node[u].ch[0]].size+1);
		else
			return Find(node[u].ch[0],a,b,left);
	}
	void DFS(int u,LL &sum){
		if(!u)
			return;
		Pushdown(u);
		DFS(node[u].ch[0],sum);
		sum+=node[u].val;
		printf("%lld\n",sum);
		DFS(node[u].ch[1],sum);
	}
}
void ReadData(){
	using IO::GetInt;
	n=GetInt();
	for(int i=1;i<=n;i++){
		s[i].a=GetInt();
		s[i].b=GetInt();
	}
}
void Solve(){
	sort(s+1,s+n+1,Object::CmpA);
	for(int i=1;i<=n;i++){
		int pos=Treap::Find(Treap::rt,s[i].a,s[i].b);
		int x=0,y=0;
		Treap::Split(Treap::rt,pos,x,y);
		Treap::MakeAddTag(y,s[i].a);
		int z=Treap::NewNode(s[i].a*pos+s[i].b);
		Treap::rt=Treap::MergeSeg(x,z,y);
	}
	LL temp=0;
	Treap::DFS(Treap::rt,temp);
}
int main(){
	IO::Init();
	IO::Load();
	srand(233333);
	ReadData();
	Solve();
	return 0;
}
```

