---
layout: post
mathjax: true
title: 配对
date: 2019-01-09 20:55:00
tag: [结论题,方案特征,可做未做]
---
# Description

　　给一棵$n$个点的边带权树和$m$个关键点，保证$m$为偶数。请为这$m$个关键点两两配对，使得每一对点的简单路径长度之和最大

　　请输出一个合法的方案

　　$m\le n \le 10^5$



　　
<!-- more -->
# Solution

　　由于要输出方案，简单的DP肯定是行不通的，只能考虑一些奇怪的贪心

　　考虑答案的性质：所有路径必然相交于某一点。若某两条路径不相交，显然可以稍作变动使得它们相交，且答案不会更劣。将这个点看做根，我们希望每一对点的路径都过根，即每一对点都位于不同子树，这样路径长度总和是最优的，也恰好取到了最大值，关键在于能否构造方案

　　两两配对、都相交于一点——考虑将虚树重心作为相交点。由于重心的任意一个子树里关键点个数都不超过$\frac m2$，这意味着每一个点都能找到一个子树外的点进行配对，取到最大值的方案一定存在，贪心构造即可

　　我们有更简便的实现方法：将所有关键点按dfs序排序，令排名第$i$的点与排名第$i+\frac m2$的点配对即可

　　由于重心的每一个子树都不会有超过$\frac m2$个关键点，可以发现每一对的两个点一定处于虚树重心的不同子树

　　时间复杂度$O(n)$



# Code

```c++
#include <cstdio>
namespace IO{
    const int LEN=20000000;
    char *inBuf;
    char *outBuf,*outCur;
    void init(){
        inBuf=new char[LEN];
        outBuf=outCur=new char[LEN];
        fread(inBuf,1,LEN,stdin);
    }
    void flush(){
        fwrite(outBuf,1,outCur-outBuf,stdout);
    }
    char getChar(){
        return *(inBuf++);
    }
    void writeChar(char c){
        *(outCur++)=c;
    }
    int getInt(){
        char c=getChar();
        int x=0,f=1;
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
    void writeInt(int x,char end=' '){
        if(!x){
            writeChar('0');
        }else{
            static int d[20],cnt;
            for(cnt=0;x;x/=10) d[++cnt]=x%10;
            for(;cnt;cnt--) writeChar('0'+d[cnt]);
        }
        writeChar(end);
    }
    void Enter(){
        writeChar('\n');
    }
}
using IO::getInt;
using IO::writeInt;
const int N=100000+10;
int n,m;
namespace T{
    int h[N],tot;
    struct Edge{
        int v,next;
    }e[N*2];
    bool imp[N];
    void addEdge(int u,int v){
        e[++tot]=(Edge){v,h[u]}; h[u]=tot;
        e[++tot]=(Edge){u,h[v]}; h[v]=tot;
    }
    void dfs(int u,int fa,int *arr){
        if(imp[u])
            arr[++arr[0]]=u;
        for(int i=h[u],v;i;i=e[i].next)
            if((v=e[i].v)!=fa)
                dfs(v,u,arr);
    }
}
void readData(){
    n=getInt(); m=getInt();
    for(int i=1;i<n;i++){
        int u=getInt(),v=getInt();
        getInt();
        T::addEdge(u,v);
    }
    for(int i=1;i<=m;i++) T::imp[getInt()]=true;
}
void solve(){
    static int lis[N];
    T::dfs(1,0,lis);
    for(int i=1;i<=(m>>1);i++){
        writeInt(lis[i]);
        writeInt(lis[i+(m>>1)]);
        IO::Enter();
    }
}
int main(){
    IO::init();
    readData();
    solve();
    IO::flush();
    return 0;
}
```

