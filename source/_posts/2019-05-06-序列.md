---
title: 序列
mathjax: true
date: 2019-05-06 19:13:41
tags: [数据结构---线段树,数据结构---吉利线段树]
---

# Description

给定一个长度为$n$的序列$a$，要求支持$q$次操作，每次操作为以下三种中的一种：

* 将序列的某个区间$[l,r]$加上一个整数$x$
* 将序列的某个区间$[l,r]$对某一个整数$x$取$\max$
* 给定下标$x$，求$a_x$的值及其变动次数

$n,m \le 10^5$

<!-- more -->

# Solution

## 吉利线段树

这种做法最直观

吉利线段树的一个核心思想是：将区间取最值的操作转化为区间最值的加减操作

我们只需要对区间的最小值们维护一组区间值加和区间变动次数加的标记，再对不是最小值的值维护同样的一组标记。下传标记时，最小值的标记往最小值的来源下传，非最小值的标记往剩余未下传的位置下传即可

时间复杂度$O(q \log^{(2)} n)$

## 离线

假设我们只需要计算某一个元素的答案

考虑与之相关的操作，使用无效全局操作将操作序列补成$A_1M_1A_2M_2A_3M_3...A_kM_k$的形式

则每个询问相当于求一个前缀的答案

我们只需要关注哪些$M$会生效

记$A_i$的前缀和为$S_i$

假设当前在$A_iM_i$的$M_i$，且$M_i$更新成功了，考虑下一次更新成功的$M_j$在哪里。$j$显然要满足这样一个条件：
$$
M_j>M_i+S_j-S_i \\
M_j-S_j>M_i-S_i
$$
如果记$F_i=M_i-S_i$，$\max$操作生效的位置就是从左往右扫$F$数组、贪心地取最大值的那些位置

考虑经典的线段树线性递推模型（楼房重建），我们用一个线段树维护$F$数组，要支持给定一个初值，问它经过某个区间后的值和最大值更新次数（为了还原真实值，还需要记录最后成功更新的位置）

维护区间最大值。若当前值$x$不小于左区间的最大值，直接递归右区间计算；否则递归左区间计算，出来的值显然是左区间的最大值，若我们提前对每个区间维护了左区间的最大值代入右区间后的答案，这里就可以直接合并信息返回了

线段树可能要支持区间加操作，由于懒标记覆盖的是整个区间，维护的答案可以快速变化；而被边界分割的区间直接计算即可，单次修改的复杂度是$O(\log^2 n)$

从左往右扫序列上的每个元素，在适当的时候加入或删除操作，维护$F$数组即可

时间复杂度$O(q \log^2 n)$。实现起来比较繁琐（且被卡空间），但具有启发意义

# Summary

<!-- summary_start -->

吉利线段树能将区间取最值的操作转化为对区间的最值进行加减的操作，对最值以及非最值分开维护标记（下传时对应地下传，如最大值的标记仅下传给儿子内的最大值等于当前最大值的儿子）就可以解决许多问题

<!-- summary_end -->

# Code

吉利线段树：

```c++
#include <cstdio>

typedef long long LL;

const LL LINF=1ll<<60;
const int N=100000+10;

inline LL min(const LL &x,const LL &y){
	return x<y?x:y;
}
inline void applyMin(LL &x,const LL &y){
	x=(y<x)?y:x;
}

int n;
int a[N];

void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
}

namespace Seg{/*{{{*/
	const int SIZE=(::N)*2;
	struct Data{
		LL minVal;
		LL addTag;
		int mdfTag;
		Data(){}
		Data(LL x,LL y,int z): minVal(x),addTag(y),mdfTag(z) {}
		void Add(const int &x){
			minVal+=x;
			addTag+=x;
			mdfTag+=1;
		}
		void Apply(const Data &x){
			minVal+=x.addTag;
			addTag+=x.addTag;
			mdfTag+=x.mdfTag;
		}
		void Clear(){
			addTag=mdfTag=0;
		}
		bool Empty(){
			return addTag==0&&mdfTag==0;
		}
	};
	struct Node{
		int ch[2];
		Data mn1,mn2;
	}a[SIZE];
	int nodeCnt;
	int rt;
	void Pushup(int u){
		int lc=a[u].ch[0],rc=a[u].ch[1];
		a[u].mn1.minVal=min(a[lc].mn1.minVal,a[rc].mn1.minVal);
		a[u].mn2.minVal=LINF;
		applyMin(a[u].mn2.minVal,a[lc].mn1.minVal==a[u].mn1.minVal?a[lc].mn2.minVal:a[lc].mn1.minVal);
		applyMin(a[u].mn2.minVal,a[rc].mn1.minVal==a[u].mn1.minVal?a[rc].mn2.minVal:a[rc].mn1.minVal);
	}
	void Pushdown(int u){
		if(!a[u].mn1.Empty()||!a[u].mn2.Empty()){
			int lc=a[u].ch[0],rc=a[u].ch[1];
			LL val=a[u].mn1.minVal-a[u].mn1.addTag;
			a[lc].mn1.Apply(a[lc].mn1.minVal==val?a[u].mn1:a[u].mn2);
			a[lc].mn2.Apply(a[u].mn2);
			a[rc].mn1.Apply(a[rc].mn1.minVal==val?a[u].mn1:a[u].mn2);
			a[rc].mn2.Apply(a[u].mn2);
			a[u].mn1.Clear();
			a[u].mn2.Clear();
		}
	}
	void Build(int &u,int l,int r){
		u=++nodeCnt;
		if(l==r){
			a[u].mn1=Data(::a[l],0,0);
			a[u].mn2=Data(LINF,0,0);
			return;
		}
		int mid=(l+r)>>1;
		Build(a[u].ch[0],l,mid);
		Build(a[u].ch[1],mid+1,r);
		Pushup(u);
	}
	void ModifyAdd(int u,int l,int r,int ml,int mr,int x){
		if(ml<=l&&r<=mr){
			a[u].mn1.Add(x);
			a[u].mn2.Add(x);
			return;
		}
		Pushdown(u);
		int mid=(l+r)>>1;
		if(mr<=mid){
			ModifyAdd(a[u].ch[0],l,mid,ml,mr,x);
		}else if(mid<ml){
			ModifyAdd(a[u].ch[1],mid+1,r,ml,mr,x);
		}else{
			ModifyAdd(a[u].ch[0],l,mid,ml,mid,x);
			ModifyAdd(a[u].ch[1],mid+1,r,mid+1,mr,x);
		}
		Pushup(u);
	}
	void DFS(int u,int l,int r,int x){
		if(x<=a[u].mn1.minVal)
			return;
		if(x<a[u].mn2.minVal){
			a[u].mn1.Add(x-a[u].mn1.minVal);
			return;
		}else{
			Pushdown(u);
			int mid=(l+r)>>1;
			DFS(a[u].ch[0],l,mid,x);
			DFS(a[u].ch[1],mid+1,r,x);
			Pushup(u);
		}
	}
	void ModifyMax(int u,int l,int r,int ml,int mr,int x){
		if(x<=a[u].mn1.minVal)
			return;
		if(ml<=l&&r<=mr){
			DFS(u,l,r,x);
			return;
		}
		Pushdown(u);
		int mid=(l+r)>>1;
		if(mr<=mid){
			ModifyMax(a[u].ch[0],l,mid,ml,mr,x);
		}else if(mid<ml){
			ModifyMax(a[u].ch[1],mid+1,r,ml,mr,x);
		}else{
			ModifyMax(a[u].ch[0],l,mid,ml,mid,x);
			ModifyMax(a[u].ch[1],mid+1,r,mid+1,mr,x);
		}
		Pushup(u);
	}
	void Query(int u,int l,int r,int pos){
		if(l==r){
			printf("%lld %d\n",a[u].mn1.minVal,a[u].mn1.mdfTag);
			return;
		}
		Pushdown(u);
		int mid=(l+r)>>1;
		if(pos<=mid)
			Query(a[u].ch[0],l,mid,pos);
		else
			Query(a[u].ch[1],mid+1,r,pos);
	}
}/*}}}*/

void AnswerQuery(){
	int q;
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		static char opt[5];
		int l,r,x;
		scanf("%s",opt);
		switch(opt[0]){
			case 'A': scanf("%d%d%d",&l,&r,&x);
					  if(x!=0)
						  Seg::ModifyAdd(Seg::rt,1,n,l,r,x);
					  break;
			case 'M': scanf("%d%d%d",&l,&r,&x);
					  Seg::ModifyMax(Seg::rt,1,n,l,r,x);
					  break;
			case 'Q': scanf("%d",&x);
					  Seg::Query(Seg::rt,1,n,x);
					  break;
		}
	}
}

int main(){
	ReadData();
	Seg::Build(Seg::rt,1,n);
	AnswerQuery();
	return 0;
}

```

离线做法：

```c++
#include <cstdio>
#include <algorithm>
#include <vector>

using std::sort;
using std::vector;

typedef long long LL;

const LL LINF=1ll<<60;
const int N=100000+10;
const int M=100000+10;

inline LL max(const LL &x,const LL &y){
	return x>y?x:y;
}

int n;
int a[N];
int m,q;
struct Operation{
	int type;
	int l,r;
	LL x;
}opt[M*2];
struct Query{
	int time;
	int qid;
};
vector<Query> que[N];
LL ans[M][2];
int ecnt;
struct Event{
	int type;
	int x;
	int pos;
	LL val;
	static bool CmpX(const Event &a,const Event &b){
		return a.x<b.x;
	}
}e[M*4];

void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	int t;
	scanf("%d",&t);
	int last=-1;
	for(int i=1;i<=t;i++){
		static char cmd[10];
		int l,r,x;
		scanf("%s",cmd);
		switch(cmd[0]){
			case 'A': scanf("%d%d%d",&l,&r,&x);
					  if(last!=-1)
						  opt[++m]=(Operation){2,1,n,-LINF};
					  opt[++m]=(Operation){1,l,r,x};
					  last=1;
					  break;
			case 'M': scanf("%d%d%d",&l,&r,&x);
					  if(last==-1)
						  opt[++m]=(Operation){1,1,n,0};
					  opt[++m]=(Operation){2,l,r,x};
					  last=-1;
					  break;
			case 'Q': if(last!=-1)
						  opt[++m]=(Operation){2,1,n,-LINF};
					  scanf("%d",&x);
					  que[x].push_back((Query){m,++q});
					  last=-1;
					  break;
		}
	}
	if(last!=-1)
		opt[++m]=(Operation){2,1,n,-LINF};
}

void InitEvent(){
	for(int i=1;i<=m;i++){
		if(opt[i].type==1){
			e[++ecnt]=(Event){1,opt[i].l,i,opt[i].x};
			e[++ecnt]=(Event){-1,opt[i].r+1,i,-opt[i].x};
		}else{
			e[++ecnt]=(Event){1,opt[i].l,i,opt[i].x-(-LINF)};
			e[++ecnt]=(Event){-1,opt[i].r+1,i,(-LINF)-opt[i].x};
		}
	}
}

namespace Seg1{/*{{{*/
	const int SIZE=(::M)*2*2;
	struct Node{
		int ch[2];
		int x;
		LL sumAdd;
		int cntAdd;
	}a[SIZE];
	int nodeCnt;
	int rt;
	void Pushup(int u){
		a[u].sumAdd=a[a[u].ch[0]].sumAdd+a[a[u].ch[1]].sumAdd;
		a[u].cntAdd=a[a[u].ch[0]].cntAdd+a[a[u].ch[1]].cntAdd;
	}
	void Build(int &u,int l,int r){
		u=++nodeCnt;
		a[u].x=0;
		a[u].sumAdd=0;
		a[u].cntAdd=0;
		if(l==r)
			return;
		int mid=(l+r)>>1;
		Build(a[u].ch[0],l,mid);
		Build(a[u].ch[1],mid+1,r);
	}
	void Modify(int u,int l,int r,int pos,LL val){
		if(l==r){
			a[u].x=val;
			a[u].sumAdd=a[u].x;
			a[u].cntAdd=(a[u].x!=0);
			return;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)
			Modify(a[u].ch[0],l,mid,pos,val);
		else
			Modify(a[u].ch[1],mid+1,r,pos,val);
		Pushup(u);
	}
	LL QuerySum(int u,int l,int r,int ql,int qr){
		if(ql>qr)
			return 0;
		if(ql<=l&&r<=qr)
			return a[u].sumAdd;
		int mid=(l+r)>>1;
		if(qr<=mid)
			return QuerySum(a[u].ch[0],l,mid,ql,qr);
		else if(mid<ql)
			return QuerySum(a[u].ch[1],mid+1,r,ql,qr);
		else
			return QuerySum(a[u].ch[0],l,mid,ql,mid)+QuerySum(a[u].ch[1],mid+1,r,mid+1,qr);
	}
	int QueryCnt(int u,int l,int r,int ql,int qr){
		if(ql<=l&&r<=qr)
			return a[u].cntAdd;
		int mid=(l+r)>>1;
		if(qr<=mid)
			return QueryCnt(a[u].ch[0],l,mid,ql,qr);
		else if(mid<ql)
			return QueryCnt(a[u].ch[1],mid+1,r,ql,qr);
		else
			return QueryCnt(a[u].ch[0],l,mid,ql,mid)+QueryCnt(a[u].ch[1],mid+1,r,mid+1,qr);
	}
}/*}}}*/
namespace Seg2{/*{{{*/
	const int SIZE=(::M)*2;
	struct Data{
		LL val;
		int time;
		int last;
		Data(){}
		Data(LL val,int time,int last): val(val),time(time),last(last) {}
		static Data Merge(const Data &a,const Data &b){
			Data res;
			res.val=b.val;
			res.time=a.time+b.time;
			res.last=max(a.last,b.last);
			return res;
		}
	};
	struct Node{
		int ch[2];
		LL maxVal;
		Data rans;
		LL addTag;
	}a[SIZE];
	int nodeCnt;
	int rt;
	void MakeAddTag(int u,LL x){
		a[u].addTag+=x;
		a[u].maxVal+=x;
		a[u].rans.val+=x;
	}
	void Pushdown(int u){
		if(a[u].addTag){
			MakeAddTag(a[u].ch[0],a[u].addTag);
			MakeAddTag(a[u].ch[1],a[u].addTag);
			a[u].addTag=0;
		}
	}
	Data Calc(int u,int l,int r,LL x){
		if(l==r){
			if(x<a[u].maxVal)
				return Data(a[u].maxVal,1,l);
			else
				return Data(x,0,0);
		}
		Pushdown(u);
		int mid=(l+r)>>1;
		if(x>=a[a[u].ch[0]].maxVal)
			return Calc(a[u].ch[1],mid+1,r,x);
		else
			return Data::Merge(Calc(a[u].ch[0],l,mid,x),a[u].rans);
	}
	void Pushup(int u,int l,int r){
		a[u].maxVal=max(a[a[u].ch[0]].maxVal,a[a[u].ch[1]].maxVal);
		int mid=(l+r)>>1;
		a[u].rans=Calc(a[u].ch[1],mid+1,r,a[a[u].ch[0]].maxVal);
	}
	void Build(int &u,int l,int r){
		u=++nodeCnt;
		a[u].maxVal=-LINF;
		a[u].rans=Data(-LINF,0,0);
		if(l==r)
			return;
		int mid=(l+r)>>1;
		Build(a[u].ch[0],l,mid);
		Build(a[u].ch[1],mid+1,r);
	}
	void Modify(int u,int l,int r,int ml,int mr,LL x){
		if(ml<=l&&r<=mr){
			MakeAddTag(u,x);
			return;
		}
		Pushdown(u);
		int mid=(l+r)>>1;
		if(mr<=mid){
			Modify(a[u].ch[0],l,mid,ml,mr,x);
		}else if(mid<ml){
			Modify(a[u].ch[1],mid+1,r,ml,mr,x);
		}else{
			Modify(a[u].ch[0],l,mid,ml,mid,x);
			Modify(a[u].ch[1],mid+1,r,mid+1,mr,x);
		}
		Pushup(u,l,r);
	}
	Data Query(int u,int l,int r,int ql,int qr,LL &cur){
		if(ql<=l&&r<=qr){
			Data res=Calc(u,l,r,cur);
			cur=res.val;
			return res;
		}
		Pushdown(u);
		int mid=(l+r)>>1;
		if(qr<=mid){
			return Query(a[u].ch[0],l,mid,ql,qr,cur);
		}else if(mid<ql){
			return Query(a[u].ch[1],mid+1,r,ql,qr,cur);
		}else{
			Data t1=Query(a[u].ch[0],l,mid,ql,mid,cur);
			Data t2=Query(a[u].ch[1],mid+1,r,mid+1,qr,cur);
			return Data::Merge(t1,t2);
		}
	}
}/*}}}*/

void Solve(){
	if(m==0){
		for(int i=1;i<=n;i++)
			for(int j=0;j<int(que[i].size());j++){
				int id=que[i][j].qid;
				ans[id][0]=a[i];
				ans[id][1]=0;
			}
	}else{
		Seg1::Build(Seg1::rt,1,m);
		Seg2::Build(Seg2::rt,1,m/2);
		sort(e+1,e+ecnt+1,Event::CmpX);
		for(int i=1,j=1;i<=n;i++){
			for(;j<=ecnt&&e[j].x==i;j++){
				int x=e[j].pos;
				if(x&1){ // add
					if(e[j].type==1)
						Seg1::Modify(Seg1::rt,1,m,x,e[j].val);
					else
						Seg1::Modify(Seg1::rt,1,m,x,0);
					Seg2::Modify(Seg2::rt,1,m/2,(x+1)>>1,m/2,-e[j].val);
				}else{ // max
					Seg2::Modify(Seg2::rt,1,m/2,(x+1)>>1,(x+1)>>1,e[j].val);
				}
			}
			opt[0].x=a[i];
			for(int k=0;k<int(que[i].size());k++){
				int t=que[i][k].time,id=que[i][k].qid;
				if(t&1)
					t++;
				if(t==0){
					ans[id][0]=a[i];
					ans[id][1]=0;
					continue;
				}
				LL temp=a[i];
				Seg2::Data data=Seg2::Query(Seg2::rt,1,m/2,1,t/2,temp);
				ans[id][0]=opt[data.last*2].x+Seg1::QuerySum(Seg1::rt,1,m,data.last*2+1,t);
				ans[id][1]=Seg1::QueryCnt(Seg1::rt,1,m,1,t)+data.time;
			}
		}
	}
	for(int i=1;i<=q;i++)
		printf("%lld %lld\n",ans[i][0],ans[i][1]);
}

int main(){
	ReadData();
	InitEvent();
	Solve();
	return 0;
}
```

