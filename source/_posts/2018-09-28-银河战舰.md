---
layout: post
mathjax: true
title: 银河战舰
date: 2018-09-28 21:07:39
tag: [最长上升子序列,启发式,长链剖分]
category: 2016北京集训
---
# Description

　　给一棵点带权的树，求所有简单路径的权值最大值

　　一条路径的权值定义为它经过的点的权值构成序列的最长严格上升子序列

　　$1 \le N \le 200000$


<!-- more -->
# Solution

　　先想一下序列上的简化问题：从左往右扫时，维护$f_i$表示长度为$i$的LIS的结尾最小权值

　　搬到树上：就是从下往上扫，维护$f_{u,i}$表示$u$子树内，自下向上的任意一条长度为$i$的LIS的结尾最小值

　　同理维护$g_{u,i}$，表示$u$子树内自下向上任意一条长度为$i$的LDS结尾最大值

　　考虑如何贡献答案。树上路径统计无非是在合并子树时考虑合并两条路径

　　当加入一个新的子树时，会构成两种新LIS：

- LIS包含$u$，我们只需要使用$u$的权值在归并子树$f$和新子树的$g$上二分、交换$g$和$f$再二分即可
- LIS不包含$u$，对于归并子树和新子树的$f$和$g$，挑选规模小的一个枚举每个元素，在另一边二分即可

　　这一步的复杂度瓶颈在后者，合并一次子树的复杂度是$O(\min(\mid f_u\mid,\mid g_v \mid)\log n)$或者$O(\min(\mid f_v\mid,\mid g_u \mid)\log n)$，使用了启发式思想保证了复杂度

　　至于合并操作，我们直接暴力将$f_u$和$f_v$取$\min$，将$g_u$和$g_v$取$\max$即可。同样，用规模小的往大的上合并，合并复杂度$O(\min(f,g))$

　　我们发现$f_u$或者$g_u$的第二维的有效范围不会超过$u$子树的最大深度。因此$fg$的规模和最大深度相关。我们在合并和统计的时候又运用到了有关最大深度的启发式思路。依此思路我们发现：如果某一个子树在统计时作为被枚举的一方在另一方中二分，那么在合并时它也会被合并到另一方，并且从此之后这个存在就消失了。换句话说，每个$f_u$被作为规模较小的一方枚举，这种情况从始至终最多发生一次，因此每个子树对整体的贡献都恰好是其子树长链长度带个$log$。由此我们保证了总复杂度为$O(n \log n)$



# Summary

　　对于树上问题，如果其在序列版本上有简单、易于考虑的做法，先思考在序列上的做法，再尝试搬到树上

　　注意如果序列上有多种做法，我们在搬到树上时，要尽可能选择那些可以在树上实现的做法

　　如果DP时需要记录子树信息，考虑记录信息的规模是否和子树大小或者子树最大深度有关，以此用启发式或者长链剖分的思想保证每个子树对复杂度只贡献一次，达到总贡献次数不超过$n$的结果

　　不要因为感觉树上的DP开不下就放弃，我们完全可以在树上从下往上一边扫一边合并，以此  来离线求得每一个点的结果

# Code

　　自认为写的很好看的代码（一直被模仿，轻松被超越）：

```c++
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#define pb push_back
using namespace std;
namespace IO{
    const int S=10000000;
    char buf[S];
    int pos;
    void load(){
        fread(buf,1,S,stdin);
        pos=0;
    }
    char getChar(){
        return buf[pos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
typedef vector<int> vi;
const int N=200010;
const int INF=1e9;
int n;
int a[N];
int h[N],tot;
struct Edge{
    int v,next;
}e[N*2];
vi f[N],g[N];
int ans;
inline void updmin(int &x,int y){
    x=(y<x?y:x);
}
inline void updmax(int &x,int y){
    x=(y>x?y:x);
}
void addEdge(int u,int v){
    e[++tot]=(Edge){v,h[u]}; h[u]=tot;
    e[++tot]=(Edge){u,h[v]}; h[v]=tot;
}
void readData(){
    n=getInt();
    for(int i=1;i<=n;i++) a[i]=getInt();
    int u,v;
    for(int i=1;i<n;i++){
        u=getInt(); v=getInt();
        addEdge(u,v);
    }
}
bool cmpR(const int &x,const int &y){
    return x>y;
}
void cross(int u,int v){ // f[u] g[v]
    int pos;
    if(f[u].size()<g[v].size()){
        for(int i=0,sz=f[u].size();i<sz;i++){
            pos=lower_bound(g[v].begin(),g[v].end(),f[u][i],cmpR)-g[v].begin();
            updmax(ans,(i+1)+pos);
        }
    }
    else{
        for(int i=0,sz=g[v].size();i<sz;i++){
            pos=lower_bound(f[u].begin(),f[u].end(),g[v][i])-f[u].begin();
            updmax(ans,(i+1)+pos);
        }
    }
}
void updateAns(int u,int v){
    // use u as a point
    int l1,l2;
    l1=lower_bound(f[u].begin(),f[u].end(),a[u])-f[u].begin();
    l2=lower_bound(g[v].begin(),g[v].end(),a[u],cmpR)-g[v].begin();
    updmax(ans,l1+l2+1);
    l1=lower_bound(f[v].begin(),f[v].end(),a[u])-f[v].begin();
    l2=lower_bound(g[u].begin(),g[u].end(),a[u],cmpR)-g[u].begin();
    updmax(ans,l1+l2+1);
    // cross over u
    cross(u,v);
    cross(v,u);
}
void merge(int u,int v){ // u <- v
    int lu,lv;
    lu=f[u].size();
    lv=f[v].size();
    if(lu>=lv)
        for(int i=0;i<lv;i++) updmin(f[u][i],f[v][i]);
    else{
        for(int i=0;i<lu;i++) updmin(f[v][i],f[u][i]);
        swap(f[u],f[v]);
    }
    lu=g[u].size();
    lv=g[v].size();
    if(lu>=lv)
        for(int i=0;i<lv;i++) updmax(g[u][i],g[v][i]);
    else{
        for(int i=0;i<lu;i++) updmax(g[v][i],g[u][i]);
        swap(g[u],g[v]);
    }
}
void join(int u){
    int len,pos;
    len=f[u].size();
    pos=upper_bound(f[u].begin(),f[u].end(),a[u])-f[u].begin();
    if(!len||(!pos||a[u]>f[u][pos-1])){
        if(pos==len)
            f[u].pb(INF);
        f[u][pos]=a[u];
    }
    len=g[u].size();
    pos=upper_bound(g[u].begin(),g[u].end(),a[u],cmpR)-g[u].begin();
    if(!len||(!pos||a[u]<g[u][pos-1])){
        if(pos==len)
            g[u].pb(-INF);
        g[u][pos]=a[u];
    }
}
void solve(int u,int fa){
    for(int i=h[u],v;i;i=e[i].next)
        if((v=e[i].v)!=fa){
            solve(v,u);
            updateAns(u,v);
            merge(u,v);
        }
    join(u);
}
int main(){
    IO::load();
    readData();
    solve(1,0);
    printf("%d\n",ans);
    return 0;
}
```

