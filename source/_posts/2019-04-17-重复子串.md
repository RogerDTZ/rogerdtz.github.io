---
title: 重复子串
mathjax: true
date: 2019-04-17 15:33:17
tags: [后缀数组,启发式]
---

# Description

给一个长度为$N$的字符串$S$

有$Q$次询问，每次询问给出一个区间$[l,r]$，求$S_{[l,r]}$中的最长重复子串长度

$N \le 10^5$

<!-- more -->

# Solution

之前做过一道加强版的题，要求强制在线，做法是SAM+LCT+主席树；但本题允许离线，所以存在另一种做法，在这里总结一下

考虑后缀数组。不妨从大到小枚举答案$x$，在后缀数组中$height$值$<x$的地方断开，这样后缀数组就被划分成了若干组，每一组内部的LCP都$\ge x$

考虑将每一组内部的元素按$sa_i$的值排序（即按原串位置排序）。对于一个询问$[l,r]$，如果在同一组中存在两个元素在原串中的位置$a,b$满足$a,b \in [l,r-x+1]$，那么$x$就可以用来贡献答案。显然，我们只需要考虑同组中每一对相邻元素即可，因为它们最有可能被询问区间所包含

当$x$减小时，我们有可能需要合并两个组，启发式合并即可。插入元素时，会产生新的相邻对，也需要我们考虑

不妨将操作历史中所有的信息对记录下来。信息对形如$(a,b,x)$，表示枚举的答案为$x$时，$a$和$b$处于同组的相邻位置。注意到我们只需要在插入新元素时记录新相邻对产生的信息对即可，因为其他已有信息对会变得更劣，不需要录入。这样一来，信息对的个数就与启发式合并的次数相同，为$O(N \log N)$

考虑如何回答询问：我们枚举答案$x$，求所有满足$[a,b] \in [l,r-x+1]$的信息对$(a,b,x)$的$x$的最大值（这是一个二维问题，按右端点为版本、左端点为下标建立主席树，就可以$O(\log)$查询一个后缀矩形最大值），如果最大值大于等于$x$，则答案$\ge x$。这个东西显然具有二分性，二分答案计算就可以了

时间复杂度$O(Q \log^2 N)​$

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <set>
#include <vector>
#include <utility>

#define MP make_pair
#define FR first
#define SE second

using std::max;
using std::swap;
using std::vector;
using std::set;
using std::sort;
using std::unique;
using std::pair;
using std::make_pair;

const int INF=1e9;
const int N=100000+10;

int n,q;
char str[N];
int sa[N],rk[N],ht[N];
set<int> s[N];
struct Pair{
	int l,r;
	int val;
	friend bool operator == (const Pair &a,const Pair &b){
		return a.l==b.l&&a.r==b.r;
	}
	friend bool operator < (const Pair &a,const Pair &b){
		if(a.r!=b.r)
			return a.r<b.r;
		if(a.l!=b.l)
			return a.l<b.l;
		return a.val>b.val;
	}
}p[N*18+10];
int pcnt;

void ReadData(){
	scanf("%d%d",&n,&q);
	scanf("%s",str+1);
}
namespace SA{/*{{{*/
	const int N=(::N);
	int n;
	int reala[N],realb[N],*a=reala,*b=realb;
	int c[N],m;
	void Sort(int *sa){
		for(int i=1;i<=m;i++) c[i]=0;
		for(int i=1;i<=n;i++) c[a[b[i]]]++;
		for(int i=2;i<=m;i++) c[i]+=c[i-1];
		for(int i=n;i>=1;i--) sa[c[a[b[i]]]--]=b[i];
	}
	void main(int _n,char *str,int *sa,int *rk,int *ht){
		n=_n;
		for(int i=1;i<=n;i++){
			a[i]=(str[i]-'a'+1);
			b[i]=i;
			m=max(m,a[i]);
		}
		Sort(sa);
		int all=-1;
		for(int l=1;all<n;l<<=1){
			all=0;
			for(int i=n-l+1;i<=n;i++) b[++all]=i;
			for(int i=1;i<=n;i++)
				if(sa[i]>l)
					b[++all]=sa[i]-l;
			Sort(sa);
			swap(a,b);
			a[sa[1]]=all=1;
			for(int i=2;i<=n;i++){
				all+=!(b[sa[i]]==b[sa[i-1]]&&b[sa[i]+l]==b[sa[i-1]+l]);
				a[sa[i]]=all;
			}
			m=all;
		}
		for(int i=1;i<=n;i++) rk[i]=a[i];
		for(int i=1,j=0;i<=n;i++){
			if(j)
				j--;
			while(str[i+j]==str[sa[rk[i]-1]+j])
				j++;
			ht[rk[i]]=j;
		}
	}
}/*}}}*/
namespace DSU{
	const int N=(::N);
	int dsu[N];
	void Init(int n){
		for(int i=1;i<=n;i++)
			dsu[i]=i;
	}
	int Find(int x){
		return dsu[x]==x?x:(dsu[x]=Find(dsu[x]));
	}
	void Merge(int x,int y,int curLen){
		x=Find(x);
		y=Find(y);
		if(x==y)
			return;
		if(s[x].size()>s[y].size())
			swap(x,y);
		dsu[x]=y;
		for(set<int>::iterator it=s[x].begin();it!=s[x].end();it++){
			s[y].insert(*it);
			set<int>::iterator it1=s[y].find(*it),it2;
			if(it1!=s[y].begin()){
				it2=it1;
				it2--;
				p[++pcnt]=(Pair){*it2,*it,curLen};
			}
			it2=it1; it2++;
			if(it2!=s[y].end()){
				p[++pcnt]=(Pair){*it,*it2,curLen};
			}
		}
		s[x].clear();
	}
}
void InitPair(){
	static vector<int> where[N];
	for(int i=2;i<=n;i++)
		where[ht[i]].push_back(i-1);
	DSU::Init(n);
	for(int i=1;i<=n;i++) s[i].insert(sa[i]);
	for(int i=n;i>=0;i--)
		for(int j=0;j<int(where[i].size());j++){
			int x=where[i][j];
			DSU::Merge(x,x+1,i);
		}
	sort(p+1,p+pcnt+1);
	pcnt=unique(p+1,p+pcnt+1)-p-1;
}
namespace Seg{
	const int VER=(::N);
	const int SIZE=(::N)*150;
	struct Node{
		int ch[2];
		int maxv;
	}a[SIZE];
	int nodeCnt;
	int rt[VER];
	void Pushup(int u){
		a[u].maxv=max(a[a[u].ch[0]].maxv,a[a[u].ch[1]].maxv);
	}
	void NewVersion(int x,int y){
		rt[x]=rt[y];
	}
	int Copy(int u){
		int v=++nodeCnt;
		a[v]=a[u];
		return v;
	}
	void Modify(int &u,int l,int r,vector<pair<int,int> > &upd,int &ptr){
		u=Copy(u);
		if(l==r){
			for(;ptr<int(upd.size())&&upd[ptr].FR==l;ptr++)
				a[u].maxv=max(a[u].maxv,upd[ptr].SE);
			return;
		}
		int mid=(l+r)>>1;
		if(ptr<int(upd.size())&&l<=upd[ptr].FR&&upd[ptr].FR<=mid)
			Modify(a[u].ch[0],l,mid,upd,ptr);
		if(ptr<int(upd.size())&&mid<upd[ptr].FR&&upd[ptr].FR<=r)
			Modify(a[u].ch[1],mid+1,r,upd,ptr);
		Pushup(u);
	}
	int QueryMax(int u,int l,int r,int ql,int qr){
		if(!u)
			return 0;
		if(ql<=l&&r<=qr)
			return a[u].maxv;
		int mid=(l+r)>>1;
		if(qr<=mid)
			return QueryMax(a[u].ch[0],l,mid,ql,qr);
		else if(mid<ql)
			return QueryMax(a[u].ch[1],mid+1,r,ql,qr);
		else
			return max(QueryMax(a[u].ch[0],l,mid,ql,mid),QueryMax(a[u].ch[1],mid+1,r,mid+1,qr));
	}
}
void BuildSeg(){
	int i=1;
	for(int r=1;r<=n;r++){
		vector<pair<int,int> > upd;
		for(;i<=pcnt&&p[i].r==r;i++)
			upd.push_back(MP(p[i].l,p[i].val));
		Seg::NewVersion(r,r-1);
		if(!upd.empty()){
			int ptr=0;
			Seg::Modify(Seg::rt[r],1,n,upd,ptr);
		}
	}
}
int Query(int ql,int qr){
	int l=0,r=qr-ql+1,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(Seg::QueryMax(Seg::rt[qr-mid+1],1,n,ql,n)>=mid)
			l=mid+1;
		else
			r=mid-1;
	}
	return r;
}
void AnswerQuery(){
	for(int i=1;i<=q;i++){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",Query(l,r));
	}
}
int main(){
	ReadData();
	SA::main(n,str,sa,rk,ht);
	InitPair();
	BuildSeg();
	AnswerQuery();
	return 0;
}
```

