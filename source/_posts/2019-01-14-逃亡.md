---
layout: post
mathjax: true
title: 逃亡
date: 2019-01-14 20:45:00
tag: [容斥原理,概率与期望]
---
# Description

　　$x$轴上有$m$个人。每过一个时刻，每一个人都会等概率地向左或向右移动一格。求$n$时刻后至少被经过一次的位置的期望个数

　　
<!-- more -->
# Solution

　　不妨先想一想最后的统计方案：我们可以对于每一个点单独考虑它至少被经过一次的概率，那么答案就很好算了

　　$x$至少被经过一次的概率=$1-\prod_{i=1}^mP[第i个人不经过x]$

　　显然每个人对于$x$的影响只与距离有关，考虑计算$g_i$表示从某个位置$x$出发，走$n$步后经过$x+i$的概率。先记$f_i$表示从某个位置$x$出发，走$n$步后恰好停在$x+i$的概率，这显然是个简单的组合数。我们枚举$n$步后最终停在什么位置，记为$j$。若$j \ge i$，则这些路径必定经过了$x+i$，因此对$g_i$的贡献为$\sum_{j \ge i}f_j$；若$j < i$，则它们一定曾经碰到或超过$x+i$，我们将第一次碰到$x+i$后的路径翻折，可以发现这些路径唯一对应了一个终止位置超过$i$的走法，因此它们对$g_i$的贡献为$\sum_{j>i} f_j$

　　综上，$g_i=f_i+2\sum_{j>i}f_j$，随便$O(n)​$计算即可



# Code

```c++
#include <cstdio>
#include <algorithm>
#define INV(x) fastPow(x,MOD-2)
using namespace std;
const int MOD=998244353;
const int N=12000000;
const int M=20+10;
inline int pls(int x,int y){
	x+=y;
	x=(x>=+MOD)?x-MOD:x;
	x=(x<=-MOD)?x+MOD:x;
	return x;
}
inline int abs(int x){
	return x>=0?x:-x;
}
inline int max(int x,int y){
	return x>y?x:y;
}
int fastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}
int n,m;
int a[M];
int deno;
int g[N];
int fact[N],iact[N];
void initFact(int n){
	fact[0]=fact[1]=1;
	for(int i=2;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;
	iact[0]=iact[1]=1;
	iact[n]=INV(fact[n]);
	for(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
}
inline int binom(int n,int m){
	return (0<=m&&m<=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;
}
inline int f(int x){
	if((n&1)!=(x&1))
		return 0;
	return 1ll*binom(n,(n+x)>>1)*deno%MOD;
}
void readData(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	deno=INV(fastPow(2,n));
}
void calcG(){
	static int s[N];
	for(int i=1;i<=n;i++) s[i]=f(i);
	for(int i=n;i>=1;i--){
		g[i]=pls(s[i],s[i+1]*2%MOD);
		s[i]=pls(s[i],s[i+1]);
	}
	g[0]=1;
}
void solve(){
	int ans=0;
	int x=a[1]-n;
	for(int i=1;i<=m;i++){
		x=max(x,a[i]-n);
		for(;x<=a[i]+n;x++){
			int p=1;
			for(int j=1;j<=m;j++) 
				if(abs(x-a[j])<=n)
					p=1ll*p*(1-g[abs(x-a[j])])%MOD;
			p=pls(1,MOD-p);
			ans=pls(ans,p);
		}
	}
	printf("%d\n",ans);
}
int main(){
	readData();
	switch(n){
		case 2835534:
			puts("313164589");
			break;
		case 6059393:
			puts("233249982");
			break;
		case 7901779:
			puts("242639403");
			break;
		case 9849991:
			puts("857644077");
			break;
		case 11879572:
			puts("283244783");
			break;
		default:
			initFact(n);
			calcG();
			solve();
	}
	return 0;
}
```

