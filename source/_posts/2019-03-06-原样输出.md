---
title: 原样输出
date: 2019-03-06 14:37:48
tags: [字符串---后缀自动机,适应]
mathjax: true
---

# Description

有$n$个字符串$a_1,a_2,\dots,a_n$，问有多少本质不同的串$S$可以拆分成$n$段$s_1,s_2,\dots,s_n$（每段可以为空），使得$s_i$恰好为$a_i$的一个子串（可以为空）

输入文件大小不超过1 MB（即$\sum{\mid a_i \mid} \le 2^{20}$），字符集$\sum=4$

<!-- more -->

# Solution

一个思路是对$S$进行DP，一个$S$的贡献特征为从前往后贪心匹配$a_1,a_2,\dots,a_n$时的匹配状态

DP时需要识别每一个字符串的子串，因此可以使用SAM作为转移载体。对每一个$a_i$构建出SAM，在$n$个SAM上进行DP：设$f_{i,u}$表示已经确定了$S$的前$i$位，当前对应节点为$u$时本质不同的$S$的数量

此时，每个SAM之内的转移是没有问题的，但我们还没有构建不同SAM之间的转移：如果当前节点为第$i$个SAM内的$x$，而$x$缺少了某个转移$c$，我们应该将$x$的$c$转移指向$i$之后第一个拥有字符$c$的字符串$j$的SAM的接受$c$的节点，也就是第$j$个SAM的根节点的$c$儿子

现在，从第一个SAM根节点出发的每一条路径，都对应了一个本质不同的$S$。注意到我们构建出的新自动机依然是一个DAG，因此直接DP就好了

# Summary

问“本质不同数量"的问题时，不妨在构成元素的基础上去DP答案，而不是想如何从构成元素去组成本质不同的答案

后缀自动机可以做进一步的改造和拼接

# Code

```c++
#include <cstdio>
#include <cstring>
const int MOD=1e9+7;
const int LEN=(1<<20)+10;
inline void apply(int &x,int y){
	x=(x+y<MOD)?(x+y):(x+y-MOD);
}
inline int min(int x,int y){
	return x<y?x:y;
}
namespace IO{/*{{{*/
	const int LEN=100*1024*1024+10;
	char *outBuf,*outPtr;
	void Init(){
		outBuf=outPtr=new char[LEN];
	}
	void Flush(){
		fwrite(outBuf,1,outPtr-outBuf,stdout);
		outPtr=outBuf;
	}
	void PutChar(char c){
		*(outPtr++)=c;
		if(outPtr-outBuf==LEN)
			Flush();
	}
	void PutString(char *src,int len){
		if(outPtr-outBuf+len<=LEN){
			memcpy(outPtr,src,sizeof(char)*len);
			outPtr+=len;
			if(outPtr-outBuf==LEN)
				Flush();
		}else{
			int len0=LEN-(outPtr-outBuf);
			PutString(src,len0);
			PutString(src+len0,len-len0);
		}
	}
	void PutInt(int x,char end='\n'){
		if(x==0){
			PutChar('0');
		}else{
			if(x<0){
				PutChar('-');
				x=-x;
			}
			static int d[100],len;
			for(len=0;x;x/=10) d[++len]=x%10;
			for(;len;len--) PutChar('0'+d[len]);
		}
		PutChar(end);
	}
	void Enter(){
		PutChar('\n');
	}
}/*}}}*/
using IO::PutString;
using IO::PutInt;
int m;
int type;
inline int MapChar(char c){
	switch(c){
		case 'A': return 0;
		case 'C': return 1;
		case 'G': return 2;
		case 'T': return 3;
	}
	return -1;
}
inline char MapID(int id){
	switch(id){
		case 0: return 'A';
		case 1: return 'C';
		case 2: return 'G';
		case 3: return 'T';
	}
	return -1;
}
namespace SAM{
	const int C=4;
	const int VER=LEN;
	const int SIZE=LEN*2;
	struct Node{
		int trans[C];
		int len;
		int link;
	}a[SIZE];
	int nodeCnt;
	int rt;
	int last;
	bool isRoot[SIZE];
	void Extend(int c){
		int u=++nodeCnt,p=last;
		a[u].len=a[p].len+1;
		for(;p&&a[p].trans[c]==0;p=a[p].link) a[p].trans[c]=u;
		if(p==0){
			a[u].link=rt;
		}else{
			int q=a[p].trans[c];
			if(a[p].len+1==a[q].len){
				a[u].link=q;
			}else{
				int v=++nodeCnt;
				a[v]=a[q];
				a[v].len=a[p].len+1;
				a[q].link=a[u].link=v;
				for(;p&&a[p].trans[c]==q;p=a[p].link) a[p].trans[c]=v;
			}
		}
		last=u;
	}
	void Build(int n,char *str){
		rt=last=++nodeCnt;
		isRoot[nodeCnt]=true;
		for(int i=1;i<=n;i++)
			Extend(MapChar(str[i]));
	}
	void LinkBack(){
		int lastRoot=-1;
		for(int u=nodeCnt;u>=1;u--){
			if(lastRoot!=-1){
				for(int c=0;c<C;c++)
					if(a[u].trans[c]==0)
						a[u].trans[c]=a[lastRoot].trans[c];
			}
			if(isRoot[u])
				lastRoot=u;
		}
	}
	int topSeq[SIZE];
	void TopSort(){
		static int d[SIZE];
		for(int u=1;u<=nodeCnt;u++)
			for(int c=0;c<C;c++)
				if(a[u].trans[c])
					d[a[u].trans[c]]++;
		static int q[SIZE],head,tail;
		head=1; tail=0;
		for(int u=1;u<=nodeCnt;u++)
			if(d[u]==0)
				q[++tail]=u;
		int cnt=0;
		while(head<=tail){
			int u=q[head++];
			topSeq[++cnt]=u;
			for(int c=0,v;c<C;c++)
				if((v=a[u].trans[c])){
					d[v]--;
					if(d[v]==0)
						q[++tail]=v;
				}
		}
	}
	int ans;
	void Solve(){
		TopSort();
		static int f[SIZE];
		ans=0;
		f[1]=1;
		for(int i=1;i<=nodeCnt;i++){
			int u=topSeq[i];
			apply(ans,f[u]);
			for(int c=0,v;c<C;c++)
				if((v=a[u].trans[c]))
					apply(f[v],f[u]);
		}
		printf("%d\n",ans);
	}
	void SearchDFS(int u,int len){
		static char path[LEN];
		ans++;
		IO::PutString(path+1,len);
		IO::Enter();
		for(int c=0,v;c<C;c++)
			if((v=a[u].trans[c])){
				path[len+1]=MapID(c);
				SearchDFS(v,len+1);
			}
	}
	void Search(){
		SearchDFS(1,0);
		PutInt(ans);
	}
}
void ReadData(){
	scanf("%d",&m);
	for(int i=1;i<=m;i++){
		static char str[LEN];
		scanf("%s",str+1);
		SAM::Build(strlen(str+1),str);
	}
	scanf("%d",&type);
}
int main(){
	IO::Init();
	ReadData();
	SAM::LinkBack();
	if(type==0)
		SAM::Solve();
	else
		SAM::Search();
	IO::Flush();
	return 0;
}
```

