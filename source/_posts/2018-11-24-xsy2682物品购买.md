---
layout: post
mathjax: true
title: 物品购买
date: 2018-11-24 10:13:00
tag: [DP---背包,树链剖分]
category: 2018冬令营模拟测试赛
---
# Description

　　给一棵$n$个节点的有根树，每一个节点上都有无限多个物品，一个节点$i$的物品价值都为$w_i$，价格都为$c_i$

　　有$q$个询问，每次给出一个参数$C,x$，求从$x$出发的到根路径的所有物品组成的完全背包问题在钱数为$C$时的最大收益

　　$n,q \le 5000$，$c_i,w_i \le 32767$


<!-- more -->
# Solution

　　首先，完全背包是一个NP问题，这意味着你必须接受复杂度下界是$O(32767n)$的这个事实

　　考虑深搜时维护深搜栈组成的完全背包。记一个32767的数组$f_i$表示花费$i$的代价时的最大收益。递归进一个新点时，$O(32767)$更新数组即可。

　　关键问题在于回溯：我不可能对于每一个节点都复制一遍数组，在儿子递归完成后复位，这样空间复杂度过高

　　考虑树剖：在某一个节点$u$时，先递归轻儿子$v$，令轻儿子使用一个新数组，并把当前数组复制给$v$。最后，递归重儿子$son$时，让重儿子继续使用当前$u$的数组即可。根据树剖特性，任意一条到根路径经过的轻边数量不超过$\log n$，因此任意时刻使用的总数组数量也是$O(\log n)$的，空间复杂度降为$O(32767\log n)$

　　具体实现上，全局开$\log n$个数组，深搜时额外传一个参数$p$，表示当前在用哪一个数组即可

　　原来的$f_i$定义为"恰好花费$i$时的最大收益"，这意味着我们在回答询问时还要处理一遍前缀$\max$，且初始化时，$f_0=0,\ f_{i}=\infty(i >0)$。为了优化常数，我们定义$f_i$为"花费不超过$i$时的最大收益"，转移与原来完全一样，不过$f$的初始化变成$f_i=\infty$即可，可以发现，这样能把花费比需要少$x$的情况以首次转移时从$f_x=0$转移体现

　　时间复杂度$O(32767n)$，空间复杂度$O(32767\log n)$

# Summary

　　深搜维护栈内DP时，如果加入容易，而回溯复位遇到问题（无法对每一个点都记录递归前的值），不妨使用树剖，使重儿子继承当前数组，而令轻儿子使用新的数组，利用树剖的特性，使得任意时刻需要记录历史的节点个数不超过$\log$个



# Code

```c++
#include <cstdio>
#include <cstring>
#include <vector>
#define PB push_back
using namespace std;
typedef vector<int> VI;
const int N=5010;
const int W=32768;
int n,m;
struct Good{
    int cost,val;
}a[N];
VI que[N];
int money[N];
int ans[N];
inline void applyMax(int &x,int y){
    if(y>x)
        x=y;
}
namespace T{
    int h[N],tot;
    struct Edge{
        int v,next;
    }e[N];
    void addEdge(int u,int v){
        e[++tot]=(Edge){v,h[u]}; h[u]=tot;
    }
    int size[N],son[N];
    void dfs1(int u,int fa){
        size[u]=1;
        for(int i=h[u],v;i;i=e[i].next){
            v=e[i].v;
            dfs1(v,u);
            size[u]+=size[v];
            if(!son[u]||size[v]>size[son[u]])
                son[u]=v;
        }
    }
    int f[15][W];
    void add(int p,int u){
        int c=a[u].cost,v=a[u].val;
        for(register int i=0;i+c<W;i++)
            applyMax(f[p][i+c],f[p][i]+v);
    }
    void dfs2(int u,int fa,int p){
        add(p,u);
        if(que[u].size()){
            for(int i=0,sz=que[u].size();i<sz;i++)
                ans[que[u][i]]=f[p][money[que[u][i]]];
        }
        if(!son[u])
            return;
        for(int i=h[u],v;i;i=e[i].next)
            if((v=e[i].v)!=fa&&v!=son[u]){
                memcpy(f[p+1],f[p],W*sizeof(int));
                dfs2(v,u,p+1);
            }
        dfs2(son[u],u,p);
    }
}
void readData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].cost,&a[i].val);
    int x;
    for(int i=2;i<=n;i++){
        scanf("%d",&x);
        T::addEdge(x,i);
    }
    for(int i=1;i<=m;i++) scanf("%d",&money[i]);
    for(int i=1;i<=m;i++){
        scanf("%d",&x);
        que[x].PB(i);
    }
}
void printAnswer(){
    for(int i=1;i<=m;i++)
        printf("%d\n",ans[i]);
}
int main(){
    readData();
    T::dfs1(1,0);
    T::dfs2(1,0,0);
    printAnswer();
    return 0;
}
```

