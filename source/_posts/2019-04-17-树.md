---
title: 树
mathjax: true
date: 2019-04-17 08:47:12
tags: DP---期望概率DP
---

# Description

有一个长度为$N$的环，上面有$N$个点

所有点初始时都为白色

每个时刻，你会等概率地随机选一个点，把它染黑

如果一个白点的两边都是黑点，那么它也会自动变黑

问所有点都变黑的期望时间

$N\le 10^7$ 

<!-- more -->

# Solution

顺着题意去DP根本没法做，怎么办？

不妨考虑操作过的位置的集合$S$：如果任意两个相邻位置的距离都不超过$2$，游戏就会结束。设$f(x)$表示$|S|=x$的$S$出现的概率，则
$$
f(x)=\frac {x \choose n-x} {n-1 \choose x-1}
$$
要计算总期望时间，我们直接计算当操作集合大小为$x$时游戏尚未结束的概率，乘上集合大小变大的期望步数：
$$
ans=\sum_{i=0}^{n-1} \frac{n}{n-i}(1-f(i))
$$
$\frac n {n-i}$即操作集合大小从$i$变为$i+1$的期望时间，即选中一个$S$以外的点的期望步数

时间复杂度$O(n)$

# Code

```c++
#include <cstdio>
#define INV(x) FastPow(x,MOD-2)
const int MOD=1e9+7;
const int N=10000000+10;
int FastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}
int n;
int fact[N],iact[N];
int inv[N];
void ReadData(){
	scanf("%d",&n);
}
void InitArray(int n){
	fact[0]=fact[1]=1;
	for(int i=2;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;
	iact[0]=iact[1]=1;
	iact[n]=INV(fact[n]);
	for(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
	inv[0]=inv[1]=1;
	for(int i=2;i<=n;i++) inv[i]=-1ll*(MOD/i)*inv[MOD%i]%MOD;
}
void DP(){
	int ans=0;
	int mid=(n+1)>>1;
	for(int i=mid;i<n;i++)
		(ans+=1ll*inv[n-i]*(fact[n-1]-1ll*fact[i]*fact[i-1]%MOD*iact[2*i-n]%MOD)%MOD)%=MOD;
	ans=1ll*ans*iact[n-1]%MOD;
	for(int i=0;i<mid;i++)
		(ans+=inv[n-i])%=MOD;
	ans=1ll*ans*n%MOD;
	printf("%d\n",ans>=0?ans:ans+MOD);
}
int main(){
	ReadData();
	InitArray(n);
	DP();
	return 0;
}
```

