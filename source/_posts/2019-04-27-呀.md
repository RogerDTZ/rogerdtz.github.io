---
title: 呀
mathjax: true
date: 2019-04-27 08:52:43
tags: [数论---组合数学,方案特征]
---

# Description

给定一个$m$的排列$b$，对于所有满足$\forall i,a_{a_i}=i$的$n$的排列$a$（称其为合法），求有多少$a$包含$b$作为其子序列

$n \le 10^7$，$m \le 3000$

<!-- more -->

# Solution

考虑枚举$b$的前缀$i$并钦定只有它们处在$a$的前$m$位。先计算这$i$个元素放置到$a$的前$m$位的方案数，之后再考虑剩余位置的填法。注意到这$i$个元素要么填到与自己相等的位置，要么与这$i$个元素的另一个呼应（互填对方位置）。考虑离散化这个前缀$i$，然后将其看做一个$i$的排列判断其是否合法（可以用桶排离散化，复杂度$O(m)$）。显然，这个前缀要么合法，且只有唯一一种放置方法，要么不合法。因此这个前缀填入$a$的方案数只可能是$0$或$1$

此时$a​$的前$m​$位已经有$i​$个位置有值，剩余的$m-i​$个位置的值呢？这$m-i​$个位置的下标，就是$b​$中后$m-i​$位的元素，那么$a​$中这$m-i​$个位置填的值就是$b​$中后$m-i​$位元素分布到$a​$中后$n-m​$位的下标。显然，只要确定了$b​$中后$m-i​$位元素的位置，$a​$中前$m​$位剩余的$m-i​$个位置的值也就固定了。因此方案数为$n-m \choose m-i​$

$a$的后$n-m$位还剩下$(n-m)-(m-i)=n-2m+i$位未填。显然这些位置只能互相呼应，与$b$填入的位置没有任何交集。这相当于求有多少$n-2m+i$的排列是合法的，DP即可：

$$
f_n=f_{n-1}+(n-1)f_{n-2}
$$

答案即

$$
\sum_{i=0}^m legal(i){n-m \choose m-i}f_{n-2m+i}
$$

时间复杂度$O(m^2+n)$

# Code

```c++
#include <cstdio>

#define INV(x) FastPow(x,MOD-2)

const int MOD=1e9+7;
const int N=10000000+10;
const int M=3000+10;

int FastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}

int n,m;
int b[M];
int comb[M];
int f[N];

void ReadData(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++) scanf("%d",&b[i]);
}
void InitComb(){
	int x=n-m;
	comb[0]=1;
	for(int i=1;i<=m;i++)
		comb[i]=1ll*comb[i-1]*(x-i+1)%MOD*INV(i)%MOD;
}
void CalcF(){
	f[0]=1;
	f[1]=1;
	for(int i=2;i<=n;i++)
		f[i]=(f[i-1]+1ll*(i-1)*f[i-2])%MOD;
}
void Solve(){
	int ans=0;
	for(int i=0;i<=m;i++){
		static int bucket[M],x[M];
		for(int j=1;j<=m;j++) bucket[j]=0;
		for(int j=1;j<=i;j++) bucket[b[j]]=1;
		for(int j=1;j<=m;j++) bucket[j]+=bucket[j-1];
		for(int j=1;j<=i;j++) x[j]=bucket[b[j]];
		bool flag=true;
		for(int j=1;j<=i;j++)
			if(x[x[j]]!=j){
				flag=false;
				break;
			}
		if(flag)
			(ans+=1ll*((m-i<=n-m)?comb[m-i]:0)*(n-2*m+i>=0?f[n-2*m+i]:0)%MOD)%=MOD;
	}
	printf("%d\n",ans>=0?ans:ans+MOD);
}

int main(){
	ReadData();
	InitComb();
	CalcF();
	Solve();
	return 0;
}
```

