---
layout: post
mathjax: true
title: 地铁
date: 2019-01-14 21:00:00
tag: [网络流---最小割,平面对偶图]
---
# Description

　　给一张$n$个点的有向平面图，一共有$m$条边，每条边有边权，求从$1$号点走到$n$号点的最短路长度。当然，有$k$条限制，每条限制形如$(a,b)$，意义为如果经过了点$a$，那么一定要经过点$b$

　　$n,m \le 1001,\ k \le 998$
<!-- more -->
# Solution

　　一个平面图的最短路即其对偶图的最小割，一个平面图的最小割即其对偶图的最短路

　　直接建出原图的对偶图（为了方便，额外在最外边套一条大边），每一个区间$u$向所有子区间$v$连流量为$v$权值的边，**而其反向边设置成正无穷**。可以发现对偶图大体呈树形结构：根即大边对应的区域，特殊的是叶子节点全部连向一个汇点

　　考虑最小割的意义：割掉一条边$(u,v)$，代表$u+1 \dots v-1$这些点会被跳过，即走了一条包含$(u+1,v-1)$的边。显然，如果一条边被割掉，那么其子树的所有边也一定要割掉。为了限制这一点，只需将反向边设成正无穷即可

　　考虑如何绑定两个节点：对于限制$(a,b)$，我们分别找到真包含它们的最小区间，降这两个区间的区域对应点互相连上正无穷边，表示它们不可以被割开

　　建图完毕，直接跑最小割即可



# Code

```c++
#include <cstdio>
#include <algorithm>
#include <queue>
#define LYY_BAOLING {puts("-1"); exit(0);} // no solution, never
using std::sort;
using std::queue;
typedef long long LL;
const int INF=1e9+100000;
const int N=1001+10;
const int M=1000+10;
const int O=1000+10;
inline int min(int x,int y){
	return x<y?x:y;
}
int n,m,o;
struct Segment{
	int u,v,w;
	static bool contain(Segment a,Segment b,bool tru){
		if(tru)
			return a.u<b.u&&b.v<a.v;
		else
			return a.u<=b.u&&b.v<=a.v;
	}
}e[M];
int s[O][2];
namespace Flow{
	const int N=(::N)+(::M)+10;
	const int M=1000000;
	int h[N],tot;
	struct Edge{
		int v,f,next;
	}e[M*2];
	int flowS,flowT;
	int dis[N],cur[N];
	void addEdge(int u,int v,int f1,int f2){
		e[++tot]=(Edge){v,f1,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,f2,h[v]}; h[v]=tot;
	}
	void init(int s,int t){
		tot=1;
		flowS=s;
		flowT=t;
	}
	bool bfs(){
		static queue<int> q;
		while(!q.empty()) q.pop();
		for(int i=1;i<=flowT;i++){
			dis[i]=-1;
			cur[i]=h[i];
		}
		q.push(flowS);
		dis[flowS]=1;
		while(!q.empty()){
			int u=q.front();
			q.pop();
			for(int i=h[u],v;i;i=e[i].next)
				if(e[i].f&&dis[v=e[i].v]==-1){
					dis[v]=dis[u]+1;
					if(v==flowT)
						return true;
					q.push(v);
				}
		}
		return dis[flowT]!=-1;
	}
	LL dfs(int u,LL flow){
		if(u==flowT)
			return flow;
		LL res=0,get;
		for(int i=cur[u],v;i&&flow;i=e[i].next)
			if(e[i].f&&dis[v=e[i].v]==dis[u]+1){
				get=dfs(v,min(flow,e[i].f));
				e[i].f-=get;
				e[i^1].f+=get;
				if(e[i].f)
					cur[u]=i;
				flow-=get;
				res+=get;
			}
		if(!res)
			dis[u]=-1;
		return res;
	}
	LL Dinic(){
		LL res=0;
		while(bfs())
			res+=dfs(flowS,INF);
		return res;
	}
}
void readData(){
	scanf("%d%d%d",&n,&m,&o);
	static int mp[N][N];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++) 
			mp[i][j]=INF;
	for(int i=1;i<=m;i++){
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		mp[u][v]=min(mp[u][v],w);
	}
	m=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(mp[i][j]!=INF)
				e[++m]=(Segment){i,j,mp[i][j]};
	e[++m]=(Segment){0,n+1,INF};
	for(int i=1;i<=o;i++)
		scanf("%d%d",&s[i][0],&s[i][1]);
}
bool cmpWidth(const Segment &a,const Segment &b){
	if(a.u!=b.u||a.v!=b.v)
		return (a.v-a.u)>(b.v-b.u);
	return a.w>b.w;
}
void buildGraph(){
	Flow::init(1,m+n);
	sort(e+1,e+m+1,cmpWidth);
	for(int i=2;i<=m;i++){
		for(int j=i-1;j>=1;j--)
			if(Segment::contain(e[j],e[i],false)){
				Flow::addEdge(j,i,e[i].w,INF);
				break;
			}
	}
	for(int i=1;i<n;i++){
		Segment s=(Segment){i,i+1,INF};
		for(int j=m;j>=1;j--){
			if(j==1)
				LYY_BAOLING;
			if(Segment::contain(e[j],s,false)){
				Flow::addEdge(j,m+i,INF,INF);
				break;
			}
		}
		Flow::addEdge(m+i,Flow::flowT,INF,INF);
	}
	for(int i=1;i<=o;i++){
		int u=s[i][0],v=s[i][1];
		Segment su=(Segment){u,u,INF};
		Segment sv=(Segment){v,v,INF};
		int idu,idv;
		for(idu=m;idu>=1&&!Segment::contain(e[idu],su,true);idu--);
		for(idv=m;idv>=1&&!Segment::contain(e[idv],sv,true);idv--);
		Flow::addEdge(idu,idv,INF,INF);
		Flow::addEdge(idv,idu,INF,INF);
	}
}
int main(){
	readData();
	buildGraph();
	LL ans=Flow::Dinic();
	if(ans>=INF)
		LYY_BAOLING
	else
		printf("%lld\n",ans);
	return 0;
}
```

