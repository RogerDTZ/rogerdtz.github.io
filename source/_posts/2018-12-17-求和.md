---
layout: post
mathjax: true
title: 求和
date: 2018-12-17 11:03:00
tag: [数据结构---维护题,数据结构---线段树,好题]
---
# Description

　　有一个长度为$n$的数组$a_i$，再给定一个参数$k$

　　请支持$q$次修改操作，每次操作只修改一个元素。你需要在一开始和每次修改之后回答下标相差不超过$k$的两个元素之和的最大值

　　$1 \le k < n \le 10^6,\ q \le 10^6$



　　
<!-- more -->
# Solution

　　定义第$i$个元素的贡献为$v_i$，则答案为$\max v_i$。$v_i$的值如下

$$
v_i=\left\{
\begin{array}{rcl}
a_i+\max\{a_j\mid j\in[i-k,i+k]-\{i\}\}& &{a_i为[i-k,i+k]中的最大值}\\
-\infty& &{\text{else}}
\end{array} \right.
$$

　　如果存在相同元素，我们以下标为第二关键字将其区分即可

　　若一个元素不是管辖范围内的最大值，那么它的贡献不可能优于范围内最大值的那个位置的贡献，将其设为不影响答案的值即可

　　为什么这样维护是对的呢？首先明确目标：如果对于每一个$i$，形如$(i,\dots)$的点对都能被考虑或被更优解覆盖，则维护就是完整且正确的。下面具体证明一下：

1. $i$是管辖范围内的最大值：显然$v_i$能够完整地考虑这些点对
2. $i$不是管辖范围内的最大值：设管辖范围内的最大值在$j$处，形如$(i,x\neq j)$的点对显然没有$(i,j)$优，而后者会在$v_j$处被考虑到

　　证毕

　　修改一个元素$a_i$时，先进行数值修改，之后我们只需要重新计算$[i-k,i)$中的最大值位置$x$、$(i,i+k]$中的最大值位置$y$以及$i$这三个位置的$v$即可。下面是对正确性的证明：

1. 若修改后$a_i$成为了管辖范围的最大值：首先，$v_i$会被更新为正确的值；若原来区间最大值不是$a_i$，则原最大值一定为$x$或$y$中的某一个，会被相应更新。由于现在$a_i$是最大值，故$a_i$不会在其他某一个点的$v$中呈现，因此没有考虑维护其他$v$的必要
2. 若修改后$a_i$并不是管辖范围的最大值：首先，$v_i$会被更新为正确的值；新的区间最大值必然是$x$和$y$中的一个，会被相应更新，$a_i$作为其他某一个点的$v$呈现的情况已经被考虑周全

　　本题极度卡常，最好使用zkw线段树。时间复杂度$O(n \log n)$

　　

# Code

```c++
#include <cstdio>
using namespace std;
typedef long long LL;
namespace IO{
    const int L=50000000;
    char inBuf[L],outBuf[L];
    int inPos,outPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    void flush(){
        fwrite(outBuf,1,outPos,stdout);
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        for(;c<'0'||c>'9';c=getChar()){if(c=='-')f=-1;}
        for(;'0'<=c&&c<='9';c=getChar()){x=x*10+c-'0';}
        return x*f;
    }
    void writeChar(char c){
        outBuf[outPos++]=c;
    }
    void writeInt(int x,char end='\n'){
        if(!x)
            writeChar('0');
        else{
            static int digit[20],cnt;
            for(cnt=0;x;x/=10) digit[++cnt]=x%10;
            for(;cnt;cnt--) writeChar('0'+digit[cnt]);
        }
        writeChar(end);
    }
}
using IO::getInt;
using IO::writeInt;
const int INF=1e9;
const int N=1000010;
inline LL max(LL x,LL y){
    return x>y?x:y;
}
inline LL min(LL x,LL y){
    return x<y?x:y;
}
int n,m,q,op;
int a[N];
LL b[N];
namespace SEG{
    const int N=(1<<22);
    LL maxa[N];
    int maxv[N];
    int m;
    void build(int n){
        for(m=1;m<(n+2);m<<=1);
        for(int i=1;i<=n;i++){
            maxa[m+i]=b[i];
            maxv[m+i]=0;
        }
        for(int i=m-1;i>=1;i--){
            maxa[i]=max(maxa[i<<1],maxa[i<<1|1]);
            maxv[i]=max(maxv[i<<1],maxv[i<<1|1]);
        }
    }
    LL queryMax(int l,int r){
        LL res=0;
        for(int u=m+l-1,v=m+r+1;u^v^1;u>>=1,v>>=1){
            if(!(u&1))
                res=max(res,maxa[u^1]);
            if(v&1)
                res=max(res,maxa[v^1]);
        }
        return res;
    }
    void setArr(int p,int x){
        a[p]=x;
        b[p]=((LL)a[p]<<25)+p;
        maxa[m+p]=b[p];
        for(int u=(m+p)>>1;u;u>>=1)
            maxa[u]=max(maxa[u<<1],maxa[u<<1|1]);
    }
    void setValue(int p,int x){
        maxv[m+p]=x;
        for(int u=(m+p)>>1;u;u>>=1)
            maxv[u]=max(maxv[u<<1],maxv[u<<1|1]);
    }
    int getAnswer(){
        return maxv[1];
    }
}
void readData(){
    n=getInt(); m=getInt(); q=getInt(); op=getInt();
    for(int i=1;i<=n;i++){
        a[i]=getInt();
        b[i]=((LL)a[i]<<25)+i;
    }
}
void calc(int p){
    int l=max(1,p-m),r=min(n,p+m);
    if(SEG::queryMax(l,r)==b[p]){
        int match=0;
        if(l<p)
            match=max(match,SEG::queryMax(l,p-1)>>25);
        if(p<r)
            match=max(match,SEG::queryMax(p+1,r)>>25);
        SEG::setValue(p,match+a[p]);
    }
    else
        SEG::setValue(p,0);
}
void modify(int x,int y){
    SEG::setArr(x,y);
    calc(x);
    int l=max(1,x-m),r=min(n,x+m),pos;
    if(l<x)
        calc(SEG::queryMax(l,x-1)&((1<<25)-1));
    if(x<r)
        calc(SEG::queryMax(x+1,r)&((1<<25)-1));
}
void answerQuery(){
    int ans;
    for(int i=1;i<=n;i++) calc(i);
    writeInt(ans=SEG::getAnswer());
    int x,y;
    for(int i=1;i<=q;i++){
        x=getInt(); y=getInt();
        if(op){
            x^=ans;
            y^=ans;
        }
        modify(x,y);
        writeInt(ans=SEG::getAnswer());
    }
}
int main(){
    IO::load();
    readData();
    SEG::build(n);
    answerQuery();
    IO::flush();
    return 0;
}
```

