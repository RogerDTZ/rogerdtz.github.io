---
layout: post
mathjax: true
title: 三角形
date: 2019-02-25 20:14:00
tag: [贪心,数据结构---线段树]
category: [2018集训队作业]
---
# Description

　　有一棵$N$个节点的树，每个节点$i$有一个权值$w_i$

　　你可以往节点上放置或拿走石子。记节点$i$上的石子数为$a_i$。初始时，$\forall i\ a_i=0$。接下来，你可以任意执行以下两种操作：

1. 拿走一个节点上的所有石子

2. 若节点$u$的所有儿子$v$都满足$a_v=w_v$，你可以往$u$上放置$w_u$个石子

　　对于每一个$i$（$i \in [1,n]$），请回答：若要使得$a_i=w_i$，你最少需要准备多少石子？



　　
<!-- more -->
# Solution

　　自下往上、按一定顺序遍历儿子的做法是假的，因为可能存在更优的同时下推的方案

　　我们将过程反过来考虑。求$i$子树的答案时，初始时，只有根节点$i$被选中，且有$a_i=w_i$。之后，每次我们挑一个父亲已被选中的节点或根节点（记为$u$），执行下面的操作：

* 对$u​$的所有儿子$v​$执行2.操作，然后的对$u​$执行1.操作

　　可以证明，这两步连接在一起是最优的

　　我们的目的是清空子树中的所有石子，并使得历史最大值最小

　　记$sum$表示当前正在使用的石子数，则对$u$执行操作后，$sum+=\sum_vw_v-w_u$。历史最大值即$sum$的最大值

　　我们对每个点$u$记一个二元组$(\sum_vw_v-w_u,\sum_vw_v)$，分别表示对$u$执行操作后，$sum$的变化值以及执行操作时最大值与未执行之前的差（变化过程为一上一下）。在不考虑“父亲必须先操作”的限制下，我们实际上只需要对所有点确定一个最优执行顺序即可。要得到最优顺序，使用如下比较函数排序：

　　对于$(a,b)$和$(c,d)$，定义$(a,b)<(c,d)$（前者优于后者）当且仅当以下某个条件成立

* $a<0, c>0$：先执行$(a,b)$能整体降低后续的$sum$值，而先执行$(c,d)$会起相反作用
* $a<0,c<0,b<d$：拔高较小的优先执行，这样拔高较大的二元组会在$sum$更低时执行，达到最优
* $a>0,c>0,b-a>c-d$：既然都要提高，$b-a$更大即执行操作时下坡更大，为后续摆动预撑更多空间

　　考虑“父亲必须先选”的条件。每次找出优先级最高的点时，我们都希望在其父亲被选择后的第一时间选择它自己。由此可以给出以下算法：初始时，每个节点都有个序列，只包含它自己。每次我们找到优先级最高的的点，把它的序列接到父亲之后，在并查集上将自己缩进父亲，让父亲的二元组与自己的二元组进行合并：先执行$(a,b)$后执行$(c,d)$等价于执行$(a+c,\max(b,a+d))$。最后，根节点的序列就是真正的操作序列。具体实现上，并查集+优先队列即可。

　　到此我们给出了$O(n^2 \log n)$的算法。注意到每个子树的操作序列都是整棵树的操作序列的一个子序列，因此我们可以用一棵线段树维护一棵子树内二元组的执行，自下往上线段树合并即可

　　

# Code

```c++
#include <cstdio>
#include <queue>
#include <algorithm>
#include <vector>
#define PB push_back
using namespace std;
typedef long long LL;
const int N=200000+10;
int task;
int n;
int fa[N];
int w[N];
struct Data{
	LL x,y;
	int id;
	Data(){}
	Data(LL x,LL y): x(x),y(y) {}
	Data(LL x,LL y,int id): x(x),y(y),id(id) {}
	friend bool operator < (const Data &a,const Data &b){
		if(a.x<0&&b.x<0)
			return (a.y!=b.y)?a.y<b.y:a.id<b.id;
		else if(a.x<0||b.x<0)
			return a.x<0;
		else
			return ((a.y-a.x)!=(b.y-b.x))?(a.y-a.x)>(b.y-b.x):a.id<b.id;
	}
	friend bool operator == (const Data &a,const Data &b){
		return a.x==b.x&&a.y==b.y&&a.id==b.id;
	}
	friend bool operator > (const Data &a,const Data &b){
		return !(a<b)&&!(a==b);
	}
	static Data merge(Data a,Data b){
		return Data(a.x+b.x,max(a.y,a.x+b.y),a.id);
	}
}data[N];
int seq[N],pos[N];
LL ans[N];
namespace Seg{
	const int N=(::N);
	const int SIZE=N*20;
	int rt[N];
	struct Node{
		int ch[2];
		Data s;
	}a[SIZE];
	int nodeCnt;
	inline void pushup(int u){
		a[u].s=Data::merge(a[a[u].ch[0]].s,a[a[u].ch[1]].s);
	}
	void insert(int &u,int l,int r,int p){
		if(!u)
			u=++nodeCnt;
		if(l==r){
			a[u].s=data[seq[p]];
			return;
		}
		int mid=(l+r)>>1;
		if(p<=mid)
			insert(a[u].ch[0],l,mid,p);
		else
			insert(a[u].ch[1],mid+1,r,p);
		pushup(u);
	}
	int merge(int x,int y){
		if(!x||!y)
			return x+y;
		int u=++nodeCnt;
		a[u].ch[0]=merge(a[x].ch[0],a[y].ch[0]);
		a[u].ch[1]=merge(a[x].ch[1],a[y].ch[1]);
		pushup(u);
		return u;
	}
	void mergeTree(int u,int v){
		rt[u]=merge(rt[u],rt[v]);
	}
	LL query(int u){
		return a[rt[u]].s.y;
	}
}
namespace Tree{
	const int N=(::N);
	int h[N],tot;
	struct Edge{
		int v,next;
	}e[N];
	void addEdge(int u,int v){
		e[++tot]=(Edge){v,h[u]}; h[u]=tot;
	}
	bool cmpData(const int &x,const int &y){
		return data[x]<data[y];
	}
	int bel[N];
	int findBel(int x){
		return (bel[x]==x)?x:(bel[x]=findBel(bel[x]));
	}
	void initSeq(){
		static int nex[N],end[N];
		static Data cur[N];
		static priority_queue<Data,vector<Data>,greater<Data> > q;
		for(int i=1;i<=n;i++){
			bel[i]=i;
			nex[i]=0;
			end[i]=i;
			cur[i]=data[i];
			q.push(cur[i]);
		}
		while(true){
			int u=-1;
			while(!q.empty()){
				Data now=q.top();
				q.pop();
				if(now==cur[now.id]){
					u=now.id;
					break;
				}
			}
			if(u==-1)
				break;
			if(fa[u]==0)
				continue;
			int fu=findBel(fa[u]);
			bel[u]=fu;
			nex[end[fu]]=u;
			end[fu]=end[u];
			cur[fu]=Data::merge(cur[fu],cur[u]);
			q.push(cur[fu]);
		}
		int u=1;
		for(int i=1;i<=n;i++,u=nex[u]){
			seq[i]=u;
			pos[u]=i;
		}
	}
	void dfs(int u){
		for(int i=h[u],v;i;i=e[i].next){
			v=e[i].v;
			dfs(v);
			Seg::mergeTree(u,v);
		}
		Seg::insert(Seg::rt[u],1,n,pos[u]);
		ans[u]=w[u]+Seg::query(u);
	}
}
void readData(){
	scanf("%d",&task);
	scanf("%d",&n);
	for(int i=2;i<=n;i++){
		scanf("%d",&fa[i]);
		Tree::addEdge(fa[i],i);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);
		data[i].id=i;
		data[i].x-=w[i];
		if(fa[i]){
			data[fa[i]].x+=w[i];
			data[fa[i]].y+=w[i];
		}
	}
}
int main(){
	readData();
	Tree::initSeq();
	Tree::dfs(1);
	for(int i=1;i<=n;i++) printf("%lld ",ans[i]);
	puts("");
	return 0;
}
```

