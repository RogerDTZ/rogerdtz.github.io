---
title: 平均值
mathjax: true
date: 2019-03-23 11:25:29
tags: [数据结构---线段树,好题,可做未做]
---

# Description

给定一个长度为$n$的序列$a_1,a_2,\dots,a_n$

定义$\text{mex}(l,r)$表示$a_l,a_{l+1},\dots,a_r$的$\text{mex}$值

求：
$$
\sum_{l=1}^n\sum_{r=l}^n \frac {\text{mex}(l,r)} {r-l+1}
$$
答案模$998244353$

$1 \le n \le 5 \times 10^5$，$0 \le a_i \le 5 \times 10^5$

<!-- more -->

# Solution

显然要将函数值转化成枚举+判定问题，即求：
$$
\sum_{x=0}^{up}\sum_{l \le r} \frac {[\text{mex}(l,r)>x]} {r-l+1}
$$
其中$up$为最大的自然数$x$，满足$[0,x]$在$a$中都出现过

考虑$x​$固定时算的是什么：包含$[0,x]​$所有数的区间的长度倒数之和

注意到对于每一个左端点$l$，右端点$r$在向右移动一定距离之后区间会一直合法，因此其对答案的贡献是分母连续的一些分数之和

令$s_i=\sum_{j=1}^i \frac 1 j$；令$f_x(l)$表示左端点为$l$时，右端点至少要到什么位置，才能使区间$[l,r]$包含$[0,x]$的所有数。

则答案变成：
$$
\sum_{x=0}^{up}\sum_{l=1}^n s_{n-l+1}-s_{f_x(l)-l}
$$
接下来看看当$x$变成$x+1$时，$f$发生了什么变化：原来包含$[0,x]$的区间，现在必须向右扩展，直到包含至少一个$x+1$为止

记$x+1$的出现位置为$p_1,p_2,\dots,p_k$。对于夹在两个$x+1$之间的左端点$l \in (p_i,p_{i+1})$，由于$f_x(l)$显然是递增的，有一段前缀的$l$会满足$f_{x}(l) < p_{i+1}$，而其余满足$f_{x}(l) \ge p_{i+1}$。显然，所有前者的$f$现在都应该被赋值为$p_{i+1}$

考虑使用线段树维护$x$递增时的$f_x(l)$，同时维护$s_{f_x(l)-l}$的和。每次$x$变化时，我们枚举$x+1$的出现位置，二分一段区间并将$f$赋值为新值。由于赋值的区间标号连续，新的区间$s$之和也可以很方便地考虑

时间复杂度$O(n \log n)​$

# Code

```c++
#include <cstdio>
#include <vector>
using std::vector;
typedef long long LL;
const int MOD=998244353;
const int N=500000+10;
const int W=500000+10;
inline int min(int x,int y){
    return x<y?x:y;
}
namespace IO{
    const int LEN=20000000;
    char *inBuf,*inPtr;
    void Init(){
        inBuf=new char[LEN];
    }
    void Load(){
        fread(inBuf,1,LEN,stdin);
        inPtr=inBuf;
    }
    char GetChar(){
        return *(inPtr++);
    }
    int GetInt(){
        int x=0,f=1;
        char c=GetChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=GetChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=GetChar();}
        return x*f;
    }
}
int n;
int a[N];
bool b[W];
vector<int> p[W];
int inv[N];
int s[N],s2[N];
void InitInv(int n){
    inv[0]=inv[1]=1;
    for(int i=2;i<=n;i++) inv[i]=-1ll*(MOD/i)*inv[MOD%i]%MOD;
}
void InitPrefix(int n){
    for(int i=1;i<=n;i++){
        s[i]=(s[i-1]+inv[i])%MOD;
        s2[i]=(s2[i-1]+s[i])%MOD;
    }
}
void ReadData(){
    using IO::GetInt;
    n=GetInt();
    for(int i=1;i<=n;i++){
        a[i]=GetInt();
        b[a[i]]=true;
        p[a[i]].push_back(i);
    }
}
namespace Seg{
    const int SIZE=(::N)*2;
    struct Node{
        int ch[2];
        int val,minVal;
        LL sum;
        int setTag;
    }a[SIZE];
    int nodeCnt;
    int rt;
    void MakeSetTag(int u,int l,int r,int x){
        a[u].setTag=x;
        a[u].val=a[u].minVal=x;
        a[u].sum=s2[x-l]-s2[(x-r)-1];
    }
    void Pushup(int u){
        a[u].minVal=min(a[a[u].ch[0]].minVal,a[a[u].ch[1]].minVal);
        a[u].sum=a[a[u].ch[0]].sum+a[a[u].ch[1]].sum;
    }
    void Pushdown(int u,int l,int r){
        int mid=(l+r)>>1;
        if(a[u].setTag!=-1){
            MakeSetTag(a[u].ch[0],l,mid,a[u].setTag);
            MakeSetTag(a[u].ch[1],mid+1,r,a[u].setTag);
            a[u].setTag=-1;
        }
    }
    void Build(int &u,int l,int r){
        u=++nodeCnt;
        a[u].setTag=-1;
        if(l==r){
            a[u].val=a[u].minVal=l;
            a[u].sum=0;
            return;
        }
        int mid=(l+r)>>1;
        Build(a[u].ch[0],l,mid);
        Build(a[u].ch[1],mid+1,r);
        Pushup(u);
    }
    void SetSeg(int u,int l,int r,int ml,int mr,int x){
        if(ml<=l&&r<=mr){
            MakeSetTag(u,l,r,x);
            return;
        }
        Pushdown(u,l,r);
        int mid=(l+r)>>1;
        if(mr<=mid){
            SetSeg(a[u].ch[0],l,mid,ml,mr,x);
        }else if(mid<ml){
            SetSeg(a[u].ch[1],mid+1,r,ml,mr,x);
        }else{
            SetSeg(a[u].ch[0],l,mid,ml,mid,x);
            SetSeg(a[u].ch[1],mid+1,r,mid+1,mr,x);
        }
        Pushup(u);
    }
    int Find(int u,int l,int r,int ql,int qr,int x){ // the last i in [ql,qr] such that val(i)<x
        if(a[u].minVal>=x)
            return -1;
        int mid=(l+r)>>1;
        if(ql<=l&&r<=qr){
            if(l==r)
                return a[u].val<x?l:-1;
            Pushdown(u,l,r);
            int temp=Find(a[u].ch[1],mid+1,r,mid+1,r,x);
            if(temp!=-1)
                return temp;
            return Find(a[u].ch[0],l,mid,l,mid,x);
        }
        Pushdown(u,l,r);
        if(qr<=mid){
            return Find(a[u].ch[0],l,mid,ql,qr,x);
        }else if(mid<ql){
            return Find(a[u].ch[1],mid+1,r,ql,qr,x);
        }else{
            int temp=Find(a[u].ch[1],mid+1,r,mid+1,qr,x);
            if(temp!=-1)
                return temp;
            return Find(a[u].ch[0],l,mid,ql,mid,x);
        }
    }
    LL Query(){
        return a[rt].sum;
    }
}
void Solve(){
    Seg::Build(Seg::rt,1,n);
    LL ans=0;
    for(int x=0;x<n&&b[x];x++){
        ans+=s2[n];
        p[x].push_back(n+1);
        for(int i=0;i<int(p[x].size());i++){
            int l=(i>0?p[x][i-1]+1:1);
            int r=p[x][i]-1;
            if(l>r)
                continue;
            int p=Seg::Find(Seg::rt,1,n,l,r,r+1);
            if(l<=p)
                Seg::SetSeg(Seg::rt,1,n,l,p,r+1);
        }
        ans-=Seg::Query()%MOD;
    }
    ans%=MOD;
    printf("%lld\n",ans>=0?ans:ans+MOD);
}
int main(){
    IO::Init();
    IO::Load();
    InitInv(500000);
    InitPrefix(500000);
    ReadData();
    Solve();
    return 0;
}
```

