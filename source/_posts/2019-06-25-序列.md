---
title: 序列
mathjax: true
date: 2019-06-25 08:30:51
tags: [字符串---后缀树,数据结构---平衡树]
---

# Description

给定正整数$m$和整数序列$a_1,a_2,\dots,a_n$

有$q$个询问，每次询问给出$d,k$，令$b_i=(a_i+d) \bmod m$，将$b$当成一个字符串，求字典序第$k$小的后缀下标

$n \le 10^5$，$q \le 5 \times 10^5$

<!-- more -->

# Solution

显然序列只有$O(n)$中不同的情况，顺次处理离线回答询问即可

建出后缀树，每次我们相当于要把树上的某一个转移变成一个新的、最小的转移，显然旧转移是每个节点所有转移中最大的，新转移是最小的

所以操作相当于是移动子树

考虑总操作次数：由于序列中每个元素至多被变换一次，因此总的变换次数就是后缀树节点数

用平衡树维护后缀树的DFS序即可

时间复杂度$O(n \log n)$

# Summary

<!-- summary_start -->

如果可以，最好在一个确切的模型上准确分析操作复杂度，这样就不会因为自认为复杂度没有保证而放弃了一道可做的题

<!-- summary_end -->

# Code

```c++
#include <cstdio>
#include <utility>
#include <algorithm>
#include <map>
#include <vector>

#define FR first
#define SE second

using std::sort;
using std::unique;
using std::map;
using std::vector;

const int N=100000+10;
const int Q=500000+10;

int n,m,q;
int a[N];
struct Query{
	int d,k;
	int qid;
	static bool CmpD(const Query &a,const Query &b){
		return a.d<b.d;
	}
}que[Q];
int ans[Q];

void ReadData(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=q;i++){
		scanf("%d%d",&que[i].d,&que[i].k);
		que[i].qid=i;
	}
}

namespace SAM{
	const int N=(::N);
	const int SIZE=N*2;
	struct Node{
		map<int,int> trans;
		int len;
		int link;
		int endPos;
	}node[SIZE];
	int nodeCnt;
	int rt,cur;
	int isEnd[SIZE];
	void Init(){
		rt=cur=nodeCnt=1;
	}
	void Extend(int c,int endPos){
		int u=++nodeCnt,p=cur;
		node[u].len=node[p].len+1;
		node[u].endPos=endPos;
		isEnd[u]=n-node[u].len+1;
		for(;p&&node[p].trans[c]==0;p=node[p].link) node[p].trans[c]=u;
		if(!p){
			node[u].link=rt;
		}else{
			int q=node[p].trans[c];
			if(node[q].len==node[p].len+1){
				node[u].link=q;
			}else{
				int v=++nodeCnt;
				node[v]=node[q];
				node[v].len=node[p].len+1;
				node[q].link=node[u].link=v;
				for(;p&&node[p].trans[c]==q;p=node[p].link) node[p].trans[c]=v;
			}
		}
		cur=u;
	}
}

namespace Splay{
	const int SIZE=(SAM::SIZE);
	struct Node{
		int fa;
		int ch[2];
		int size;
		int cnt;
	}node[SIZE];
	int rt;
	int dest;
	inline int who(int u){
		return node[node[u].fa].ch[1]==u;
	}
	void Pushup(int u){
		int lc=node[u].ch[0],rc=node[u].ch[1];
		node[u].size=node[lc].size+node[rc].size+1;
		node[u].cnt=node[lc].cnt+node[rc].cnt+(SAM::isEnd[u]!=0);
	}
	void Rotate(int u){
		int f=node[u].fa,g=node[f].fa,c=who(u);
		if(g)
			node[g].ch[who(f)]=u;
		node[u].fa=g;
		node[f].ch[c]=node[u].ch[c^1];
		if(node[f].ch[c])
			node[node[f].ch[c]].fa=f;
		node[u].ch[c^1]=f;
		node[f].fa=u;
		Pushup(f);
		Pushup(u);
	}
	void Splay(int u,int endFa=0){
		for(;node[u].fa!=endFa;Rotate(u))
			if(node[node[u].fa].fa!=endFa)
				Rotate(who(u)==who(node[u].fa)?node[u].fa:u);
		if(endFa==0)
			rt=u;
	}
	int GetRank(int u){
		Splay(u);
		return node[node[u].ch[0]].size+1;
	}
	int GetByRank(int u,int k){
		int cmp=node[node[u].ch[0]].size+1;
		if(k==cmp)
			return u;
		int res;
		if(k<cmp)
			res=GetByRank(node[u].ch[0],k);
		else
			res=GetByRank(node[u].ch[1],k-cmp);
		if(u==rt)
			Splay(res);
		return res;
	}
	void Build(int n,int *arr){
		for(int i=n;i>=1;i--){
			int u=arr[i];
			node[u].ch[1]=arr[i+1];
			node[u].size=1;
			node[u].cnt=(SAM::isEnd[u]!=0);
			node[node[u].ch[1]].fa=u;
			Pushup(u);
		}
		rt=arr[1];
	}
	void Move(int l,int r,int pos){
		int x=-1,y=-1,z=0;
		if(l>1)
			x=GetByRank(rt,l-1);
		if(r<SAM::nodeCnt)
			y=GetByRank(rt,r+1);
		if(x!=-1&&y!=-1){
			Splay(x);
			Splay(y,x);
			z=node[y].ch[0];
			node[y].ch[0]=0;
			Pushup(y);
		}else if(x!=-1){
			Splay(x);
			z=node[x].ch[1];
			node[x].ch[1]=0;
			Pushup(x);
		}else if(y!=-1){ // impossible
		}else{ // impossible
		}
		Splay(x=GetByRank(rt,pos));
		if(node[x].ch[1]==0){
			node[x].ch[1]=z;
			node[z].fa=x;
			Pushup(x);
		}else{
			y=GetByRank(rt,pos+1);
			Splay(x);
			Splay(y,x);
			node[y].ch[0]=z;
			node[z].fa=y;
			Pushup(y);
		}
	}
	int Query(int u,int k){
		int cmp=node[node[u].ch[0]].cnt+(SAM::isEnd[u]!=0);
		if(cmp==k&&SAM::isEnd[u]!=0){
			dest=u;
			return SAM::isEnd[u];
		}
		int res;
		if(k<=cmp)
			res=Query(node[u].ch[0],k);
		else
			res=Query(node[u].ch[1],k-cmp);
		if(u==rt)
			Splay(dest);
		return res;
	}
}

namespace SFT{
	using SAM::SIZE;
	using SAM::node;
	using SAM::nodeCnt;
	map<int,int> ch[SIZE];
	int fa[SIZE];
	int size[SIZE];
	int dfnLis[SIZE],dfnTimer;
	map<int,vector<int> > info;
	int curID;
	void Build(){
		for(int u=2;u<=nodeCnt;u++)
			ch[node[u].link][a[node[u].endPos+node[node[u].link].len]]=u;
	}
	void DFS(int u){
		dfnLis[++dfnTimer]=u;
		size[u]=1;
		for(map<int,int>::iterator it=ch[u].begin();it!=ch[u].end();it++)
			if(it->SE){
				int c=it->FR;
				int v=it->SE;
				info[c].push_back(v);
				fa[v]=u;
				DFS(v);
				size[u]+=size[v];
			}
	}
	void InitSplay(){
		DFS(1);
		Splay::Build(nodeCnt,dfnLis);
	}
	void Work(int id){
		curID--;
		vector<int> &lis=info[id];
		for(int p=0;p<int(lis.size());p++){
			int u=lis[p];
			int f=fa[u];
			int l=Splay::GetRank(u),r=l+size[u]-1;
			Splay::Move(l,r,Splay::GetRank(f));
			ch[f][id]=0;
			ch[f][curID]=u;
		}
	}
}

void InitData(){
	SAM::Init();
	for(int i=n;i>=1;i--)
		SAM::Extend(a[i],i);
	SFT::Build();
	SFT::InitSplay();
}

int tim[N],tcnt;

bool CmpOrder(const int &x,const int &y){
	return x>y;
}

void InitTime(){
	for(int i=1;i<=n;i++) tim[++tcnt]=a[i];
	sort(tim+1,tim+tcnt+1,CmpOrder);
	tcnt=unique(tim+1,tim+tcnt+1)-tim-1;
	tim[tcnt+1]=0;
}

void AnswerQuery(){
	sort(que+1,que+q+1,Query::CmpD);
	SFT::curID=0;
	for(int i=0,j=1;i<=tcnt&&j<=q;i++){
		for(;j<=q&&que[j].d<m-tim[i+1];j++)
			ans[que[j].qid]=Splay::Query(Splay::rt,que[j].k);
		if(i<tcnt)
			SFT::Work(tim[i+1]);
	}
	for(int i=1;i<=q;i++) printf("%d\n",ans[i]);
}

int main(){
	ReadData();
	InitData();
	InitTime();
	AnswerQuery();
	return 0;
}
```

