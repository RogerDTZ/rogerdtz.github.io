---
layout: post
title: 疯狂求导
date: 2018-09-18
category: 2016北京集训
tag: 数据结构---树套树
mathjax: true
---
# Description

　　题意简述：一行序列，每一个位置有一个多项式，支持区间加一个系数为1的单项式

​	　　询问如下：对于$[l,r]$多项式之和，找到最小的$k$，使得指数大于等于$k$的项的系数之和不超过给定的界限$s$





![](http://192.168.102.138/JudgeOnline/upload/attachment/image/20160320/20160320180241_86832.jpg)


<!-- more -->
# Solution

　　我居然没看出这是一道数据结构题？

　　最直接的想法是，按照暴力那样，每一个位置维护一个多项式，然后用二分答案来判定后缀和是否不超过界限......

　　可是这样显然没法做啊。第一，怎么可能开的下这么大的数组；第二，求和操作不现实。这个方案应该第一时间被舍弃，可我还是往这里想了半天

　　所以直想应该是行不通的

　　考虑二分答案时，每次要查询一段区间的多项式之和中，指数大于等于某个数的单项式系数和是多少

　　既然以区间作为第一维、指数作为第二维不行，那么我们就要想想能不能交换一下两个维度

　　把指数作为第一维，下标作为第二维

　　第一维用线段树维护这一段指数范围中，每个区间的系数和是多少

　　第二维也用线段树维护，动态开点，这样就不会爆空间

　　那么就是一个经典的线段树套线段树题，查询在第一维上线段树二分即可

# Summary

　　每个位置一个超长元素，如果第一维是按位置为下标可能不行。不妨交换两维考虑，说不定就更利于操作了

　　如果感觉线段树根本开不下，有可能是使用动态开点使得总空间复杂度和操作次数有关（利用线段树在表示方面的性质）。不要直接把自己从正解方向吓走了

# Code

```c++
#include <cstdio>
using namespace std;
typedef long long ll;
namespace IO{
    const int S=20000000;
    char in_buf[S];
    int in_pos;
    void load(){
        in_pos=0;
        fread(in_buf,1,S,stdin);
    }
    char getChar(){
        return in_buf[in_pos++];
    }
    ll getLong(){
        ll x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getLong;
const int N=200010,M=20010,V=1000010;
int n,m;
int maxa=1000000;
namespace SEG2{
    const int S=V*2*18;
    int sz,rt[V*2];
    int ch[S][2],sum[S],tag[S];
    inline void pushup(int u){
        sum[u]=sum[ch[u][0]]+sum[ch[u][1]];
    }
    inline void makeTag(int u,int l,int r,int x){
        sum[u]+=(r-l+1)*x;
        tag[u]+=x;
    }
    inline void pushdown(int u,int l,int r){
        if(tag[u]){
            int mid=(l+r)>>1;
            if(!ch[u][0]) 
                ch[u][0]=++sz;
            if(!ch[u][1])
                ch[u][1]=++sz;
            makeTag(ch[u][0],l,mid,tag[u]);
            makeTag(ch[u][1],mid+1,r,tag[u]);
            tag[u]=0;
        }
    }
    void modify(int &u,int l,int r,int L,int R){
        if(!u){
            u=++sz;
            sum[u]=tag[u]=0;
        }
        if(L<=l&&r<=R){
            makeTag(u,l,r,1);
            return;
        }
        pushdown(u,l,r);
        int mid=(l+r)>>1;
        if(R<=mid)
            modify(ch[u][0],l,mid,L,R);
        else if(mid<L)
            modify(ch[u][1],mid+1,r,L,R);
        else{
            modify(ch[u][0],l,mid,L,mid);
            modify(ch[u][1],mid+1,r,mid+1,R);
        }
        pushup(u);
    }
    int query(int &u,int l,int r,int L,int R){
        if(!u)
            return 0;
        if(L<=l&&r<=R)
            return sum[u];
        pushdown(u,l,r);
        int mid=(l+r)>>1;
        if(R<=mid)
            return query(ch[u][0],l,mid,L,R);
        else if(mid<L)
            return query(ch[u][1],mid+1,r,L,R);
        else
            return query(ch[u][0],l,mid,L,mid)+
                   query(ch[u][1],mid+1,r,mid+1,R);
    }
}
namespace SEG1{
    const int S=V*2;
    int rt,sz;
    int ch[S][2],val[S];
    int nl,nr;
    ll limit,ans,sum;
    void build(int &u,int l,int r){
        u=++sz;
        if(l==r)
            return;
        int mid=(l+r)>>1;
        build(ch[u][0],l,mid);
        build(ch[u][1],mid+1,r);
    }
    void modify(int u,int l,int r,int pos){
        SEG2::modify(SEG2::rt[u],1,n,nl,nr);
        if(l==r)
            return;
        int mid=(l+r)>>1;
        if(pos<=mid)
            modify(ch[u][0],l,mid,pos);
        else
            modify(ch[u][1],mid+1,r,pos);
    }
    void setCurrent(int _l,int _r){
        nl=_l;
        nr=_r;
    }
    void query(int u,int l,int r){
        ll rsum=SEG2::query(SEG2::rt[ch[u][1]],1,n,nl,nr);
        if(l==r){
            ll cur=SEG2::query(SEG2::rt[u],1,n,nl,nr);
            if(cur<=limit){
                ans=l;
                sum+=cur;
            }
            else
                ans=l+1;
            return;
        }
        int mid=(l+r)>>1;
        if(limit>=rsum){
            limit-=rsum;
            sum+=rsum;
            query(ch[u][0],l,mid);
        }
        else
            query(ch[u][1],mid+1,r);
    }
    void queryD(ll _limit,ll &_ans,ll &_sum){
        limit=_limit;
        ans=sum=0;
        query(rt,1,maxa);
        _ans=ans; _sum=sum;
    }
}
void readData(){
    n=getLong(); m=getLong();
    int useless;
    for(int i=1;i<=n;i++)
        useless=getLong();
}
void answerQuery(){
    int opt,l,r;
    ll a,ans=0,val;
    for(int i=1;i<=m;i++){
        opt=getLong(); l=getLong(); r=getLong(); a=getLong();
        SEG1::setCurrent(l,r);
        if(opt==0){
            a^=ans;
            SEG1::modify(SEG1::rt,1,maxa,a);
        }
        else{
            SEG1::queryD(a,ans,val);
            printf("%lld %lld\n",ans,val);
        }
    }
}
int main(){
    IO::load();
    readData();
    SEG1::build(SEG1::rt,1,maxa);
    answerQuery();
    return 0;
}
```

