---
layout: post
mathjax: true
title: 【BZOJ4940】这是我自己的发明
date: 2018-10-16 15:47:00
tag: [莫队,可做未做]
category: BZOJ
---
# Description

　　给一棵$n$个节点的有根树，初始时根为1号节点。此外，每个节点还有一个颜色$a$

　　要求你支持共$m$次下列两种操作：

1. 换根

2. 给出$u,v$，对于$u$的子树$S_u$和$v$的子树$S_v$，统计$\sum_{a\in S_u}\sum_{b\in S_v}[a_u==b_v]$

	$n \le 10^5,\ m \le 5*10^5$


<!-- more -->
# Solution

　　如果尝试在模拟的思路上优化，应该尽早停止，因为这样几乎是一个不可做形式：统计的过程形如两个向量的点积，无法快速搞定

　　首先，由于询问是子树的形式，很容易想到先将dfn序列拉出来，这样每个子树就是dfn序列上的一个区间

　　以下过程先不考虑换根操作

　　区间、离线、直接统计不可做，考虑到最后一个特征，我们想一下莫队

　　我们拿着两个区间在序列上移动，用两个数组分别记录每一个区间内每一种颜色的元素数量。某一个区间新加入一个元素时，在该区间的数组的相应位置上+1，并令当前总答案加上另一个区间的数组的该颜色的值；删除一个元素的做法同理。这样的依据，其实就是统计式的展开

　　现在，我们已经可以实现$O(1)$加减元素；想要回答某个询问，只需要把两个区间分别移到对应的两个子树区间即可。然而，我们带着两个区间在上面跑却不是莫队的形式，没有复杂度保证

　　假设我们要计算$A(l1,r1,l2,r2)=[l1,r1]\otimes[l2,r2]$。运用差分思想，我们可以将询问拆分成

$$
\begin{aligned}
A(l_1,r_1,l_2,r_2)&=A(1,r_1,1,r_2)-A(1,r_1,1,l_2-1)-A(1,l_1-1,1,r_2)+A(1,l_1-1,1,l_2-1)\\
&=B(r_1,r_2)-B(r_1,l_2-1)-B(l_1-1,r_2)+B(l_1-1,r_1-1)
\end{aligned}
$$

　　我们发现，$B(x,y)$的参数只有两个，代表着求$[1,x]\otimes [1,y]$的答案。虽然这玩意不是一个区间，但是有了上述$O(1)$加减元素的保证，我们也能套用莫队直接计算

　　这样我们就可以较快地离线回答每一个询问了

　　现在，加上换根操作，问题有什么变化？大致思想是完全一致的，只不过考虑上换根操作后，一个子树的区间在dfn序列上可能是全集挖掉一段，意味着回答某一个询问时，某一个人的参与运算的元素不一定只有一个区间，可能还有两个。我们只需要分类讨论，将一个询问运用差分思想拆分成多个询问即可，探究后可以发现，最坏情况下一个询问会被拆成9个区间，也就是总询问至多有450w个

　　事实告诉我们莫队**还是可以跑出来的**

　　。。。。。。



# Summary

　　离线、类区间、直接统计不可做$\rightarrow$上莫队

　　询问太复杂，使用差分可以用效率换来简单



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
namespace IO{
    const int LEN=10000000;
    char inBuf[LEN],outBuf[LEN];
    int inPos,outPos;
    void load(){
        fread(inBuf,1,LEN,stdin);
        inPos=0;
    }
    void flush(){
        fwrite(outBuf,1,outPos,stdout);
    }
    char getChar(){
        return inBuf[inPos++];
    }
    void writeChar(char c){
        outBuf[outPos++]=c;
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
    void writeInt(ll x,char endc='\n'){
        static int sta[20],top;
        if(!x)
            writeChar('0');
        else{
            for(top=0;x;x/=10) sta[++top]=x%10;
            for(;top;top--) writeChar('0'+sta[top]);
        }
        writeChar(endc);
    }
}
using IO::getInt;
using IO::writeInt;
const int N=100010,M=500010;
const int B=300;
int n,m;
int col[N];
int dcnt,d[N];
int h[N],tot;
struct Edge{
    int v,next;
}e[N*2];
int pre[N][17],dep[N];
int dfnTimer,dfn[N][2],dfnList[N];
int inputQueryCnt;
struct Query{
    int x,y;
    int id,co; // belong/coe
}q[M*10];
int qcnt;
ll ans[M];
void addEdge(int u,int v){
    e[++tot]=(Edge){v,h[u]}; h[u]=tot;
    e[++tot]=(Edge){u,h[v]}; h[v]=tot;
}
void readData(){
    n=getInt(); m=getInt();
    for(int i=1;i<=n;i++) col[i]=getInt();
    int u,v;
    for(int i=1;i<n;i++){
        u=getInt(); v=getInt();
        addEdge(u,v);
    }
}
void Diz(){
    for(int i=1;i<=n;i++) d[i]=col[i];
    sort(d+1,d+1+n);
    dcnt=unique(d+1,d+1+n)-d-1;
    for(int i=1;i<=n;i++)
        col[i]=lower_bound(d+1,d+1+dcnt,col[i])-d;
}
void preDfs(int u,int fa){
    pre[u][0]=fa;
    for(int i=1;i<=16;i++) pre[u][i]=pre[pre[u][i-1]][i-1];
    dep[u]=dep[fa]+1;
    dfn[u][0]=++dfnTimer;
    dfnList[dfnTimer]=u;
    for(int i=h[u],v;i;i=e[i].next)
        if((v=e[i].v)!=fa)
            preDfs(v,u);
    dfn[u][1]=dfnTimer;
}
int curRoot;
int getWhichSon(int anc,int u){
    for(int i=16;i>=0;i--)
        if(dep[pre[u][i]]>dep[anc])
            u=pre[u][i];
    return u;
}
void generate(int id,int co,int l1,int r1,int l2,int r2){
    if(l1>r1||l2>r2)
        return;
    q[++qcnt]=(Query){r1,r2,id,co};
    if(l1-1)
        q[++qcnt]=(Query){l1-1,r2,id,-co};
    if(l2-1)
        q[++qcnt]=(Query){r1,l2-1,id,-co};
    if(l1-1&&l2-1)
        q[++qcnt]=(Query){l1-1,l2-1,id,co};
}
int getType(int u){ // isRoot:0 inSubtree:1 out:2
    if(u==curRoot)
        return 0;
    else if(dfn[u][0]<dfn[curRoot][0]&&dfn[curRoot][0]<=dfn[u][1])
        return 1;
    return 2;
}
void takeApart(int id,int a,int b){
    int ta=getType(a),tb=getType(b);
    if(ta>tb){
        swap(a,b);
        swap(ta,tb);
    }
    int la,lb;
    if(ta==1)
        la=getWhichSon(a,curRoot);
    if(tb==1)
        lb=getWhichSon(b,curRoot);
    if(ta==0){
        if(tb==0)
            generate(id,1,1,n,1,n);
        else if(tb==1){
            generate(id,1,1,n,1,dfn[lb][0]-1);
            generate(id,1,1,n,dfn[lb][1]+1,n);
        }
        else
            generate(id,1,1,n,dfn[b][0],dfn[b][1]);
    }
    else if(ta==1){
        if(tb==1){
            generate(id,1,1,dfn[la][0]-1,1,dfn[lb][0]-1);
            generate(id,1,dfn[la][1]+1,n,1,dfn[lb][0]-1);
            generate(id,1,1,dfn[la][0]-1,dfn[lb][1]+1,n);
            generate(id,1,dfn[la][1]+1,n,dfn[lb][1]+1,n);
        }
        else{
            generate(id,1,1,n,dfn[b][0],dfn[b][1]);
            generate(id,-1,dfn[la][0],dfn[la][1],dfn[b][0],dfn[b][1]);
        }
    }
    else
        generate(id,1,dfn[a][0],dfn[a][1],dfn[b][0],dfn[b][1]);
}
void initQuery(){
    int opt,x,y;
    curRoot=1;
    for(int i=1;i<=m;i++){
        opt=getInt();
        if(opt==1)
            curRoot=getInt();
        else{
            inputQueryCnt++;
            x=getInt(); y=getInt();
            takeApart(inputQueryCnt,x,y);
        }
    }
}
ll curSum=0;
bool cmpMo(const Query &a,const Query &b){
    if(a.x/B!=b.x/B)
        return a.x/B<b.x/B;
    return a.y<b.y;
}
void add(int p,int x,int *a,int *b){
    int c=col[dfnList[p]];
    a[c]+=x;
    curSum+=1ll*x*b[c];
}
void MoQueue(){
    sort(q+1,q+1+qcnt,cmpMo);
    int l=0,r=0;
    static int ta[N],tb[N];
    for(int i=1;i<=qcnt;i++){
        while(l<q[i].x)
            add(++l,1,ta,tb);
        while(l>q[i].x)
            add(l--,-1,ta,tb);
        while(r<q[i].y) 
            add(++r,1,tb,ta);
        while(r>q[i].y)
            add(r--,-1,tb,ta);
        ans[q[i].id]+=1ll*q[i].co*curSum;
    }
}
void print(){
    for(int i=1;i<=inputQueryCnt;i++)
        writeInt(ans[i]);
}
int main(){
    IO::load();
    readData();
    Diz();
    preDfs(1,0);
    initQuery();
    MoQueue();
    print();
    IO::flush();
    return 0;
}
```

 