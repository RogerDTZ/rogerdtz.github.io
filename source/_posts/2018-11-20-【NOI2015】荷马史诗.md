---
layout: post
mathjax: true
title: 【NOI2015】荷马史诗
date: 2018-11-20 08:45:00
tag: [适应,哈夫曼编码]
category: NOI
---
# Description

　　给定$n$个单词的长度及其出现次数，求构造$k$叉哈夫曼树后的最小代价

　　$n \le 10^5,\ 2 \le k \le 9$


<!-- more -->
# Solution

　　$k=2$即经典Huffman编码问题

　　当$k>2$时，我们发现原算法并不总是最优的：按权值优先、深度其次的方法合并子树时，如果当前新建节点接上的子树数量不足$k$个，我们完全可以将底下的某一些子树移接到闲置的儿子处，以减小代价

　　经过一些观察，我们发现：如果原来的$n$个点构成了完全$k$叉树的所有叶子（即当$n-1 \mod k-1=0$，每次合并减少$k-1$个子树，最后剩下1个子树），合并时完全不会出现这种情况。因为每次合并时，新建的节点总会连接上恰好$k$个子树，再根据算法的贪心，应该被移上来的子树会被相应地处理

　　因此，我们可以添加若干个出现次数为0的单词，直到满足上述条件为止。此时原生哈夫曼树算法即可适应$k$阶的拓展情况



# Code

```c++
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long LL;
int n,m;
struct Data{
    LL val;
    int dep;
    friend bool operator < (const Data &a,const Data &b){
        if(a.val!=b.val) 
            return a.val>b.val;
        return a.dep>b.dep;
    }
};
priority_queue<Data> q;
void readData(){
    scanf("%d%d",&n,&m);
    Data t;
    for(int i=1;i<=n;i++){
        scanf("%lld",&t.val);
        t.dep=1;
        q.push(t);
    }
    while((n-1)%(m-1)!=0){
        n++;
        q.push((Data){0,1});
    }
}
void solve(){
    LL ans=0;
    Data u,v;
    while(q.size()>1){
        u.val=0;
        u.dep=0;
        for(int i=0;i<m&&!q.empty();i++){
            v=q.top();
            q.pop();
            u.val+=v.val;
            u.dep=max(u.dep,v.dep+1);
        }
        q.push(u);
        ans+=u.val;
    }
    printf("%lld\n%d",ans,u.dep-1);
}
int main(){
    readData();
    solve();
    return 0;
}
```

