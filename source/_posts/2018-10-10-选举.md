---
layout: post
mathjax: true
title: 选举
date: 2018-10-10 16:12:00
tag: [DP,单调队列]
---
# Description

　　有一个长度为$n$的序列，权值为-1或1或0

　　给定$l$和$r$，你将要将序列划分成任意多段长度在$[l,r]$中的区间，使得所有区间的权值之和最大

　　定义一个区间的权值为：记该区间元素之和为$s$，若$s>0$则为1，若$s<0$则为-1，否则为0

　　$1 \le n \le 10^6$


<!-- more -->
# Solution

　　听说一个log可以过而且不卡常。场上我一看100w特别虚，硬是把自己逼出了$O(n)$的做法......

　　求出原序列的前缀和$s$后，就可以快速回答任意一段区间$(l,r]$的权值$v(l,r)$

　　考虑朴素DP：设$f_i$表示划分序列的前$i$位，以$i$为最后一个区间的结尾时，各区间权值之和最大值是多少

$$
f_i=\max\{f_{i-j}+v(i-j,i)\mid j\in[l,r]\}
$$

　　至此已经可以给出$O(n \log n)$的算法：我们使用一个以$s$为下标、以$f$值为权值的线段树，记录$j \in[i-r,i-l]$这些位置的$s_j$和$f_j$。对于$s_j<s_i$的$f$，它们在贡献时加一；对于$s_j>s_i$的$f$，它们在贡献时减一。因此维护区间最大值就可以加速取$\max$的过程。由于考虑范围是一个滑动窗口，因此我们可以很方便地维护这棵线段树

　　考虑如何进一步优化

　　我们称$[i-r,i-l]$为“考虑范围”。如果忽略$v$的存在，那么这题就是一个基本的滑动窗口，用单调队列维护区间最大值。我们使用一个最基本的单调队列维护考虑范围中的$f$最大值

　　考虑到$v$的取值范围为$[-1,1]$，此时我们观察$f_i$的最终取值，记考虑范围中的$f$最大值为$f_{max}$，则$f_i$一定由下面两类位置的某一个最大值得来：

1. $f=f_{max}$的位置
2. $f=f_{max}-1$的位置

　　这些位置转移时还要考虑上$v$的影响。贪心地想，两类位置肯定都尽可能地想加一，去获得最大值。由于加一的条件是$s_j<s_i$，且$v$满足$s$越小价值越高，我们对于两类位置分别维护的$s$的最小值，就可以知道每一类的位置考虑上$v$后最大的能去多少。转移时，取两类位置的最优者即可

　　于是我们相当于要对每一个$x$，维护那些满足$f_i=x$的位置$i$的$s_i$，并支持查询区间最小值。这个查询也是一个滑动窗口的形式，我们开$2n+1$个单调队列（$[-n,n]$），直接跟随主单调队列滑动并维护即可，每次滑动，弹出的元素都只有一个，总空间复杂度和时间复杂度都是$O(n)$（我写了个链表模拟队列）



# Code

```c++
#include <cstdio>
#include <utility>
#define mp make_pair
#define FR first
#define SE second
using namespace std;
typedef pair<int,int> pii;
namespace IO{
    const int S=10000000;
    char buf[S];
    int pos;
    void load(){
        fread(buf,1,S,stdin);
        pos=0;
    }
    char getChar(){
        return buf[pos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
const int N=1000010;
const int INF=1e9;
int n,l,r;
int s[N];
int f[N];
inline int max(int x,int y){
    return x>y?x:y;
}
void readData(){
    n=getInt(); l=getInt(); r=getInt();
    for(int i=1;i<=n;i++){
        s[i]=getInt();
        s[i]+=s[i-1];
    }
}
struct Node{
    pii d;
    int pre,nex;
}d[N*2];
int use=0;
struct Queue{
    bool flag;
    int size;
    int h,t; 
    void setup(bool ismax){
        flag=ismax;
        size=0;
        h=0;
    }
    void pop_back(){
        size--;
        int pn=d[t].pre;
        if(pn){
            d[pn].nex=0;
            t=pn;
        }
        else h=t=0;
    }
    void pop_front(){
        size--;
        int nn=d[h].nex;
        if(nn){
            d[nn].pre=0;
            h=nn;
        }
        else h=t=0;
    }
    void push_back(pii s){
        d[++use]=(Node){s,0,0};
        if(size){
            d[t].nex=use;
            d[use].pre=t;
        }
        else
            h=use;
        t=use;
        size++;
    }
    inline bool cmp(int vl,int vr){
        return flag?(vl>vr):(vl<vr);
    }
    void push(int p,int v){
        while(size&&!cmp(d[t].d.SE,v))
            pop_back();
        push_back(mp(p,v));
    }
    void pop(int curhead){
        while(size&&d[h].d.FR<curhead)
            pop_front();
    }
    int getHead(){
        if(size)
            return d[h].d.SE;
        else
            return flag?-INF:INF;
    }
}q,b[N*2]; // b (+n)
void init(){
    q.setup(true);
    for(int i=0;i<=2*n;i++)
        b[i].setup(false);
}
inline int calc(int curs,int tars){
    if(curs>tars)
        return 1;
    else if(curs<tars)
        return -1;
    return 0;
}
void insert(int p){
    if(f[p]!=-INF){
        q.push(p,f[p]);
        b[n+f[p]].push(p,s[p]);
    }
}
void pop(int cur){
    int left=max(0,cur-r);
    q.pop(left);
    if(f[left-1]!=-INF){
        b[n+f[left-1]].pop(left);
    }
}
void dp(){
    for(int i=0;i<=n;i++) f[i]=-INF;
    f[0]=0;
    for(int i=l;i<=n;i++){
        insert(i-l);
        pop(i);
        int maxf=q.getHead();
        if(maxf==-INF)
            continue;
        f[i]=maxf+calc(s[i],b[n+maxf].getHead());
        int secf_s=b[n+(maxf-1)].getHead();
        if(secf_s!=INF)
            f[i]=max(f[i],(maxf-1)+calc(s[i],secf_s));
    }
    if(f[n]==-INF)
        puts("Impossible");
    else
        printf("%d\n",f[n]);
}
int main(){
    IO::load();
    readData();
    init();
    dp();
    return 0;
}
```

