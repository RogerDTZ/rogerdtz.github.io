---
layout: post
mathjax: true
title: 几何
date: 2018-10-07 19:29:00
tag: [数论---组合数学,分治,FFT]
---
# Description

　　有$n$个正四面体，标号为$1...n$

　　其中，第$i$个四面体的每条边都由$i$根长度为1的木棒首尾相接构成

　　要摧毁第$i$个四面体，你需要断掉一些边，断边必须满足下列两个条件：

1. 断边后，每个顶点连接的边不能少于2条
2. 断掉的边的数量不小于$i$

　　如果要达成目的，你需要摧毁至少$k$个四面体。注意，如果你的计划不摧毁某一个四面体，你不能动它的任意一条边

　　忽略断边顺序，问有多少种断边方案可以达成目的？

　　$ k \le n \le 60000$


<!-- more -->
# Solution

　　假设我们知道摧毁第$n$个四面体的方案$d_n$，后面的问题显然是一个DP：设$f_{i,j}$表示前$i$个四面体中，已摧毁$j$个的方案数，显然有转移：

$$
f_{i,j}=f_{i-1,j}+f_{i-1,j-1}*d_i
$$

　　完事后直接统计$\sum_{i=k}^nf_{n,i}$就是答案

　　考虑到这是一个整体偏移、乘上一个系数再加回原数组的DP，我们第一反应想到用生成函数解决

$$
f_{n,j}=(\prod_{i=1}^n(d_ix+1))[x^j]
$$

　　又看到$n$相对于10w而言较小，我们直接上两个log的FFT就可以完成后面的DP

　　关键是如何求出$d_n$

　　手算得出$d_1$等于9。接下来考虑$n>1$的情况

　　将与四个角相连的12条边单独拉出来考虑，然后再考虑从剩余的边中选多少以补齐满足“至少$n$条"的要求

　　考虑到每个角要么断1条，要么不断，我们可以枚举总共断$a$条边，然后计算出四个角的方案组合；断掉$a$条边之后，未考虑的边还有$6n-12$条，要从中至少选$n-a$条边断掉，则可以列出式子：

$$
d_n=\sum_{a=0}^4{4 \choose a}3^aS(6n-12,n-a)\\
S(n,m)=\sum_{i=m}^n{n \choose i}
$$

　　问题转向如何快速求得$S(n,m)$。这玩意是组合数某一行的后缀和

　　使用直接计算化简的方法貌似行不通；由于想起了之前做另一道题时的思路：连续一段$n$相同的组合数可以快速整体向下转移，考虑直接维护$S(6n-12,n)$；其余情况当$a>0$时，只需要从$S(6n-12,n)$中$O(1)$加上一些组合数即可

　　我们有$S(n,m)*2+{n \choose m-1}=S(n+1,m)$

　　因此，当手上拿着$S(6n-12,n)$时，用上述式子做6次可以得到$S(6(n+1)-12,n)$，再减去一个${6(n+1)-12 \choose n}$就可以得到$S(6(n+1)-12,n+1)$，也就是计算$n+1$时所需要的数组

　　由此我们可以在$O(n)$的时间递推$S$，并一同计算出$d$

　　然后就做完了

　　注意FFT预处理根的幂



# Code

```c++
#include <cstdio>
#include <vector>
#include <cmath>
#define pb push_back
using namespace std;
typedef long long ll;
typedef vector<int> vi;
const int N=60010;
const int MOD=1e5+3;
const int UP=300010;
const double PI=acos(-1.0);
int fact[UP],iact[UP];
int d[N];
int fmi(int x,int y){
    int res=1;
    for(;y;x=1ll*x*x%MOD,y>>=1)
        if(y&1)
            res=1ll*res*x%MOD;
    return res;
}
void init(){
    fact[0]=fact[1]=1;
    for(int i=2;i<MOD;i++) fact[i]=1ll*fact[i-1]*i%MOD;
    iact[0]=iact[1]=1;
    iact[MOD-1]=fmi(fact[MOD-1],MOD-2);
    for(int i=MOD-2;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
}
int C(int n,int m){
    if(n<m)
        return 0;
    if(n<MOD&&m<MOD)
        return m<=n?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;
    return 1ll*C(n/MOD,m/MOD)*C(n%MOD,m%MOD)%MOD;
}
void calcD(){
    int n=60000;
    d[1]=9;
    int s=0;
    const static int pow3[5]={1,3,9,27,81};
    for(int i=2;i<=n;i++){
        int cur=s;
        for(int j=0;j<=4;j++){
            (d[i]+=1ll*C(4,j)*pow3[j]%MOD*cur%MOD)%=MOD;
            if(j<4){
                if(i-(j+1)>=0)
                    (cur+=C(6*i-12,i-(j+1)))%=MOD;
            }
        }
        if(i<n){
            for(int j=0;j<6;j++)
                s=(2ll*s+C(6*i-12+j,i-1))%MOD;
            (s-=C(6*(i+1)-12,i))%=MOD;
        }
    }
}
struct Comp{
    double x,y;
    Comp(){}
    Comp(double _x,double _y):x(_x),y(_y){}
    friend Comp operator + (const Comp a,const Comp b){
        return Comp(a.x+b.x,a.y+b.y);
    }
    friend Comp operator - (const Comp a,const Comp b){
        return Comp(a.x-b.x,a.y-b.y);
    }
    friend Comp operator * (const Comp a,const Comp b){
        return Comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
    }
};
namespace FFT{
    const int S=200010;
    int n,bit;
    int rev[S];
    Comp W[17][S];
    void build(){
        for(int i=2,j=1;j<17;i<<=1,j++)
            for(int k=0;k<(i>>1);k++)
                W[j][k]=Comp(cos(k*PI/(i>>1)),sin(k*PI/(i>>1)));
    }
    void init(int _n){
        for(n=1,bit=0;n<_n;n<<=1,bit++);
        for(int i=0;i<n;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
    }
    void fft(Comp *a,int f){
        for(int i=0;i<n;i++)
            if(i<rev[i])
                swap(a[i],a[rev[i]]);
        Comp u,v,w;
        for(int i=2,ni=1;i<=n;i<<=1,ni++){
            for(int j=0;j<n;j+=i){
                for(int k=0;k<(i>>1);k++){
                    w=W[ni][k];
                    if(f)
                        w.y*=-1;
                    u=a[j+k];
                    v=w*a[j+(i>>1)+k];
                    a[j+k]=u+v;
                    a[j+(i>>1)+k]=u-v;
                }
            }
        }
        if(f)
            for(int i=0;i<n;i++) 
                a[i].x/=n;
    }
}
vi divide(int l,int r){
    if(l==r){
        vi res(2);
        res[0]=1;
        res[1]=d[l];
        return res;
    }
    int mid=(l+r)>>1;
    vi lf=divide(l,mid);
    vi rf=divide(mid+1,r);
    static Comp ta[FFT::S],tb[FFT::S];
    FFT::init((r-l+1)+1);
    for(int i=0;i<=mid-l+1;i++) ta[i]=Comp(lf[i],0);
    for(int i=0;i<=r-mid;i++) tb[i]=Comp(rf[i],0);
    for(int i=mid-l+2;i<FFT::n;i++) ta[i]=Comp(0,0);
    for(int i=r-mid+1;i<FFT::n;i++) tb[i]=Comp(0,0);
    FFT::fft(ta,0);
    FFT::fft(tb,0);
    for(int i=0;i<FFT::n;i++) ta[i]=ta[i]*tb[i];
    FFT::fft(ta,1);
    vi res((r-l+1)+1);
    for(int i=0;i<=r-l+1;i++)
        res[i]=llround(ta[i].x)%MOD;
    return res;
}
int solve(int n,int k){
    vi poly=divide(1,n);
    int res=0;
    for(int i=k;i<=n;i++)
        (res+=poly[i])%=MOD;
    return res<0?res+MOD:res;
}
void answerQuery(){
    int q,x,y;
    scanf("%d",&q);
    for(int i=1;i<=q;i++){
        scanf("%d%d",&x,&y);
        printf("%d\n",solve(x,y));
    }
}
int main(){
    init();
    calcD();
    FFT::build();
    answerQuery();
    return 0;
}
```

