---
title: 灯
mathjax: true
date: 2019-03-15 19:25:22
tags: [分块,可做未做]
---

# Description

有$n$盏灯排成一排，每一盏灯有一个$[1,m]$的颜色

初始时，所有灯都是灭的。接下来有$q$次操作，每次操作会改变某一种灯的颜色。你需要在每次操作之后，回答有多少个极长的开着的灯的连续段

$n,m \le 10^5$

<!-- more -->

# Solution

连续段数=亮着的灯数-有多少对相邻的灯都是亮着的（简称双亮）

前者很好维护，但后者是$\log​$不可处理的问题，bitset也不好优化，所以我们转向分块

将所有颜色按照其出现次数是否超过$\sqrt n$分成两组：

* 出现次数$\le \sqrt n$（称作“小颜色”）：我们可以直接暴力维护与它相关的双亮个数
* 出现次数$> \sqrt n$（称作“大颜色”）：由于大颜色不会有超过$\sqrt n$个，我们可以分别预处理出它们两两产生的双亮个数有多少。在某个大颜色发生状态更改时，$O(\sqrt n)$枚举其他亮着的大颜色计算涉及对数即可；我们还未考虑该大颜色与其余小颜色产生的双亮，这点可以在小颜色暴力更新时计算对相邻大颜色的贡献，大颜色需要统计时加上这个额外的贡献即可

时间复杂度$O(n \sqrt n)​$

# Summary

有一些问题用$\log$算法是不能解决的，不要在上面死磕几个小时，应转向其他优化暴力做法，如bitset和分块

自己的分块思想还是过于薄弱

分块不仅仅局限于线性分块。区间询问的问题固然可以使用区间分块，但用在其他某些问题上就完全不着边

可以直接对于**元素或集合本身**按**考虑代价**进行分块，在代价小时暴力更新，顺带维护一些算法需要维护的东西；在代价大时，可以对代价大的元素$O(\sqrt n^2)=O(n)$两两考虑，等等

# Code

```c++
#include <cstdio>
#include <vector>
using std::vector;
const int N=100000+10;
const int M=100000+10;
const int B=316;
int n,m,q;
int c[N];
vector<int> p[M];
int self[M];
int id[M],idCnt,a[N/B+10];
int mat[N/B+10][N/B+10];
void ReadData(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
}
void Init(){
	for(int i=1;i<=n;i++)
		p[c[i]].push_back(i);
	for(int i=1;i<=m;i++)
		for(int j=0;j<int(p[i].size())-1;j++)
			self[i]+=(p[i][j]+1==p[i][j+1]);
	for(int i=1;i<=m;i++)
		if(p[i].size()>B){
			idCnt++;
			id[i]=idCnt;
			a[idCnt]=i;
		}
	for(int i=1;i<=idCnt;i++){
		mat[i][i]=self[a[i]];
		static bool in[N];
		for(int k=0;k<int(p[a[i]].size());k++) in[p[a[i]][k]]=true;
		for(int j=i+1;j<=idCnt;j++){
			int edge=0;
			for(int k=0;k<int(p[a[j]].size());k++) edge+=in[p[a[j]][k]-1]+in[p[a[j]][k]+1];
			mat[i][j]=mat[j][i]=edge;
		}
		for(int k=0;k<int(p[a[i]].size());k++) in[p[a[i]][k]]=false;
	}
}
void AnswerQuery(){
	static bool on[M];
	static int extra[B+10];
	int node=0,edge=0;
	for(int i=1;i<=q;i++){
		int x;
		scanf("%d",&x);
		if(id[x]==0){
			if(!on[x]){
				for(int j=0;j<int(p[x].size());j++){
					int u=p[x][j];
					edge+=on[c[u-1]]+on[c[u+1]];
					if(id[c[u-1]])
						extra[id[c[u-1]]]++;
					if(id[c[u+1]])
						extra[id[c[u+1]]]++;
				}
				on[x]=true;
				edge+=self[x];
				node+=p[x].size();
			}else{
				on[x]=false;
				for(int j=0;j<int(p[x].size());j++){
					int u=p[x][j];
					edge-=on[c[u-1]]+on[c[u+1]];
					if(id[c[u-1]])
						extra[id[c[u-1]]]--;
					if(id[c[u+1]])
						extra[id[c[u+1]]]--;
				}
				edge-=self[x];
				node-=p[x].size();
			}
		}else{
			if(!on[x]){
				on[x]=true;
				for(int j=1;j<=idCnt;j++)
					if(on[a[j]])
						edge+=mat[id[x]][j];
				edge+=extra[id[x]];
				node+=p[x].size();
			}else{
				for(int j=1;j<=idCnt;j++)
					if(on[a[j]])
						edge-=mat[id[x]][j];
				edge-=extra[id[x]];
				node-=p[x].size();
				on[x]=false;
			}
		}
		printf("%d\n",node-edge);
	}
}
int main(){
	ReadData();
	Init();
	AnswerQuery();
	return 0;
}
```
