---
title: 游戏
mathjax: true
date: 2019-04-09 19:23:19
tags: [二分图匹配]
---

# Description

有一个长度为$n$的数组$a_i$，还有一个长度为$m$的数组$b_i$

这两个数组各自有一个指针$c$和$d$，初始时$c=d=1$

有两个人A和B轮流进行操作，A先手。当前操作的玩家有两种操作可供选择：

* 将指针$c$和$d$分别移动到$c'$和$d'$，但$(c',d')$这个状态不能在之前出现过，即不能走到相同的状态
* 立即结束游戏，游戏的得分为$a_c+b_d$

A想要最小化得分，而B想要最大化得分。在两人都采取最优策略的前提下，这一得分会是多少？

$n,m \le 10^5​$

<!-- more -->

# Solution

考虑二分答案，判断终止格子是否能$\le x$；若终止格子$\le x$则先手胜，否则后手胜

不妨将状态$(c,d)$看做二维网格上的一个格子，每个格子$(x,y)$的权值为$a_x+b_y$（$a$从上到下，$b$从左到右）

将权值$\le x$的格子染成白色，权值$>x$的格子染成黑色

显然，若初始格子为白色，先手直接终止游戏就可以胜利。下面只讨论初始格子为黑色的情况

当前操作的人必须移动到同行或同列的、尚未经过的异色格子（A去白，B去黑），因为当前所在格子是对手的胜利点，异色是自己的胜利点，自己必须离开并走到有利于自己的颜色，否则下一步对手会直接终止游戏

考虑将白格和黑格的关系建成二分图，同行或同列的异色格子连一条边

有一个结论是：先手必胜，当且仅当该二分图的所有最大匹配都包含初始格子

所有最大匹配都包含某个点$s$，等价于不存在一个最大独立集，满足它不包含$s$。这点只需要用原图的最大独立集大小与删去$s$后的最大独立集大小作比较即可

考虑如何求这个二分图的最大独立集

回到网格层面，我们不妨将$a$和$b$按权值从小到大排序，那么黑格子显然是右下角一块，白格子则是左上角一块

考虑某一行，最大独立集要么选择其中的某些白格，要么选择某些黑格（不能都选）；选中的格子相应的列也会被限定成只能选这种颜色，该列选中的格子相应的行也会被限定......如此连锁扩展

最优决策一定是在网格上选定一个某个分界点$(x,y)​$，然后选择该点左上角的所有白格和右下角的所有黑格

不妨枚举$x$，考虑$y$取到哪里，维护选中的格子总数。初始时$y$取$m$，选满左上角的所有白格。每当$y$向左移动一格，有一列白格会被减去，还有一列黑格会被加上。设这列的白色格子数为$w$，则总数的变化值就是​
$$
\begin{aligned}
&\min(n-w,n-x)-\min(w,x) \\
=&n-(w+x)
\end{aligned}
$$
$w$向左单增，显然$y$应该一直向左移动，直到这个变化值$<0$。因为$x$也是从小到大枚举的，所以$y$的取值非常好维护

得到$y$后，统计一下选中的格子数就可以了，每次大概是求区间的$w$和某个值$k$的$\max$或$\min$的和

如果要考虑去除掉某个格子的最大独立集，只需要在统计时特判并减一即可

时间复杂度$O(n \log n \log ans)$

# Code

```c++
#include <cstdio>
#include <algorithm>
using std::min;
using std::max;
using std::sort;
typedef long long LL;
const int N=100000+10;
int n,m;
int a[N],b[N];
int px,py;
int w[N];
LL prew[N];
void ReadData(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) scanf("%d",&b[i]);
	int ax=a[1],bx=b[1];
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);
	for(int i=1;i<=n;i++)
		if(a[i]==ax){
			px=i;
			break;
		}
	for(int j=1;j<=m;j++)
		if(b[j]==bx){
			py=j;
			break;
		}
}
LL MinSum(int l0,int r0,int x){
	if(l0>r0)
		return 0;
	int l=l0,r=r0,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(w[mid]<=x)
			r=mid-1;
		else
			l=mid+1;
	}
	return 1ll*x*(l-l0)+prew[r0]-prew[l-1];
}
LL MaxSum(int l0,int r0,int x){
	if(l0>r0)
		return 0;
	int l=l0,r=r0,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(w[mid]>=x)
			l=mid+1;
		else
			r=mid-1;
	}
	return prew[r]-prew[l0-1]+1ll*x*(r0-r);
}
bool Judge(int x){
	w[0]=n;
	for(int j=1;j<=m;j++){
		for(w[j]=w[j-1];w[j]>=1&&a[w[j]]+b[j]>x;w[j]--);
		prew[j]=prew[j-1]+w[j];
	}
	if(px<=w[py])
		return true;
	LL area1=max(prew[m],1ll*n*m-prew[m]),area2=max(prew[m],1ll*n*m-prew[m]-1);
	for(int i=1,j=1;i<=n;i++){
		for(;j<m&&w[j+1]>=n-i;j++);
		LL cur=MinSum(1,j,i)+1ll*n*(m-j)-MaxSum(j+1,m,i);
		area1=max(area1,cur);
	}
	for(int i=1,j=1;i<=n;i++){
		for(;j<m&&w[j+1]>=n-i;j++);
		LL cur=MinSum(1,j,i)+1ll*n*(m-j)-MaxSum(j+1,m,i);
		if((px<=i&&py<=j&&px<=min(i,w[py]))||(px>i&&py>j&&px>=max(i+1,w[py]+1)))
			cur--;
		area2=max(area2,cur);
	}
	return 1ll*n*m-area1!=1ll*n*m-1-area2;
}
void Solve(){
	int l=1,r=2e8,mid;
	while(l<=r){
		mid=(l+r)>>1;
		if(Judge(mid))
			r=mid-1;
		else
			l=mid+1;
	}
	printf("%d\n",l);
}
int main(){
	ReadData();
	Solve();
	return 0;
}
```

