---
layout: post
mathjax: true
title: 跑步
date: 2018-12-17 10:40:00
tag: [DP---动态DP]
---
# Description

　　有一张$n\times n$的网格，每个格子上有一个数字$a_{i,j}$。左上角为$(1,1)$，右下角为$(n,n)$

　　定义一个格子$(i,j)$的贡献为：从$(i,j)$向左或向上到达$(1,1)$的所有路径中经过格子数字之和的最大值

　　一共有$n$次修改，每次修改会将一个格子的值加一或减一。你需要在一开始和每一次修改之后，回答所有格子的贡献之和

　　$n \le 2000$



　　
<!-- more -->
# Solution

　　先把朴素的DP搞出来：设$f_{i,j}$为$(i,j)$的贡献，则有转移

$$
f_{i,j}=\max\{f_{i-1,j},f_{i,j-1}\}+a_{i,j}
$$

　　决策点在于$\max$是取上方还是左方的值

　　注意到修改十分特殊：变化连续，这意味可能存在一些机会处理决策点的切换

　　我们先考虑修改$(i,j)$后影响到了哪一些格子

　　对于第$i$行，影响的格子显然是一段区间，其左端点为$j$，右端点我们可以暴力扫出来。判断一个格子是否被影响的依据是：其选择有变，或者原选择被影响，直接查询$f$值即可

　　考虑第$(i+1)$行，影响的格子仍然是一段区间——若中间有断开，考虑一个断层中“未被影响”的最左方的格子，其左方也被影响、上边也被影响，自己不可能不被影响；一路顺推，可知这些断层都会被影响。这个区间的左端点相对于上一个区间不可能更左，右端点相对于上一个区间也不可能更左，我们暴力右移这两个端点即可

　　对于接下来的每一行，我们都暴力右移端点，显然总移动次数是$O(n)$的

　　至此，我们可以得到被影响的格子总数（即每一行区间长度之和）。显然，影响到的格子数量乘上修改值，就是全局答案的变化量，直接维护答案即可。对于每一个被影响的格子，我们将其$f$加上修改值，使用$n$个树状数组维护每一行的$f$即可

　　时间复杂度为$O(n^2 \log n)$

　　事实上，我们还有更优的做法：原来判定一个格子$(i,j)$的选择时，我们需要比较$f_{i-1,j}$和$f_{i,j-1}$的大小关系。现在，我们直接维护一个差分$g_{i,j}=f_{i-1,j}-f_{i,j-1}$，并以其正负表示选择。原来将一行的一段区间的$f$全部加上修改值，现在我们只需要维护区间两段的$g$。细节较多，时间复杂度降为$O(n^2)$

　　

# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
namespace IO{
    const int L=50000000;
    char inBuf[L],outBuf[L];
    int inPos,outPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    void flush(){
        fwrite(outBuf,1,outPos,stdout);
    }
    char getChar(){
        return inBuf[inPos++];
    }
    char getCmd(){
        char c=getChar();
        for(;c!='U'&&c!='D';c=getChar());
        return c;
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        for(;c<'0'||c>'9';c=getChar()){if(c=='-')f=-1;}
        for(;'0'<=c&&c<='9';c=getChar()){x=x*10+c-'0';}
        return x*f;
    }
    void writeChar(char c){
        outBuf[outPos++]=c;
    }
    void writeInt(LL x,char end='\n'){
        if(!x)
            writeChar('0');
        else{
            static int digit[20],cnt;
            for(cnt=0;x;x/=10) digit[++cnt]=x%10;
            for(;cnt;cnt--) writeChar('0'+digit[cnt]);
        }
        writeChar(end);
    }
}
using IO::getInt;
using IO::getCmd;
using IO::writeInt;
const int INF=1e9;
const int N=2010;
int n;
int a[N][N];
void readData(){
    n=getInt(); 
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            a[i][j]=getInt();
}
int f[N][N],g[N][N];
LL ans;
void init(){
    for(int i=2;i<=n;i++)
        f[0][i]=f[i][0]=-INF;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            f[i][j]=max(f[i][j-1],f[i-1][j])+a[i][j];
            g[i][j]=f[i-1][j]-f[i][j-1];
            ans+=f[i][j];
        }
}
void modify(int x,int y,int sgn){
    int involve=0;
    int l=y,r=y;
    for(int j=y+1;j<=n;j++){
        g[x][j]-=sgn;
        if(g[x][j]+sgn<0||(g[x][j]+sgn==0&&sgn==1))
            r=j;
        else
            break;
    }
    involve=r-l+1;
    for(int i=x+1;i<=n;i++){
        while(l<=r){
            g[i][l]+=sgn;
            if(g[i][l]-sgn<0||(g[i][l]-sgn==0&&sgn==-1))
                l++;
            else
                break;
        }
        if(l>r)
            break;
        while(r<n){
            g[i][r+1]-=sgn;
            if(g[i][r+1]+sgn<0||(g[i][r+1]+sgn==0&&sgn==1))
                r++;
            else
                break;
        }
        involve+=r-l+1;
    }
    ans+=sgn*involve;
}
void answerQuery(){
    writeInt(ans);
    char cmd;
    int x,y;
    for(int i=1;i<=n;i++){
        cmd=getCmd();
        x=getInt(); y=getInt();
        modify(x,y,(cmd=='U')?+1:-1);
        writeInt(ans);
    }
}
int main(){
    IO::load();
    readData();
    init();
    answerQuery();
    IO::flush();
    return 0;
}
```

