---
title: Paths
mathjax: true
date: 2019-06-25 16:37:47
tags: [枚举]
---

# Description

给定一张$n$个点$m$条边的简单无向图，求不经过重复点的、恰好经过$5$个点的有向路径条数

$n,m \le 10^5$

<!-- more -->

# Solution

假设我们能求出$a_x,b_x$分别表示$x$所在的本质不同的三元环和四元环的个数

使用自增标记$c$和相邻增标记$d$，我们可以对每一个点算出从它出发的、每相邻三个点互不相同的路径的条数。只需枚举第3个点，然后修改其所有相邻点的增标记即可

接下来从每个点$x$的答案中减去从它出发不合法的情况

1. 走四元环：$2a_x$
2. 走三元环回到$x$后，再走一条与上一条边不一样的边：$2b_x(deg_x-1)$
3. 走一条边$e$到$e_y$，然后走一个三元环，这个三元环不能包含$x$：$\sum_{e} 2(a_{e_y}-cnt_e) $，其中$cnt_e$是$e$这条边所在的本质不同的三元环个数

问题是如何求$a$（和$cnt$）和$b$？

这里有一种巧妙的枚举方法

我们按所有点的度数从大到小确定一个枚举顺序，然后从前往后考虑

设当前在考虑$x$

我们暴力扫出$x$的所有相邻点中枚举顺序在$x$之后的节点，称它们为第一层节点，它们与$x$的距离为1

暴力对第一层节点中的每个点扫出与它相邻的、不是$x$且不属于第一层节点的所有节点，称它们为第二层节点，它们与$x$的距离为2

要统计三元环，只需要枚举第一层中的每个点，然后枚举其出边，如果出边到达了第一层节点，那么就找到了一个三元环，更新三个顶点的$a$和三条边的$cnt$

要统计四元环，有两种情况：

* 由$x$、两个第一层节点、一个第二层节点组成：枚举第二层节点，统计其与多少第一层节点相邻，更新四元环经过节点的$b$
* 由$x$、三个第一层节点：枚举$x$对面的节点，然后统计它与多少第一层节点相邻，更新四元环经过节点的$b$

即我们会在每个三/四元环的顺序最靠前的那个节点处完成统计和更新操作

考虑这样做的复杂度

每次扫描第一层节点的复杂度是$O(deg_x)$

由于第一层节点的度数都不超过$deg_x$，因此扫描第二层节点的复杂度是$O(\min(deg_x^2,m))$

由于$\min(deg_x^2,m) \le \deg_x \sqrt m$，因此单看扫描点这一步，总的复杂度不超过$m \sqrt m$

计算三元环时枚举出边的复杂度同上

计算四元环时，如果我们只枚举第一层扩展到第二层使用的边，这样复杂度也同上

因此总复杂度是$m \sqrt m$

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <unordered_map>

using std::sort;
using std::unordered_map;

typedef long long LL;

const int N=100000+10;
const int M=100000+10;

int n,m;

namespace Graph{
	const int N=(::N);
	const int M=(::M);
	int h[N],tot;
	struct Edge{
		int v,next;
	}e[M*2];
	int d[N];
	int lis[N],pos[N];
	LL r3[N],r4[N];
	LL addSelf[N],addSide[N];
	unordered_map<int,unordered_map<int,int> > er3;
	void AddEdge(int u,int v){
		e[++tot]=(Edge){v,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,h[v]}; h[v]=tot;
		d[u]++; d[v]++;
	}
	bool CmpD(const int &x,const int &y){
		return d[x]>d[y];
	}
	void Calc(int u){/*{{{*/
		static int a[N],acnt,acnt1;
		static int dis[N];
		acnt=0;
		for(int i=h[u],v;i;i=e[i].next)
			if(pos[u]<pos[v=e[i].v]){
				a[++acnt]=v;
				dis[v]=1;
			}
		acnt1=acnt;
		for(int p=1;p<=acnt1;p++){
			int v=a[p];
			for(int i=h[v],w;i;i=e[i].next)
				if(pos[u]<pos[w=e[i].v]&&dis[w]==0){
					a[++acnt]=w;
					dis[w]=2;
				}
		}
		for(int p=1;p<=acnt1;p++){
			int v=a[p];
			for(int i=h[v],w;i;i=e[i].next)
				if(dis[w=e[i].v]==1&&v<w){
					r3[u]++; r3[v]++; r3[w]++;
					er3[u][v]++; er3[v][u]++;
					er3[v][w]++; er3[w][v]++;
					er3[u][w]++; er3[w][u]++;
				}
		}
		for(int p=1;p<=acnt1;p++){
			int v=a[p];
			int cnt=0;
			for(int i=h[v],w;i;i=e[i].next)
				if(dis[w=e[i].v]==1)
					cnt++;
			r4[u]+=1ll*cnt*(cnt-1)/2;
			r4[v]+=1ll*cnt*(cnt-1)/2;
			for(int i=h[v],w;i;i=e[i].next)
				if(dis[w=e[i].v]==1)
					r4[w]+=cnt-1;
		}
		for(int p=acnt1+1;p<=acnt;p++){
			int v=a[p];
			int cnt=0;
			for(int i=h[v],w;i;i=e[i].next)
				if(dis[w=e[i].v]==1)
					cnt++;
			r4[u]+=1ll*cnt*(cnt-1)/2;
			r4[v]+=1ll*cnt*(cnt-1)/2;
			for(int i=h[v],w;i;i=e[i].next)
				if(dis[w=e[i].v]==1)
					r4[w]+=cnt-1;
		}
		for(int i=1;i<=acnt;i++) dis[a[i]]=0;
	}/*}}}*/
	void CalcRing(){
		for(int i=1;i<=n;i++) lis[i]=i;
		sort(lis+1,lis+n+1,CmpD);
		for(int i=1;i<=n;i++) pos[lis[i]]=i;
		for(int i=1;i<=n;i++) 
			Calc(lis[i]);
	}
	void Print(){
		for(int u=1;u<=n;u++){
			LL ans=addSelf[u];
			for(int i=h[u];i;i=e[i].next)
				ans+=addSide[e[i].v];
			printf("%lld\n",ans);
		}
	}
	void Solve(){
		for(int u=1;u<=n;u++){
			int cnt=0;
			for(int i=h[u];i;i=e[i].next) cnt+=d[e[i].v]-1;
			for(int i=h[u];i;i=e[i].next){
				addSide[e[i].v]+=cnt-(d[e[i].v]-1);
				addSelf[u]-=cnt-(d[e[i].v]-1);
			}
		}
		for(int u=1;u<=n;u++){
			addSelf[u]-=2*r4[u];
			addSelf[u]-=2*r3[u]*(d[u]-1);
			for(int i=h[u],v;i;i=e[i].next){
				v=e[i].v;
				addSelf[u]-=2ll*(r3[v]-er3[u][v]);
			}
		}
		Print();
	}
}

void ReadData(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		Graph::AddEdge(u,v);
	}
}

int main(){
	ReadData();
	Graph::CalcRing();
	Graph::Solve();
	return 0;
}
```

