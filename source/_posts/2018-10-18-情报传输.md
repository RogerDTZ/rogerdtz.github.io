---
layout: post
mathjax: true
title: 【BZOJ4448】情报传递
date: 2018-10-18 15:57:00
tag: [数据结构---主席树]
category: BZOJ
---
# Description

　　给一棵树。每个点有点权，初始全为0

　　每一时刻可以做两种操作中的某一种：

* 激活某一个点。被激活的点在之后的每一时刻开始时都会+1

* 在当前时刻的末尾，询问树上一条路径上有多少点，以及有多少点的点权超过了输入的$c$

	$n,q \le 2*10^5$


<!-- more -->
# Solution

## 正解

　　查询的东西与点权有关，立刻要想到建权值线段树

　　查询的形式是一条路径，可以拆分为两条到根路径。如何维护到根路径上的权值线段树呢？直接用继承父亲的主席树实现即可

　　复杂度仅一个$\log$

## 乱搞

　　如果在第$t$时刻有一个参数为$c$的询问，这等价于在$t-c$时刻询问这个时刻之前（不包含当前时刻）加入了多少点

　　离线排个序后，使用树剖，支持路径查询点权和、单点+1两种操作即可

　　复杂度两个$\log$，实测还挺快......

# Summary

　　树上路径相关的问题，除了树剖，离线且不带修改时，还可以使用继承父亲形式的主席树。这样一条路径可以拆分为两条到根路径，直接前缀和一减就能得到路径的权值信息，这种做法说不定会比树剖优秀一个$\log$，还能支持更灵活的权值相关的查询



# Code

　　场上写的乱搞

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
namespace IO{
    const int L=30000000;
    char inBuf[L];
    int inPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
const int N=200010;
int n,m;
int root;
int h[N],tot;
struct Edge{
    int v,next;
}e[N];
int pre[N],dep[N],size[N],son[N];
int locCnt,loc[N],who[N],top[N];
struct Query{
    int opt; // 1:query 2:start
    int t;
    int x,y;
}q[N];
int qcnt;
bool hasStart[N];
bool isQuery[N];
int ans[N][2];
void addEdge(int u,int v){
    e[++tot]=(Edge){v,h[u]}; h[u]=tot;
}
void readData(){
    n=getInt();
    for(int u=1,fa;u<=n;u++){
        fa=getInt();
        if(fa)
            addEdge(fa,u);
        else
            root=u;
    }
}
void dissectionDfs1(int u,int fa){
    pre[u]=fa;
    dep[u]=dep[fa]+1;
    size[u]=1;
    for(int i=h[u],v;i;i=e[i].next){
        v=e[i].v;
        dissectionDfs1(v,u);
        size[u]+=size[v];
        if(!son[u]||size[v]>size[son[u]])
            son[u]=v;
    }
}
void dissectionDfs2(int u,int _top){
    top[u]=_top;
    locCnt++;
    loc[u]=locCnt;
    who[locCnt]=u;
    if(!son[u])
        return;
    dissectionDfs2(son[u],top[u]);
    for(int i=h[u],v;i;i=e[i].next)
        if((v=e[i].v)!=son[u])
            dissectionDfs2(v,v);
}
void Dissection(){
    dissectionDfs1(root,0);
    dissectionDfs2(root,root);
}
namespace SEG{
    const int S=N*2;
    int rt,sz;
    int ch[S][2];
    int sum[S];
    void build(int &u,int l,int r){
        u=++sz;
        if(l==r)
            return;
        int mid=(l+r)>>1;
        build(ch[u][0],l,mid);
        build(ch[u][1],mid+1,r);
    }
    void modify(int u,int l,int r,int p){
        sum[u]++;
        if(l==r)
            return;
        int mid=(l+r)>>1;
        if(p<=mid)
            modify(ch[u][0],l,mid,p);
        else
            modify(ch[u][1],mid+1,r,p);
    }
    int query(int u,int l,int r,int ql,int qr){
        if(ql<=l&&r<=qr)
            return sum[u];
        int mid=(l+r)>>1;
        if(qr<=mid)
            return query(ch[u][0],l,mid,ql,qr);
        else if(mid<ql)
            return query(ch[u][1],mid+1,r,ql,qr);
        else
            return query(ch[u][0],l,mid,ql,mid)+
                   query(ch[u][1],mid+1,r,mid+1,qr);
    }
}
void buildSeg(){
    SEG::build(SEG::rt,1,n);
}
bool cmpByTime(const Query &a,const Query &b){
    if(a.t!=b.t)
        return a.t<b.t;
    return a.opt>b.opt;
}
void addPoint(int u){
    SEG::modify(SEG::rt,1,n,loc[u]);
}
int getLCA(int a,int b){
    for(;top[a]!=top[b];dep[top[a]]>dep[top[b]]?a=pre[top[a]]:b=pre[top[b]]);
    return dep[a]<dep[b]?a:b;
}
int getPointCnt(int a,int b,int lca){
    return dep[a]+dep[b]-2*dep[lca]+1;
}
void query(int id,int a,int b){
    int lca=getLCA(a,b);
    ans[id][0]=getPointCnt(a,b,lca);
    int res=0;
    for(;dep[top[a]]>=dep[lca];a=pre[top[a]])
        res+=SEG::query(SEG::rt,1,n,loc[top[a]],loc[a]);
    if(dep[a]>=dep[lca])
        res+=SEG::query(SEG::rt,1,n,loc[lca],loc[a]);
    // (lca,b]
    for(;dep[top[b]]>dep[lca];b=pre[top[b]])
        res+=SEG::query(SEG::rt,1,n,loc[top[b]],loc[b]);
    if(dep[b]>dep[lca])
        res+=SEG::query(SEG::rt,1,n,loc[lca]+1,loc[b]);
    ans[id][1]=res;
}
void answerQuery(){
    int opt,x,y,c;
    m=getInt();
    for(int i=1;i<=m;i++){
        opt=getInt();
        if(opt==1){
            x=getInt(); y=getInt(); c=getInt();
            q[++qcnt]=(Query){i,i-c,x,y};
            isQuery[i]=true;
        }
        else{
            x=getInt();
            if(!hasStart[x]){
                q[++qcnt]=(Query){0,i,x,0};
                hasStart[x]=true;
            }
        }
    }
    sort(q+1,q+1+qcnt,cmpByTime);
    for(int i=1;i<=m;i++)
        if(q[i].opt)
            query(q[i].opt,q[i].x,q[i].y);
        else
            addPoint(q[i].x);
    for(int i=1;i<=m;i++)
        if(isQuery[i])
            printf("%d %d\n",ans[i][0],ans[i][1]);
}
int main(){
    IO::load();
    readData();
    Dissection();
    buildSeg();
    answerQuery();
    return 0;
}
```

 