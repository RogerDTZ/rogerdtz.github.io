---
layout: post
mathjax: true
title: 回文自动机的双向插入
date: 2018-12-09 09:03:50
tag: 字符串---回文自动机
category: Learning
---
　　*双向插入PAM应该是学PAM时就应该知道的基础操作，然而其实我并不会......*



# 目标

　　维护一个字符串的回文自动机，支持在字符串的前/后方追加一个字符

　　



# 双向插入PAM

　　双向PAM大体上与经典PAM没有什么不同。由于回文串的特殊性，在前端插入字符带来的更新，PAM也基本能自适应

　　总地来说，不同点如下：

* 普通PAM只需要记录上一次的结束位置，而双向PAM需要记录上一次向前插入的结束位置以及上一次向后插入的结束位置
* 查询fail的函数要多带一个选项：是正着找结尾的fail，还是反着找开头的fail？代码相应镜像即可
* 若进行一次前/后方插入后，当前结束位置的长度恰好等于全串长度，则令后/前方的结束位置也为当前结束位置。这一步是为了维护“结束位置为最长回文前/后缀”的性质，且可以证明这样维护是完全及时与必要的

　　

# 例题

　　请维护一个双向PAM，每插入一次字符后，输出回文串总数以及本质不同的回文串数量

　　操作数$n \le 5*10^5$，字符集$C\le 4$

```c++
#include <cstdio>
using namespace std;
typedef long long LL;
const int N=200010;
const int C=4;
int n;
namespace PAM{
    int a[N*2],pos[2];
    int sz,last[2];
    int trans[N][C];
    int len[N];
    int fail[N];
    int dep[N];
    LL ans;
    void init(){
        pos[0]=N; pos[1]=N-1;
        a[N-1]=a[N]=-1;
        sz=1;
        len[0]=0; len[1]=-1;
        fail[0]=1;
        dep[0]=0;
        last[0]=last[1]=0;
    }
    int getFail(int u,int d){
        if(d)
            for(;a[pos[1]-len[u]-1]!=a[pos[1]];u=fail[u]);
        else
            for(;a[pos[0]+len[u]+1]!=a[pos[0]];u=fail[u]);
        return u;
    }
    void insert(int c,int d){
        if(!d){
            a[--pos[0]]=c;
            a[pos[0]-1]=-1;
        }
        else{
            a[++pos[1]]=c;
            a[pos[1]+1]=-1;
        }
        int u=getFail(last[d],d);
        if(!trans[u][c]){
            int v=++sz;
            len[v]=len[u]+2;
            fail[v]=trans[getFail(fail[u],d)][c];
            dep[v]=dep[fail[v]]+1;
            trans[u][c]=v;
        }
        u=trans[u][c];
        last[d]=u;
        if(len[u]==pos[1]-pos[0]+1)
            last[d^1]=u;
        ans+=dep[last[d]];
    }
}
void solve(){
    scanf("%d",&n);
    char cmd[10],cha[10];
    for(int i=1;i<=n;i++){
        scanf("%s%s",cmd,cha);
        PAM::insert(cha[0]-'a',cmd[0]=='r');
        printf("%lld %d\n",PAM::ans,PAM::sz-1);
    }
}
int main(){
    PAM::init();
    solve();
    return 0;
}
``<!-- more -->`

