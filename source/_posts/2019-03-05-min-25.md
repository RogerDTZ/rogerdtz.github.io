---
title: Min_25筛
date: 2019-03-05 19:46:15
tags: min_25筛
categories: Learning
mathjax: true
---

Min_25筛是一个解决积性函数求和的算法：已知一积性函数$f(x)$，求$\sum_{i=1}^n f(i)$

它的时间复杂度为$O(\frac {n^{\frac 34}}{\log n})$，足以解决$n \le 10^{12}$的数据

<!-- more -->

# 约定的记号

* $p_i$表示第$i$个质数，即$p_1=2,p_2=3,\dots$
* $\alpha(x)$表示$x​$的最小质因子

# 算法流程

## 主递归

定义$h_{i,j}$：
$$
h_{i,j}=\sum_{x=2}^if(x)[\alpha(x)\ge p_j]
$$
显然，$h_{n,1}$就是最终答案

变换求和顺序：先枚举最小质因子$p$及其指数$e$，再统计最小质因子和指数恰好为$p$和$e$的$x$的$f(x)$之和
$$
h_{i,j}=\sum_{k \ge 1}\sum_{e \ge 1}[p_k^e \le i]f(p_k^e)(h_{\lfloor \frac i {p_k^e} \rfloor,k+1}+1)
$$
此处利用了积性函数的基本性质：先将公共部分$f(p_k^e)​$提出来，再统计除去$p_k^e​$后剩余部分的函数和

注意：$x=p_k^e$并没有顺利地被统计，因为$h$是从2开始枚举的，因此在括号内$+1$即可

实现上，我们用搜索的形式计算每一个$h$。由于有结论是搜索时状态不会相交，故不需要使用记忆化

到目前为止，复杂度仍然不对。注意到当$p_k ^2 > i$时，$e$只能取$1$，则$p_k$对答案的贡献就是$f(p_k)$。由此，贡献可以被拆成两部分：一部分是$p \le \sqrt i$的质数$p$直接通过上式计算的贡献（记这些质数中最大的一个为$p'$），一部分是$f(x)$在所有$\sqrt i < p \le i$处的取值。为了快速回答第二部分，我们需要预处理一个辅助数组

## 辅助数组

定义$g_{i,j}$：
$$
g_{i,j}=\sum_{x=2}^i [x\in P_j \lor \alpha(x)>p_j]s(x)
$$
其中，$P_i$为前$i$个质数构成的集合，$s(x)$是给定的一个**完全积性函数**

记$m$为最大的正整数$m'$使得$p_{m'}\le \sqrt n$。可以发现，$g_{i,m}$表示的就是$s(x)$在$[2,i]$中所有质数处的取值之和

如果我们精心构造$s(x)$，使得$s$和$f$在质数处的取值完全相同，刚才问题的答案就是$g_{i,m}-g_{p',m}$

下面看看如何计算$g$
$$
g_{i,j}=g_{i,j-1}-s(p_j)(g_{\lfloor \frac i {p_j} \rfloor,j-1}-g_{p_{j},j-1})
$$
从$g_{i,j-1}$转变到$g_{i,j}$时，那些$\alpha(x)=p_j$且$x \neq p_j$的$f(x)$被扣掉了。运用完全积性函数的性质，我们先把$s(p_j)$提出，再计算剩余部分的$s$之和即可

实现上，先初始化$g_{i,0}$，然后一层一层地转移$g_{i,1},g_{i,2},\dots$（注意到我们可以只使用一个数组，从大到小转移即可）

注意到一旦某个$i$满足$i \le p_j^2$，$g_{i,j}$的取值就不再更新，因此每一层转移需要操作的$i$是一个不断变小的后缀。这一步的边界优化必须要有

算法流程已经介绍完毕，但你可能还注意到一件事情：第一维太大了，根本存不下、算法复杂度也不对，怎么办？

## 离散化

记$S=\{x\mid x=\lfloor \frac ni\rfloor \}$

注意一件事情：$h$的第一维属于$S$（因为递归时使用了下取整），调用$g$时，$i$属于$S$，$p$属于$S$，故$g$的第一维也只需要计算$S$处的值；递推$g$时，不管$j$当前算到多少层，有用的位置仍然属于$S$

所以，我们只需要计算$g$的第一维属于$S$时的值，$h$调用时确定具体离散化位置即可

## 应用

Min_25筛使用的条件有：

1. 所求函数$f(x)$是**积性函数**
2. 构造一个**完全积性函数**$s(x)$，使得对于任意质数$p$，$f(p)=s(x)$。与其说是构造，不如说是对$f(x)$在质数处取值的式子进行化简，从而得到$s(x)$，~~并祈求它是一个完全积性函数~~。如果化简后得不到完全积性函数，若其能够展开成$m$次多项式的形式，我们可以令$s(x)=x^k,\ k=0\dots m$作为积性函数，求$m+1$次$g$函数，乘上多项式系数累加，就可以得到我们想要的$g$；但相应地，时间复杂度将变为$O(\frac {n^{\frac 34}}{\log n}m)$。广义地讲，多项式函数都可以用来求$g$
3. $s(x)$的前缀和必须可以快速计算，否则$g_{i,0}$的初始化将无法实现。由于$s(x)$是完全积性函数，因此大部分的$s(x)​$都可以方便地求前缀和

4. 求$h$时，我们需要调用$f(p_k^e)$。虽然有用的$p_k$不超过$\sqrt i$，但$p_k^e$可以达到$O(i)$级别。这意味着我们需要快速计算$f$在$p^q$处的取值。若没有很好的算法，这里的复杂度就会变高