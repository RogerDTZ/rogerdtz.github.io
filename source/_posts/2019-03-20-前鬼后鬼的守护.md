---
title: 前鬼后鬼的守护
mathjax: true
date: 2019-03-20 19:42:55
tags: [可做未做,DP]
---

# Description

有一个长度为$n$的数列$a_i$，你需要将它变为一个不下降序列。你可以花费1的代价令某一个元素加1或减1，求最小代价是多少

$n \le 5*10^5$，$1 \le a_i \le 10^9$

<!-- more -->

# Solution

## DP做法

40%的部分分满足$n,a_i \le 5000$。设$f_{i,j}$表示前$i$个数已经调整为非降序列，且最后一个数$\le j$时花费的最小代价：
$$
f_{i,j}=\min \left\{ f_{i-1,j}+|a_i-j|,f_{i-1,j} \right\}
$$
复杂度$O(n \max\{a_i\})​$

60%的部分分满足$n \le 5000$，显然这大概会是一个只与$n$相关的$O(n^2)$DP，脱离了关于大量权值的枚举。

（然而场上我对着40%DP的单调性开始写一个完全维护不了的东西，应该继续考虑脱离大量权值的部分分）

很容易猜到，一定存在一种最优方案，满足每一个数在调整后都是原来某个数的值，那么设$f_{i,j}$表示前$i$个数已经调整为非降序列，且最后一个数$\le$初始时第$j$大的数（记为$b_j$）时花费的最小代价：

$$
f_{i,j}=\min \left\{ f_{i-1,j}+|a_i-b_j|,f_{i-1,j} \right\}
$$

很容易注意到 $f_i$ 满足单调递减，且 $f_i$ 是由 $f_{i-1}$ 叠加上一个绝对值函数得来。考虑到叠加的是两条直线，我们可以使用差分：维护 $f_{i,j} - f_{i,j-1} $，再维护 $f_{i,0}$ 的具体值。叠加绝对值函数时令两端区间的斜率分别+1或-1即可。由于$f_i$是单调不增，所以任意时刻每处的斜率都不可以大于$0$，修改时要对$0$取$\min$。这点可以用势能分析来做，修改一段区间时，如果有数超过$0$，我们就暴力递归子区间，直到一段区间能够整体考虑为止，这样的复杂度是一个$\log$的

时间复杂度$O(n \log n)$

## 堆做法

观察得到，一定存在一种最优方案，满足所有数被划分成若干段，同一段数的最后取值恰好为本段的中位数，且每一段的中位数从前往后单调不降

从前往后考虑每一个$i$。初始时，令$i$单独成一个段。若$a_i$比上一段的中位数还要小，我们只好将$i$与上一段并同一段来考虑。重复这个过程直到当前段的中位数不小于上一段为止

可以使用可并堆完成这些操作并利用堆大小维护每一段的中位数

时间复杂度$O(n \log n)$

# Summary

<!-- summary_start -->

切忌使用一个显然不是正解简化版本的部分分做法直接开始推正解！如果有更优秀做法的部分分（如脱离权值），一定要记得去看、去做，再在其基础上考虑优化。

线段树三原则：

* 维护信息可上推
* 打标记时可迅速考虑变化之后子段的信息
* 标记可叠加

写之前一定要检查这些点，特别是第二点不能假掉

<!-- summary_end -->

# Code

```c++
#include <cstdio>
#include <algorithm>
using std::swap;
typedef long long LL;
const int N=500000+10;
namespace LT{
	const int VER=(::N);
	const int SIZE=(::N);
	struct Node{
		int ch[2];
		int size;
		int val;
	}a[SIZE];
	int nodeCnt;
	int rt[VER];
	void Pushup(int u){
		a[u].size=a[a[u].ch[0]].size+a[a[u].ch[1]].size+1;
	}
	void NewHeap(int rid,int val){
		rt[rid]=++nodeCnt;
		a[rt[rid]].size=1;
		a[rt[rid]].val=val;
	}
	int Merge(int x,int y){
		if(!x||!y)
			return x+y;
		if(a[x].val<a[y].val)
			swap(x,y);
		a[x].ch[1]=Merge(a[x].ch[1],y);
		swap(a[x].ch[0],a[x].ch[1]);
		Pushup(x);
		return x;
	}
	void MergeHeap(int r1,int r2){
		rt[r1]=Merge(rt[r1],rt[r2]);
	}
	int Top(int rid){
		return a[rt[rid]].val;
	}
	void Pop(int rid){
		rt[rid]=Merge(a[rt[rid]].ch[0],a[rt[rid]].ch[1]);
	}
}
int n;
int a[N];
void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
}
void Solve(){
	static int range[N][2];
	int rcnt=0;
	for(int i=1;i<=n;i++){
		LT::NewHeap(++rcnt,a[i]);
		range[rcnt][0]=range[rcnt][1]=i;
		while(rcnt>1&<::Top(rcnt)<LT::Top(rcnt-1)){
			range[rcnt-1][1]=range[rcnt][1];
			LT::MergeHeap(rcnt-1,rcnt);
			rcnt--;
			while(LT::a[LT::rt[rcnt]].size>(range[rcnt][1]-range[rcnt][0]+1+1)/2)
				LT::Pop(rcnt);
		}
	}
	LL ans=0;
	for(int i=1;i<=rcnt;i++){
		int stdVal=LT::Top(i);
		for(int j=range[i][0];j<=range[i][1];j++)
			ans+=abs(stdVal-a[j]);
	}
	printf("%lld\n",ans);
}
int main(){
	ReadData();
	Solve();
	return 0;
}
```

