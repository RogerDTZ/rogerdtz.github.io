---
title: 最大值问题
mathjax: true
date: 2019-03-17 10:22:00
tags: [分块,可做未做]
---

# Description

有一个长度为$n$的序列$a_i$

若一个区间$[l,r]$拥有恰好$k$个最大值，则它对$ans_k$有1的贡献

请求出$ans_1,ans_2,\dots,ans_n$

$n \le 10^5$，$1 \le a_i \le n$

<!-- more -->

# Solution

一种思路是固定右端点，维护所有左端点构成区间对答案的贡献。但这种方式涉及到累加和不可做的判断条件

考虑枚举最大值$x$，并统计所有最大值为$x$的区间对答案的贡献

不妨从大到小枚举$x$，我们考虑的区间不能包含$a_i>x$的位置，但必须至少包含一个$a_i=x$的位置。注意到可选区间被分成了很多极长段，我们对每一段单独处理

对于一个包含$m$个$x$的极长段，我们计算出第一个$x$与左边第一个$>x$的位置的差，记为$f_0$；计算出每两个$x$的距离$f_1,f_2,\dots,f_{m-1}$；计算出最后一个$x$与右边第一个$>x$的位置的差。我们发现，对$ans_k$的贡献即$\sum_{i} f_if_{i+k}$，将$f$与翻转后的$f$做卷积即可

时间复杂度$O(n \log n)$

# Summary

<!-- summary_start -->

对于统计问题，尝试从各种角度枚举并统计，如区间、权值等，一个不行可以考虑另一个可能可行的方面

<!-- summary_end -->

# Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <cmath>
using std::min;
using std::max;
using std::swap;
using std::acos;
using std::round;
using std::vector;
using std::reverse;
typedef long long LL;
const int INF=1e9;
const double PI=acos(-1);
const int N=100000+10;
int n;
int a[N];
vector<int> p[N];
struct Complex{
	double x,y;
	Complex(){
		x=y=0;
	}
	Complex(double x,double y): x(x),y(y) {}
	friend Complex operator + (const Complex &a,const Complex &b){
		return Complex(a.x+b.x,a.y+b.y);
	}
	friend Complex operator - (const Complex &a,const Complex &b){
		return Complex(a.x-b.x,a.y-b.y);
	}
	friend Complex operator * (const Complex &a,const Complex &b){
		return Complex(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);
	}
	friend Complex operator / (const Complex &a,const double b){
		return Complex(a.x/b,a.y/b);
	}
};
namespace FFT{
	const int B=18;
	const int N=(1<<B)+10;
	Complex *rt[B+1];
	int n,bit;
	int rev[N];
	void InitW(){
		for(int i=2,logi=1;logi<=B;i<<=1,logi++){
			rt[logi]=new Complex[i];
			for(int k=0;k<(i>>1);k++){
				rt[logi][k]=rt[logi][k+(i>>1)]=Complex(cos(2*PI/i*k),sin(2*PI/i*k));
				rt[logi][k+(i>>1)].y*=-1;
			}
		}
	}
	void Init(int _n){
		for(n=1,bit=0;n<_n;n<<=1,bit++);
		for(int i=0;i<n;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
	}
	void FFT(Complex *a,int f){
		for(int i=0;i<n;i++)
			if(i<rev[i])
				swap(a[i],a[rev[i]]);
		for(int i=2,logi=1;i<=n;i<<=1,logi++)
			for(int j=0;j<n;j+=i)
				for(int k=0;k<(i>>1);k++){
					Complex w=rt[logi][k+(f?(i>>1):0)];
					Complex u=a[j+k];
					Complex v=w*a[j+(i>>1)+k];
					a[j+k]=u+v;
					a[j+(i>>1)+k]=u-v;
				}
		if(f)
			for(int i=0;i<n;i++) a[i]=a[i]/n;
	}
}
void PolyMul(LL *a,LL *b,LL *c,int n,int m,int cut=INF){
	static Complex f[FFT::N],g[FFT::N];
	int len=n+m-1;
	FFT::Init(len);
	for(int i=0;i<n;i++) f[i]=Complex(a[i],0);
	for(int i=0;i<m;i++) g[i]=Complex(b[i],0);
	memset(f+n,0,sizeof(Complex)*(FFT::n-n));
	memset(g+m,0,sizeof(Complex)*(FFT::n-m));
	FFT::FFT(f,0);
	FFT::FFT(g,0);
	for(int i=0;i<FFT::n;i++) f[i]=f[i]*g[i];
	FFT::FFT(f,1);
	for(int i=0;i<min(len,cut);i++) c[i]=round(f[i].x);
}
void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		p[a[i]].push_back(i);
	}
	a[0]=a[n+1]=INF;
}
namespace BITL{/*{{{*/
	const int N=(::N);
	int n;
	int a[N];
	void SetRange(int _n){
		n=_n;
		for(int i=1;i<=n;i++) a[i]=0;
	}
	void Modify(int u,int x){
		for(;u&&u<=n;u+=u&-u) a[u]=max(a[u],x);
	}
	int Query(int u){
		int res=0;
		for(;u;u-=u&-u) res=max(res,a[u]);
		return res;
	}
}/*}}}*/
namespace BITR{/*{{{*/
	const int N=(::N);
	int n;
	int a[N];
	void SetRange(int _n){
		n=_n;
		for(int i=1;i<=n;i++) a[i]=n+1;
	}
	void Modify(int u,int x){
		for(;u;u-=u&-u) a[u]=min(a[u],x);
	}
	int Query(int u){
		int res=n+1;
		for(;u&&u<=n;u+=u&-u) res=min(res,a[u]);
		return res;
	}
}/*}}}*/
void Solve(){
	static LL sum[N];
	BITL::SetRange(n);
	BITR::SetRange(n);
	for(int x=n;x>=1;x--){
		for(int i=0,j;i<int(p[x].size());i=j){
			int pre=BITL::Query(p[x][i]);
			int nex=BITR::Query(p[x][i]);
			for(j=i;j<int(p[x].size())&&p[x][j]<nex;j++);
			int len=j-i;
			static LL f[N],g[N],h[N*2];
			f[0]=p[x][i]-pre;
			for(int k=1;k<len;k++) f[k]=p[x][i+k]-p[x][i+k-1];
			f[len]=nex-p[x][i+len-1];
			memcpy(g,f,sizeof(LL)*(len+1));
			reverse(g,g+(len+1));
			PolyMul(f,g,h,len+1,len+1);
			for(int k=1;k<=len;k++) sum[k]+=h[len+k];
		}
		for(int i=0;i<int(p[x].size());i++){
			BITL::Modify(p[x][i],p[x][i]);
			BITR::Modify(p[x][i],p[x][i]);
		}
	}
	LL ans=0;
	for(int i=1;i<=n;i++) ans+=(i^sum[i]);
	printf("%lld\n",ans);
}
int main(){
	FFT::InitW();
	ReadData();
	Solve();
	return 0;
}
```

