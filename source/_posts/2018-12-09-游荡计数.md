---
layout: post
mathjax: true
title: 游荡计数
date: 2018-12-09 09:16:50
tag: [Cayley-Hamilton定理,高斯消元,拉格朗日插值,特征多项式,多项式]
---
# Description

　　给定一个$n\times n$的方阵$A$，求$A^m\mod 1e9+9$

　　$m$以二进制形式给出

　　$n \le 50,\ m \le 2^{10000}$ 



　　

<!-- more -->
# Solution

　　矩阵快速幂优化裸题，常系数线性齐次递推中的步骤。再做一次这道题算是加深一下对思路的印象吧

　　由于$A$的特征多项式$f(x)$是一个以$x$为自变量的$n$次多项式，我们可以通过计算相应的行列式求得$f(0),f(1),\dots,f(n)$，再利用拉格朗日插值插出$f(x)$。这一步的时间复杂度为$O(n^4)$

　　令多项式$x^n$对$f(x)$进行取模，即$x^n \mod f(x)=f(x)g(x)+r(x)$

　　令$A$为自变量$x$代入其中，又根据Cayley-Hamilton定理得$f(A)=0$，则有

$$
\begin{aligned}
A^n \mod f(A)&=f(A)g(A)+r(A)\\
\because f(A)&=0\\
\therefore A^n \mod f(A)&=r(A)\\

\because A^n \mod f(A) &= A^n \\
\therefore A^n &= r(A) \mod 1e9+9
\end{aligned}
$$

　　我们直接求出$r(x)$即可，即在快速幂计算$x^n$的同时，将结果对$f(x)$进行取模。这一步使用朴素取模即可，时间复杂度$O(n^2 \log_2 m)$

　　最后，将$A$代入$r(x)$中即可得到答案

　　总时间复杂度$O(n^4+n^2 \log_2 m)$

　　

# Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MOD=1e9+9;
const int N=60;
const int L=10010;
int n;
int mlen,m[L];
struct Mat{
    int n,m;
    int a[N][N];
    Mat(){
        n=m=0;
        reset();
    }
    Mat(int _n,int _m){
        n=_n; m=_m;
        reset();
    }
    void reset(){
        memset(a,0,sizeof a);
    }
    void setUnit(){
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                a[i][j]=(i==j);
    }
    void print(){
        for(int i=1;i<=n;i++,puts(""))
            for(int j=1;j<=m;j++)
                printf("%d ",a[i][j]>=0?a[i][j]:a[i][j]+MOD);
    }
    friend Mat operator + (const Mat &u,const Mat &v){
        Mat res=Mat(u.n,u.m);
        for(int i=1;i<=u.n;i++)
            for(int j=1;j<=u.m;j++)
                res.a[i][j]=(u.a[i][j]+v.a[i][j])%MOD;
        return res;
    }
    friend Mat operator - (const Mat &u,const Mat &v){
        Mat res=Mat(u.n,u.m);
        for(int i=1;i<=u.n;i++)
            for(int j=1;j<=u.m;j++)
                res.a[i][j]=(u.a[i][j]-v.a[i][j])%MOD;
        return res;
    }
    Mat operator * (const int k){
        Mat res=Mat(n,m);
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                res.a[i][j]=1ll*k*a[i][j]%MOD;
        return res;
    }
    friend Mat operator * (const Mat &u,const Mat &v){
        Mat res=Mat(u.n,v.m); for(int i=1;i<=u.n;i++) for(int j=1;j<=v.m;j++){
                LL t=0;
                for(int k=1;k<=u.m;k++)
                    t+=1ll*u.a[i][k]*v.a[k][j]%MOD;
                res.a[i][j]=t%MOD;
            }
        return res;
    }
}a,unit;
int fastPow(int x,int y){
    int res=1;
    for(;y;x=1ll*x*x%MOD,y>>=1)
        if(y&1)
            res=1ll*res*x%MOD;
    return res;
}
void readData(){
    scanf("%d",&n);
    static char str[L];
    scanf("%s",str);
    mlen=strlen(str);
    for(int i=0;i<mlen;i++) m[i]=(str[mlen-1-i]=='1');
    a=Mat(n,n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            scanf("%d",&a.a[i][j]);
    unit=Mat(n,n);
    unit.setUnit();
}
int cp[N*10];
int cpInv;
int GaussianDet(int n,int a[][N]){
    int res=1;
    for(int i=1;i<=n;i++){
        if(!a[i][i]){
            int t;
            for(t=i;t<=n&&!a[t][i];t++);
            if(t<=n&&a[t][i]){
                res=-res;
                swap(a[i],a[t]);
            }
            else
                return 0;
        }
        int inv=fastPow(a[i][i],MOD-2);
        for(int j=i+1;j<=n;j++){
            int t=1ll*a[j][i]*inv%MOD;
            for(int k=i;k<=n;k++) (a[j][k]-=1ll*t*a[i][k]%MOD)%=MOD;
        }
    }
    for(int i=1;i<=n;i++) res=1ll*res*a[i][i]%MOD;
    return res;
}
void Lagrange(int n,int *x,int *y,int *res){
    static int a[N],b[N],c[N];
    memset(res,0,sizeof(int)*(n+3));
    memset(a,0,sizeof(int)*(n+3));
    a[0]=1;
    for(int i=0;i<=n;i++){
        for(int j=i+1;j;j--)
            a[j]=(a[j-1]-1ll*x[i]*a[j]%MOD)%MOD;
        a[0]=-1ll*x[i]*a[0]%MOD;
    }
    for(int i=0;i<=n;i++){
        memcpy(b,a,sizeof(int)*(n+3));
        memset(c,0,sizeof(int)*(n+3));
        for(int j=n;j>=0;j--){
            c[j]=b[j+1];
            (b[j]+=1ll*x[i]*c[j]%MOD)%=MOD;
        }
        int deno=1;
        for(int j=0;j<=n;j++)
            if(j!=i)
                deno=1ll*deno*(x[i]-x[j])%MOD;
        deno=fastPow(deno,MOD-2);
        for(int j=0;j<=n;j++)
            (res[j]+=1ll*y[i]*c[j]%MOD*deno%MOD)%=MOD;
    }
}
void calcCP(){
    static int x[N],y[N];
    static Mat s(n,n);
    for(int i=0;i<=n;i++){
        x[i]=i;
        s=(unit*i)-a;
        y[i]=GaussianDet(n,s.a);
    }
    Lagrange(n,x,y,cp);
    cpInv=fastPow(cp[n],MOD-2);
}
void polyMul(int n,int *a,int *b,int *c){
    static int t[N*10];
    for(int i=0;i<=(n<<1);i++) t[i]=0;
    for(int i=0;i<=n;i++)
        for(int j=0;j<=n;j++)
            (t[i+j]+=1ll*a[i]*b[j]%MOD)%=MOD;
    for(int i=(n<<1);i>=n;i--){
        int k=1ll*t[i]*cpInv%MOD;
        for(int j=0;j<=n;j++)
            (t[i-(n-j)]-=1ll*k*cp[j]%MOD)%=MOD;
    }
    for(int i=0;i<=n;i++) c[i]=t[i];
}
int r[N*10];
void CayleyHamiton(){
    static int x[N*10];
    x[1]=1;
    r[0]=1;
    for(int i=0;i<mlen;i++,polyMul(n,x,x,x))
        if(m[i])
            polyMul(n,r,x,r);
}
void solve(){
    static Mat ans(n,n);
    static Mat now(n,n);
    now.setUnit();
    for(int i=0;i<=n;i++){
        ans=ans+(now*r[i]);
        now=now*a;
    }
    ans.print();
}
int main(){
    readData();
    calcCP();
    CayleyHamiton();
    solve();
    return 0;
}
```

