---
title: 恐狼后卫
mathjax: true
date: 2019-04-17 16:12:38
tags: [DP---区间DP,好题]
---

# Description

有$N$只“恐狼后卫”排成一排，每一只恐狼后卫有三个属性

* $a_i$：它的攻击力
* $b_i$：它提升相邻恐狼后卫攻击力的数值
* $h_i$：它的血量

你的攻击力固定为$atk$

请求出干掉所有恐狼后卫所承受的最小伤害

$N \le 400​$

<!-- more -->

# Solution

显然存在一种最优方案，满足我逐个解决掉恐狼后卫，即每次不断攻击某只恐狼后卫直到其死亡

记$t_i=\lceil \frac {h_i} {atk} \rceil$为干掉第$i$个恐狼后卫所需的攻击次数

注意到$a_i$对答案的贡献已经固定，可以提前计算这一部分的值

观察到数据范围为$O(N^3)​$，再考虑到最优方案的攻击顺序没有特点，我们采用区间DP

设$f_{l,r}​$表示解决编号为$l \dots r​$的恐狼后卫所受伤害的最小代价（所受伤害包括$l-1​$和$r+1​$两只恐狼后卫带来的伤害）

这里用掉了$O(N^2)$的复杂度，那么剩余的一些复杂度应该是用来枚举区间内某个元素的

枚举什么呢？如果我们枚举的是该区间内第一个被攻击的恐狼后卫，那么$[l,r]​$会分裂成两个子区间，但是这两个子区间会立刻靠拢，所以这并不是一个子问题

考虑枚举该区间内最后一个被攻击的恐狼后卫，这样一来，两个子区间就变成了两个子问题。转移如下
$$
f_{l,r}=\min_{x\in[l,r]}\{ f_{l,x-1}+f_{x+1,r}+t_x(b_{l-1}+b_{r+1}	) \}
$$
时间复杂度$O(N^3)$

# Code

```c++
#include <cstdio>
#include <cmath>

const int INF_DANGER=2e9;
const int N=400+10;

inline int min(int x,int y){
	return x<y?x:y;
}

int n;
int atk;
int a[N],b[N],h[N],t[N];
int ans;

void ReadData(){
	scanf("%d",&n);
	scanf("%d",&atk);
	for(int i=1;i<=n;i++){
		scanf("%d%d%d",&a[i],&b[i],&h[i]);
		t[i]=ceil(1.0*h[i]/atk);
		ans+=a[i]*t[i];
	}
}
void DP(){
	static int f[N][N];
	for(int i=1;i<=n;i++) f[i][i]=(b[i-1]+b[i+1])*t[i];
	for(int l=2;l<=n;l++)
		for(int i=1,j=l;j<=n;i++,j++){
			f[i][j]=INF_DANGER;
			for(int k=i;k<=j;k++)
				f[i][j]=min(f[i][j],f[i][k-1]+f[k+1][j]+t[k]*(b[i-1]+b[j+1]));
		}
	printf("%d\n",ans+f[1][n]);
}
int main(){
	ReadData();
	DP();
	return 0;
}
```

