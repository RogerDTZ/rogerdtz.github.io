---
layout: post
mathjax: true
title: 覆盖独立集
date: 2018-10-05 16:19:00
tag: [转化,DP,好题]
---
# Description

　　对于长度为 $n$ 的序列 $A$ ，定义其逆序图 $G$ 如下：无向图 $G$ 有 $n$ 个节点，编号为 $1.. n$ ；对于任意的 $0 \leq i \le  j \le n-1$ ，如果有 $a[i] > a[j]$ ，那么 $G$ 中存在一条 $i$ 和 $j$ 之间的边

　　定义独立集 $S$ ：对于$\forall x \in S, y \in S$ ，都不存在一条边 $(x,y)$

　　定义覆盖集 $S$ ：对于$\forall x \notin S$ ，至少存在一条边 $(x,y)$ ，使得 $y \in S$

　　问题来了：给你一个逆序图 $G$（保证合法），求 $G$&nbsp;有多少个点集既是独立集又是覆盖集


<!-- more -->
# Solution

　　首先清楚一个界限：一般图的独立集是NP问题，一般做不动

　　观察到题目给出的“图”实际上是由一个序列转化而来，则可以猜测这个图、这个序列有很好的性质，或许能够迎合我们的两个要求

　　可以发现每一个逆序图都对应着至少一个序列$A$。我们不妨先构造出序列$A$，然后把两个限制照搬到序列上，看看有没有将两个限制转化成一些序列问题

　　考虑一个独立集$S$，其内部满足两两之间的点没有连边，也就是如果考虑$S$的每一个点对，它们在原序列上都不是逆序对。这相当于$S$在原序列上对应的位置构成了一个不下降子序列

　　考虑一个覆盖集$S$，要满足所有不在$S$的点都与$S$有连边，意味着所有不在$S$中的点都要和$S$中的某些元素构成逆序对。考虑原序列中的每个未选中的元素，下列情况必须满足其一：

* 左边有严格大于它的$S$中元素
* 右边有严格小于它的$S$中元素

　　我们综合上述两个条件，得出最后的转化结果：一个点集$S$满足要求，当且仅当此点集在原序列中对应着一个不下降子序列，且对于$S$中按编号排序后两个相邻的元素在原序列中对应的两个元素$a_i,a_j$，中间夹着的每一个元素$k\in(i,j)$都要满足$a_k<a_i$或者$a_k>a_j$；换言之，不可以出现$a_i\le a_k \le a_j$的情况

　　序列上的带限制的统计问题，我们一般使用DP解决。在原序列上，设$f_i$表示以$a_i$结尾的合法子序列数目。考虑正向转移，$a_i$后面可以跟哪一些$a_j$呢？我们只需要从$i+1$开始往后枚举每一个$j$，维护中间夹着的、满足$a_k\ge a_i$的最小值，看是否大于$a_j$即可。若合法，令$f_j+=f_i$。这样一来，我们就可以在$O(n^2)$的时间完成这个DP

　　为了方便，可以令$a_0=-\infty， a_{n+1}=\infty$。我们钦定这两个元素必选，则DP完成后，$f_{n+1}$就是答案

　　对于从图还原成序列的过程，我们先通过输入统计对于序列上的每一个位置，其右边的比它小的位置有多少个，记为$s_i$。还原时，从后往前填入每一个数，每次找到右边第$s_i$大的数，记为$x$，将右边所有不小于$s_i$的数全部+1，偏移一位，空出$x$，令$a_i$为$x$即可

　　注意细节，比如$a_0$和$a_{n+1}$应该设成$\pm (\infty-1)$，以防DP维护最小值时，初值$\infty$无法成功判定严格大于



# Summary

　　如果题目涉及到一些较困难的传统问题，最好应观察题目是否有给定一些性质。我们应该从那些性质入手构建并转化出另一套更简单的模型并解决，而不是纠缠于如何将几个复杂的问题套在一起解决



# Code

```c++
#include <cstdio>
using namespace std;
typedef long long ll;
const int N=1010;
const int INF=1e9;
int n,m;
int sum[N];
int a[N];
ll f[N];
inline int min(int x,int y){
    return x<y?x:y;
}
void readData(){
    scanf("%d%d",&n,&m);
    int u,v;
    for(int i=1;i<=m;i++){
        scanf("%d%d",&u,&v);
        u++; v++;
        if(u<v)
            sum[u]++;
        else
            sum[v]++;
    }
}
void initSequence(){
    a[0]=-INF;
    static int who[N],up=0;
    for(int i=n;i>=1;i--){
        for(int j=up-1;j>=sum[i];j--){
            a[who[j]]++;
            who[j+1]=who[j];
        }
        a[i]=sum[i];
        who[sum[i]]=i;
        up++;
    }
    a[n+1]=INF-1;
}
void solve(){
    f[0]=1;
    for(int i=0,k;i<=n;i++){
        k=INF;
        for(int j=i+1;j<=n+1;j++)
            if(a[j]>=a[i]&&k>a[j]){
                f[j]+=f[i];
                if(a[j]>a[i])
                    k=min(k,a[j]);
            }
    }
    printf("%lld\n",f[n+1]);
}
int main(){
    readData();
    initSequence();
    solve();
    return 0;
}
```

