---
title: 三元组
mathjax: true
date: 2019-04-07 20:16:17
tags: [一般图匹配,适应,建图]
---

# Description

有一个二分图，左部分包含$n$个点（标号$1 \dots n$），右边包含$m$个点（标号$n+1 \dots n+m$），中间有一些连边。

请挑出最多的三元组$(a,b,c)$，使得：

* $a\neq b \neq c$，每个元素至多属于一个三元组
* $a \le n$，$b>n$，$c>n$
* $a$和$b,c$都有连边

$n+m \le 150$

<!-- more -->

# Solution

对于左边的每一个点$i$，将其拆成两个点$i_1,i_2$并连一条边$(i_1,i_2)$，对于与$i$有连边的每个点$j$，连两条边$(i_1,j)$和$(i_2,j)$，然后跑一般图最大匹配，减去$n$就是答案

一个左边的点$a$和右边的两个点$b,c$配对，在新图的表现形式就是$a_1$和$a_2$分别与$b$和$c$配对

一个左边的点$a$没有选中，在新图的表现形式就是$a_1$和$a_2$连了一条边。注意到如果是$a_1$或$a_2$中的某个连向了某个$b$或$c$，显然可以用$(a_1,a_2)$替换掉这条边，留给其他人更多选择，从而最大化匹配

上个带花树就做完了

时间复杂度$O (n^3)$

# Code

```c++
#include <cstdio>
#include <cstring>
#include <queue>
using std::queue;
const int INF=1e9;
const int N=150+10;
int n,m;
bool link[N][N];
namespace Graph{
    const int N=(::N)*3;
    const int M=(::N)*(::N)*2+(::N);
    int n;
    int h[N],tot;
    struct Edge{
        int v,next;
    }e[M*2];
    int match[N],s[N],pre[N],vis[N],tim;
    int dsu[N];
    queue<int> q;
    void AddEdge(int u,int v){
        e[++tot]=(Edge){v,h[u]}; h[u]=tot;
        e[++tot]=(Edge){u,h[v]}; h[v]=tot;
    }
    int FindDSU(int x){return dsu[x]==x?x:(dsu[x]=FindDSU(dsu[x]));}
    int GetLCA(int x,int y){
        tim++;
        x=FindDSU(x); y=FindDSU(y);
        for(;;x^=y^=x^=y)
            if(x){
                if(vis[x]==tim) return x;
                vis[x]=tim;
                x=FindDSU(pre[match[x]]);
            }
    }
    void Blossom(int x,int y,int lca){
        while(FindDSU(x)!=lca){
            pre[x]=y;
            if(s[match[x]]==1){
                s[match[x]]=0;
                q.push(match[x]);
            }
            if(dsu[x]==x) dsu[x]=lca;
            if(dsu[match[x]]==match[x]) dsu[match[x]]=lca;
            y=match[x];
            x=pre[y];
        }
    }
    int Match(int x){
        for(int i=1;i<=n;i++) dsu[i]=i;
        memset(s,-1,sizeof s);
        memset(pre,0,sizeof pre);
        while(!q.empty()) q.pop();  
        s[x]=0;
        q.push(x);
        while(!q.empty()){
            int u=q.front(); q.pop();
            for(int i=h[u],v;i;i=e[i].next){
                v=e[i].v;
                if(s[v]==-1){
                    pre[v]=u; 
                    s[v]=1;
                    if(!match[v]){
                        for(int go=1;go;v=go,u=pre[go]){
                            go=match[u];
                            match[u]=v; match[v]=u;
                        }
                        return true;
                    }
                    s[match[v]]=0;
                    q.push(match[v]);
                }else if(!s[v]&&FindDSU(u)!=FindDSU(v)){
                    int lca=GetLCA(u,v);
                    Blossom(u,v,lca);
                    Blossom(v,u,lca);
                }
            }
        }
        return false;
    }
    int Solve(){
        int res=0;
        for(int i=1;i<=n;i++)
            if(!match[i])
                res+=Match(i);
        return res;
    }
}
void ReadData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        static char str[N];
        scanf("%s",str+1);
        for(int j=1;j<=m;j++) link[i][j]=(str[j]=='1');
    }
}
void BuildGraph(){
    for(int i=1;i<=n;i++){
        Graph::AddEdge(i,n+i);
        for(int j=1;j<=m;j++)
            if(link[i][j]){
                Graph::AddEdge(i,2*n+j);
                Graph::AddEdge(n+i,2*n+j);
            }
    }
    Graph::n=n*2+m;
}
int main(){
    ReadData();
    BuildGraph();
    printf("%d\n",Graph::Solve()-n);
    return 0;
}
```

