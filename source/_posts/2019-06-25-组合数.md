---
title: 组合数
mathjax: true
date: 2019-06-25 15:55:57
tags: [DP---数位DP]
---

# Description

求
$$
\sum_{i_1=l_1}^{r_1} \sum_{i_2=l_2}^{r_2} \dots \sum_{i_n=l_n}^{r_n}
{m \choose \sum_{j=1}^n i_j}
$$
答案对$p$取模

$n \le 7$，$p=2,3,5,7$，$1 \le l_i \le r_i \le 10^{17}$

<!-- more -->

# Solution

用Lucas定理展开组合数，显然我们要对$\sum_{j=1}^n i_j$的每一位进行DP

先不考虑边界限制的

从高往低DP每一位，暴力转移是枚举每个数的这一位是什么，复杂度$O(n^p)$

我们可以用DP进一步优化枚举：设$f_{i,j,k}$表示当前从高到低DP直到第$i$位，目前考虑了前$j$个数字在第$i$位的取值，这一位剩余的值还有$k$时，答案之和是多少

每次$f_{i+1}$计算完开始计算$f_{i}$的时候，枚举第$i$位预分配多少值（上一位如果没用完，则变成进位的需求，乘$p$后累加到第$i$位上），即从$f_{i+1,n,k}$转移到$f_{i,0,kp+x}$

在同层中对$n$个数顺次做背包即可

由于每个数还有区间范围，我们可以再多开一维，表示每一个数目前是否触碰下界和是否触碰上界，这个信息可以用4进制表示

注意到我们可以把“触碰上界和下界”的状态和“仅触碰上界”看成一个状态，通过判断两个边界的前$i$位是否完全相同即可知道目前这个状态究竟是哪一个。因此我们可以用3进制表示所有数的信息，复杂度进一步降低

# Summary

<!-- summary_start -->

同层转移如果涉及到大量枚举，首先考虑使用DP，这样会降低复杂度

<!-- summary_end -->

# Code

```c++
#include <cstdio>
 
typedef long long LL;
 
const int N=7+2;
const int P=7+2;
const int B=60+5;
const int W=49+5; // N*P
const int S=2187+10; // 3^N
 
int bin3[N];
char comb[P][P];
int n;
LL m;
int p;
int fm[B],mlen,fl[N][B],fr[N][B];
 
inline void apply(char &x,const char &y){
    (x+=y)%=p;
}
 
void InitBin3(int n){
    bin3[1]=1;
    for(int i=2;i<=n+1;i++) bin3[i]=bin3[i-1]*3;
}
 
void InitComb(int n){
    comb[0][0]=1;
    for(int i=1;i<=n;i++){
        comb[i][0]=1;
        for(int j=1;j<=i;j++) comb[i][j]=(comb[i-1][j]+comb[i-1][j-1])%p;
    }
}
 
int P_Format(int p,LL num,int *out){
    int len=0;
    while(num){
        out[len++]=num%p;
        num/=p;
    }
    return len;
}
 
bool ReadData(){
    scanf("%d%lld%d",&n,&m,&p);
    mlen=P_Format(p,m,fm);
    for(int i=1;i<=n;i++){
        LL l,r;
        scanf("%lld%lld",&l,&r);
        if(l>m)
            return false;
        if(r>m)
            r=m;
        P_Format(p,l,fl[i]);
        P_Format(p,r,fr[i]);
    }
    return true;
}
 
void DP(){
    static bool same[N];
    static char f[B][N][W][S];
    for(int i=1;i<=n;i++) same[i]=true;
    f[mlen][n][0][bin3[n+1]-1]=1;
    for(int b=mlen-1;b>=0;b--){
        for(int w=0;w<=n*p;w++)
            for(int s=0;s<bin3[n+1];s++)
                for(int x=0;x<=fm[b];x++)
                    if(w*p+x<=n*p)
                        apply(f[b][0][w*p+x][s],comb[fm[b]][x]*f[b+1][n][w][s]%p);
        for(int i=1;i<=n;i++){
            for(int s=0;s<bin3[n+1];s++){
                static int a[N];
                for(int j=1;j<=n;j++) a[j]=0;
                P_Format(3,s,a+1);
                for(int w=0;w<=n*p;w++)
                    if(f[b][i-1][w][s]){
                        for(int x=0;x<p&&x<=w;x++){
                            int ns=-1;
                            if(a[i]==0){
                                ns=s;
                            }else if(a[i]==1){ // lower
                                if(x<fl[i][b])
                                    continue;
                                if(x==fl[i][b])
                                    ns=s;
                                else
                                    ns=s-bin3[i];
                            }else{
                                if(same[i]){ // both lower and upper
                                    if(x<fl[i][b]||x>fr[i][b])
                                        continue;
                                    if(x==fr[i][b])
                                        ns=s;
                                    else if(x==fl[i][b])
                                        ns=s-bin3[i];
                                    else
                                        ns=s-bin3[i]*2;
                                }else{ // upper
                                    if(x>fr[i][b])
                                        continue;
                                    if(x==fr[i][b])
                                        ns=s;
                                    else
                                        ns=s-bin3[i]*2;
                                }
                            }
                            apply(f[b][i][w-x][ns],f[b][i-1][w][s]);
                        }
                    }
            }
            same[i]&=(fl[i][b]==fr[i][b]);
        }
    }
    char ans=0;
    for(int s=0;s<bin3[n+1];s++) apply(ans,f[0][n][0][s]);
    printf("%d\n",int(ans>=0?ans:ans+p));
}
 
int main(){
    if(!ReadData()){
        puts("0");
        return 0;
    }
    InitBin3(n);
    InitComb(p);
    DP();
    return 0;
}
```

