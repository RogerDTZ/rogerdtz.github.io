---
title: 取石子
mathjax: true
date: 2019-04-17 09:10:12
tags: [数据结构---线段树,模拟]
---

# Description

有两堆石子，初始石子数分别为$X$和$Y$

给定一个长度为$N$的数组$a_i$

你会顺序执行$N$次操作，按顺序编号为$1 \dots N$：

* 在编号为奇数的操作中，你会从第二堆中拿取$a_i$个石子放入第一堆。若第二堆的石子数不足$a_i$，就将第二堆的剩余石子都放入第一堆
* 在编号为偶数的操作中，你会从第一堆中拿取$a_i$个石子放入第二堆。若第一堆的石子数不足$a_i$，就将第一堆的剩余石子都放入第二堆

你的目标是求出$N$次操作完成后第一堆石子的数量

你还需要支持$Q$次修改操作，每次操作可能会修改$X,Y,a_i$中的一种。请在每次修改后给出原问题的答案

$N,Q \le 5 \times 10^5$

<!-- more -->

# Solution

不妨设两堆石子的初始数量分别为$X+Y$和$0$，令$a_0=Y$，再令偶数项都变为其相反数，则$a_i$就是第$i$次操作中第一堆石子数的变化值，这样我们就只需要模拟第一堆石子的数量。在操作过程中，该变量需要对$0$取$\max$，对$X+Y$取$\min$

注意到如果波动过大，则变量在之前是什么就毫无意义了。具体来说，若存在一个区间$[l,r]$，满足$[l,r]$区间前缀和的极差不小于$X+Y$，那么不管变量在第$l$次操作前是什么值，第$r$次操作完成后结果都是相同的

这个问题实际上是：如果右边满足条件，我就直接递归右边，否则递归左边，然后快速计算右边。因此我们考虑在线段树上解决这个问题

对于区间$[l,r]$，我们的目的是计算一个值$x$在经过$[l,r]$后的结果，简记为$f(l,r,x)$（答案即$f(1,n,X+Y)$）

如果右区间区间前缀和极差不小于$X+Y$，则直接返回$f(mid+1,r,any)$即可，其中$any$可以是$[0,X+Y]$的任意一个值

否则，我们先计算$x'=f(l,mid,x)$，然后考虑快速计算$f(mid+1,r,x')$。注意到存在一个值区间$[a,b]$，满足若$x' \in [a,b]$，则$x'$在变化过程中完全不受边界约束；若$x'<a$，则结果与$a$相同；若$x'>b$，则结果与$b$相同。于是我们只需要维护区间的前缀最大值、前缀最小值以及区间和，就可以快速得出$a,b$，并$O(1)$计算$f(mid+1,r,x')$

单次模拟的复杂度显然是$O(\log N)$的，因此总复杂度为$O(Q \log N)$

# Summary

<!-- summary_start -->

上下摆动并对边界取$\max$和$\min$的问题，注意利用好"归一"性质，即

* 若摆动过大，结果会完全相同
* 否则存在一个值区间$[l,r]$，满足若代入值属于$[l,r]$，则摆动过程中其不受边界影响；若代入值小于$l$或大于$r$，则结果与$l$或$r$相同

<!-- summary_end -->

# Code

```c++
#include <cstdio>
typedef long long LL;
const int N=500000+10;
inline LL max(LL x,LL y){
	return x>y?x:y;
}
inline LL min(LL x,LL y){
	return x<y?x:y;
}
namespace IO{
	const int LEN=20000000;
	char *inBuf,*inPtr;
	char *outBuf,*outPtr;
	void Init(){
		inBuf=new char[LEN];
		outBuf=outPtr=new char[LEN];
	}
	void Load(){
		fread(inBuf,1,LEN,stdin);
		inPtr=inBuf;
	}
	void Flush(){
		fwrite(outBuf,1,outPtr-outBuf,stdout);
	}
	char GetChar(){
		return *(inPtr++);
	}
	void PutChar(char c){
		*(outPtr++)=c;
	}
	int GetInt(){
		int x=0,f=1;
		char c=GetChar();
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=GetChar();}
		while('0'<=c&&c<='9'){x=x*10+c-'0';c=GetChar();}
		return x*f;
	}
	void PutInt(LL x,char end='\n'){
		if(x==0){
			PutChar('0');
		}else{
			if(x<0){
				PutChar('-');
				x=-x;
			}
			static int digit[100],len;
			for(len=0;x;x/=10) digit[++len]=x%10;
			for(;len;len--) PutChar('0'+digit[len]);
		}
		PutChar(end);
	}
}
int n,q;
int x,y;
int a[N];
void ReadData(){
	using IO::GetInt;
	n=GetInt(); q=GetInt();
	x=GetInt(); y=GetInt();
	a[1]=-y;
	n++;
	for(int i=2;i<=n;i++){
		a[i]=GetInt();
		if(i&1)
			a[i]=-a[i];
	}
}
namespace Seg{
	const int SIZE=(::N)*2;
	struct Node{
		int ch[2];
		LL mx,mn,sum;
	}a[SIZE];
	int nodeCnt;
	int rt;
	void Pushup(int u){
		a[u].mn=min(a[a[u].ch[0]].mn,a[a[u].ch[0]].sum+a[a[u].ch[1]].mn);
		a[u].mx=max(a[a[u].ch[0]].mx,a[a[u].ch[0]].sum+a[a[u].ch[1]].mx);
		a[u].sum=a[a[u].ch[0]].sum+a[a[u].ch[1]].sum;
	}
	void Build(int &u,int l,int r){
		u=++nodeCnt;
		if(l==r){
			a[u].sum=::a[l];
			a[u].mx=max(0,::a[l]);
			a[u].mn=min(0,::a[l]);
			return;
		}
		int mid=(l+r)>>1;
		Build(a[u].ch[0],l,mid);
		Build(a[u].ch[1],mid+1,r);
		Pushup(u);
	}
	void Modify(int u,int l,int r,int pos,int val){
		if(l==r){
			a[u].sum=val;
			a[u].mx=max(0,val);
			a[u].mn=min(0,val);
			::a[l]+=val;
			return;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)
			Modify(a[u].ch[0],l,mid,pos,val);
		else
			Modify(a[u].ch[1],mid+1,r,pos,val);
		Pushup(u);
	}
	LL Query(int u,int l,int r,LL val){
		if(l==r)
			return max(0,min(x+y,val+a[u].sum));
		int mid=(l+r)>>1;
		if(a[a[u].ch[1]].mx-a[a[u].ch[1]].mn>=x+y){
			return Query(a[u].ch[1],mid+1,r,0);
		}else{
			val=Query(a[u].ch[0],l,mid,val);
			LL vl=max(0,-a[a[u].ch[1]].mn);
			LL vr=min(x+y,x+y-a[a[u].ch[1]].mx);
			val=max(vl,min(vr,val));
			return val+a[a[u].ch[1]].sum;
		}
	}
}
void AnswerQuery(){
	using IO::GetInt;
	using IO::PutInt;
	for(int i=1;i<=q;i++){
		int opt,u,v;
		opt=GetInt();
		switch(opt){
			case 1: u=GetInt();
					x=u;
					break;
			case 2: u=GetInt();
					Seg::Modify(Seg::rt,1,n,1,-u);
					y=u;
					break;
			case 3: u=GetInt(); v=GetInt();
					Seg::Modify(Seg::rt,1,n,u+1,((u+1)&1)?-v:+v);
					break;
		}
		PutInt(Seg::Query(Seg::rt,1,n,x+y));
	}
}
int main(){
	IO::Init();
	IO::Load();
	ReadData();
	Seg::Build(Seg::rt,1,n);
	AnswerQuery();
	IO::Flush();
	return 0;
}
```

