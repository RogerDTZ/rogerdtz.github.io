---
title: 函树
mathjax: true
date: 2019-04-27 08:20:08
tags: [DP---树形DP,推式子,数论---莫比乌斯反演,数论---欧拉函数,可做未做]
---

# Description

有一棵$n$个节点的树

定义$D(u,v)$为$u$到$v$的最短路径经过的边数

求
$$
\sum_{i=1}^n\sum_{j=1}^n \varphi(ij)D(i,j)
$$
$N \le 10^5$

<!-- more -->

# Solution

先考虑如何处理$\varphi(ij)$：若有一个整数$x$及其质因数分解$x=\prod_i p_i^{q_i}$，则$\varphi(x)=\prod_i (p_i-1)p_i^{q_i-1}​$，那么
$$
\varphi(ij)=\varphi(i)\varphi(j){F(\gcd(i,j))}
$$
其中$F(x)$表示$\prod_i \frac{p_i}{p_i-1}$，$p_i$枚举的是$x$含有的质因子。$F(x)$可在线性筛中方便处理

开始推式子：
$$
\begin{aligned}
&\sum_{i=1}^n \sum_{j=1}^n \varphi(i)\varphi(j)F(\gcd(i,j))d(i,j) \\
=&\sum_{d=1}^nF(d)\sum_{i=1}^{\lfloor\frac nd\rfloor} \sum_{j=1}^{\lfloor\frac nd\rfloor}\varphi(id)\varphi(jd)D(id,jd)[\gcd(i,j)=1] \\
=&\sum_{d=1}^nF(d)\sum_{i=1}^{\lfloor\frac nd\rfloor} \sum_{j=1}^{\lfloor\frac nd\rfloor}\varphi(id)\varphi(jd)D(id,jd)\sum_{e\mid i}\sum_{e \mid j}\mu(e) \\
=&\sum_{d=1}^nF(d)\sum_{e=1}^{\lfloor \frac nd \rfloor}\mu(e)\sum_{i=1}^{\lfloor \frac {n}{de} \rfloor}\sum_{j=1}^{\lfloor \frac {n}{de} \rfloor}\varphi(ide)\varphi(jde)D(ide,jde)\\
=&\sum_{d=1}^nF(d) \sum_{e=1}^{\lfloor \frac nd \rfloor}\mu(e)G(de)
\end{aligned}
$$
观察$G(x)$：
$$
G(x)=\sum_{i=1}^{\lfloor \frac nx \rfloor}\sum_{j=1}^{\lfloor \frac nx \rfloor}\varphi(ix)\varphi(jx)D(ix,jx)
$$
相当于只考虑编号被$x​$整除的那些点，两两求值，贡献为$\varphi(u)\varphi(v)D(u,v)​$。可以建虚树后线性求解

考虑先计算完$G(1)\dots G(n)$，然后就可以调和级数计算答案。计算$G$时涉及到的总点数也是调和级数，加上排序的$\log$，总时间复杂度是$O(n \log^2 n)$，也可以通过优化排序做到$O(n \log n)$

# Code

```c++
#include <cstdio>
#include <algorithm>

#define INV(x) FastPow(x,MOD-2)

using std::sort;

typedef long long LL;

const int MOD=998244353;
const int N=100000+10;

int FastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}

int n;
int D[N];

namespace Sieve{
	const int R=(::N);
	int p[R],pcnt;
	bool no[R];
	int mu[R],phi[R];
	int sp[R];
	void main(int n){
		mu[1]=1;
		sp[1]=1;
		phi[1]=1;
		for(int i=2;i<=n;i++){
			if(!no[i]){
				p[++pcnt]=i;
				mu[i]=-1;
				sp[i]=1ll*i*INV(i-1)%MOD;
				phi[i]=i-1;
			}
			for(int j=1;j<=pcnt&&i*p[j]<=n;j++){
				int x=i*p[j];
				no[x]=true;
				if(i%p[j]==0){
					mu[x]=0;
					phi[x]=phi[i]*p[j];
					sp[x]=sp[i];
					break;
				}else{
					mu[x]=-mu[i];
					phi[x]=phi[i]*(p[j]-1);
					sp[x]=1ll*sp[i]*p[j]%MOD*INV(p[j]-1)%MOD;
				}
			}
		}
	}
}
namespace Tree{
	const int N=(::N);
	int h[N],tot;
	struct Edge{
		int v,next;
	}e[N*2];
	int dep[N];
	int pre[N];
	int dfnTimer,dfn[N][2];
	int size[N];
	int son[N];
	int locCnt,who[N],loc[N],top[N];
	void AddEdge(int u,int v){
		e[++tot]=(Edge){v,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,h[v]}; h[v]=tot;
	}
	void DissectionDFS1(int u,int fa){
		dfn[u][0]=++dfnTimer;
		pre[u]=fa;
		dep[u]=dep[fa]+1;
		size[u]=1;
		son[u]=0;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa){
				DissectionDFS1(v,u);
				size[u]+=size[v];
				if(!son[u]||size[v]>size[son[u]])
					son[u]=v;
			}
		dfn[u][1]=dfnTimer;
	}
	void DissectionDFS2(int u,int _top){
		top[u]=_top;
		locCnt++;
		who[locCnt]=u;
		loc[u]=locCnt;
		if(!son[u])
			return;
		DissectionDFS2(son[u],top[u]);
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=pre[u]&&v!=son[u])
				DissectionDFS2(v,v);
	}
	void Dissection(){
		DissectionDFS1(1,0);
		DissectionDFS2(1,1);
	}
	int GetLCA(int a,int b){
		for(;top[a]!=top[b];dep[top[a]]>dep[top[b]]?a=pre[top[a]]:b=pre[top[b]]);
		return dep[a]<dep[b]?a:b;
	}
}
namespace VT{
	using Tree::N;
	using Tree::dep;
	using Tree::dfn;
	using Tree::GetLCA;
	int h[N],tot;
	struct Edge{
		int v,w,next;
	}e[N*2];
	bool imp[N];
	void AddEdge(int u,int v){
		int w=dep[v]-dep[u];
		e[++tot]=(Edge){v,w,h[u]}; h[u]=tot;
		e[++tot]=(Edge){u,w,h[v]}; h[v]=tot;
	}
	bool CmpDFN(const int &x,const int &y){
		return dfn[x][0]<dfn[y][0];
	}
	void Build(int m,int *a){
		for(int i=1;i<=m;i++) imp[a[i]]=true;
		sort(a+1,a+m+1,CmpDFN);
		static int sta[N],top;
		sta[top=1]=1;
		for(int i=(a[1]==1?2:1);i<=m;i++){
			int lca;
			while(top>0){
				lca=GetLCA(a[i],sta[top]);
				if(top>=2&&dep[lca]<dep[sta[top-1]]){
					AddEdge(sta[top-1],sta[top]);
					top--;
				}else if(dep[lca]<dep[sta[top]]){
					AddEdge(lca,sta[top]);
					top--;
					break;
				}else{
					break;
				}
			}
			if(sta[top]!=lca)
				sta[++top]=lca;
			sta[++top]=a[i];
		}
		for(;top>1;top--)
			AddEdge(sta[top-1],sta[top]);
	}
	LL s[N],f[N],g[N];
	LL ans;
	void DP1(int u,int fa){
		s[u]=(imp[u]?Sieve::phi[u]:0);
		f[u]=0;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa){
				DP1(v,u);
				(f[u]+=f[v]+e[i].w*s[v])%=MOD;
				(s[u]+=s[v])%=MOD;
			}
	}
	void DP2(int u,int fa){
		if(imp[u])
			(ans+=(f[u]+g[u])*Sieve::phi[u])%=MOD;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa){
				g[v]=((g[u]+f[u]-(f[v]+e[i].w*s[v]))+(e[i].w*(s[1]-s[v])))%MOD;
				DP2(v,u);
			}
	}
	int Calc(){
		ans=0;
		DP1(1,0);
		DP2(1,0);
		return ans;
	}
	int nodeLis[N],lisCnt;
	void ClearDFS(int u,int fa){
		nodeLis[++lisCnt]=u;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa)
				ClearDFS(v,u);
	}
	void Reset(){
		lisCnt=0;
		ClearDFS(1,0);
		for(int i=1;i<=lisCnt;i++){
			int u=nodeLis[i];
			h[u]=0;
			imp[u]=false;
		}
		tot=0;
	}
}
void ReadData(){
	scanf("%d",&n);
	for(int i=1;i<n;i++){
		int u,v;
		scanf("%d%d",&u,&v);
		Tree::AddEdge(u,v);
	}
}
void CalcD(){
	for(int d=1;d<=n;d++){
		static int arr[N],acnt;
		acnt=0;
		for(int u=d;u<=n;u+=d) arr[++acnt]=u;
		VT::Build(acnt,arr);
		D[d]=VT::Calc();
		VT::Reset();
	}
}
void Calc(){
	int ans=0;
	for(int d=1;d<=n;d++){
		int sum=0;
		for(int i=1;i<=n/d;i++)
			(sum+=Sieve::mu[i]*D[i*d])%=MOD;
		sum=1ll*sum*Sieve::sp[d]%MOD;
		(ans+=sum)%=MOD;
	}
	printf("%d\n",ans>=0?ans:ans+MOD);
}

int main(){
	Sieve::main(100000);
	ReadData();
	Tree::Dissection();
	CalcD();
	Calc();
	return 0;
}
```

