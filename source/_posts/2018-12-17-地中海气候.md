---
layout: post
mathjax: true
title: 地中海气候
date: 2018-12-17 20:50:00
tag: [数据结构---维护题]
---
# Description

　　给一个长度为$n$的数组$a$

　　有$q$组询问，每次询问给出一个参数$p$。请模拟以下过程

1. 初始时，可重集合$S$包含了$a_1\dots a_p$
2. A和B将轮流执行以下操作，A先手
   1. 从$S$中拿走最大值，累加进自己的得分。若$S$已经为空，则游戏结束
   2. 如果$p<n$，将$p$加一，并将$a_p$加入$S$
3. 请输出A与B的得分之差

　　$n\le 10^5,\ q \le \min(2000,n)$，时间限制3s



　　
<!-- more -->
# Solution

　　记当前所有元素的最大值为$top$，再记一个数组$cnt[i]$，表示在目前集合种元素$i$出现的次数。弹出最大值$top$后，令$cnt[top]$减一，并找到最大的、$cnt$非零的值作为新的$top$

　　考虑加入一个元素$x$会带来那些影响：

* 若$x \ge top$，它在下一次操作就会立刻被弹出，我们没有将其加入集合并维护$cnt$和$top$的必要。我们可以开一个缓冲变量储存$x$，以后弹最大值时优先考虑缓冲变量，若没有缓冲变量再考虑$top$
* 若$x <top$，我们直接令$cnt[top]$加一即可，$top$不需要变化

　　时间复杂度$O(nq)$

　　这种方法仅在权值范围较小且弹出加入配套时才奏效，扩展空间不广，但在维护思路上具有很好的启发意义

　　　　

# Summary

　　多利用题目的操作特殊性、单一性来解决传统问题的加强版

　　维护题不一定要按传统问题的思路来走



# Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;
const int N=100010;
int n,m;
int a[N];
int b[N];
void readData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[a[i]]++;
    }
}
LL solve(int p){
    static int c[N];
    memset(c,0,sizeof c);
    int top=0;
    for(int i=1;i<=p;i++){
        c[a[i]]++;
        top=max(top,a[i]);
    }
    LL res=0,buf=-1;
    for(int i=1;i<=n;i++){
        if(buf!=-1){
            res+=((i&1)?1:-1)*buf;
            buf=-1;
        }
        else{
            res+=((i&1)?1:-1)*top;
            c[top]--;
            while(top&&!c[top]) top--;
        }
        if(p<n){
            p++;
            if(a[p]>=top)
                buf=a[p];
            else
                c[a[p]]++;
        }
    }
    return res;
}
void answerQuery(){
    int p;
    for(int i=1;i<=m;i++){
        scanf("%d",&p);
        printf("%lld\n",solve(p));
    }
}
int main(){
    readData();
    answerQuery();
    return 0;
}
```

