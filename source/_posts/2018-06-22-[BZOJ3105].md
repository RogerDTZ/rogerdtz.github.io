---
layout: post
title: 【BZOJ3105】
date: 2018-06-22
mathjax: true
category: BZOJ
tag: [博弈论,线性基,贪心]
---
# Description

　　传统的Nim游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。

​	　　本题的游戏稍微有些不同：在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。

​	　　如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。



## Input

​	　　第一行为整数$k（k\le1000)$。即火柴堆数。第二行包含$k$个不超过$10^9$的正整数，即各堆的火柴个数。 

## Output

​	　　输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出-1。 

## Sample Input 

​	　　6  

​	　　5 5 6 6 5 5  

## Sample Output

​	　　21


<!-- more -->
# Solution

​	　　Nim游戏先手必胜的条件是所有每一堆的数量异或和不为0。那么我们现在所要做的，是保留一个集合$S$，使得这个集合的每一个子集异或和都不为0。这样，不论对手从这个集合中删去哪些子集，剩余的元素异或和都不为0。同时，我们要使得删去的元素尽可能小，即选择保留的元素尽可能大。所以，我们的目的其实是构造一组权值最大的线性基。

​	　　我们按照每一堆的火柴数$a_i$从大到小来贪心，尝试将它加入一个线性基中。如果成功加入，则视之为$S$中的元素；否则，则视为被舍弃的元素，统计入答案中。

​	　　这样，我们就可以构造出一组权值最大的线性基。

​	　　至于为什么贪心是正确的，不会出现舍弃权值较大的元素来让某些权值较小的元素顺利加入线性基这种决策，可能要用到拟阵证明，这个坑慢慢补吧。但是貌似如此的线性基的带权问题，大概都可以套用贪心的方法，应该是得益于拟阵的相似证明。



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int N=105;
int	n,a[N];	
long long ans;
namespace LB{
	const int B=30;
	int a[B];
	bool insert(int x){
		for(int i=B-1;i>=0;i--)
			if(x&(1<<i)){
				if(a[i]) x^=a[i];
				else{a[i]=x;break;}
			}
		return x;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	sort(a+1,a+1+n);
	for(int i=n;i>=1;i--)
		if(!LB::insert(a[i])) ans+=a[i];
	printf("%lld\n",ans);
	return 0;
}
```

