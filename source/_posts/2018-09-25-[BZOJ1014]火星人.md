---
layout: post
title: 【BZOJ1014】火星人
date: 2018-09-25 16:45:00
category: BZOJ
tag: [字符串---哈希,数据结构---平衡树]
---
# Description

　　[题目链接](https://www.lydsy.com/JudgeOnline/problem.php?id=1014)

　　大意是给一个字符串，支持单点修改字符、插入一个字符，以及询问两个后缀的LCP


<!-- more -->
# Solution

　　为什么我想半天想不到呢？因为我总想着用后缀数组的思想去维护了。一上场就去想后缀平衡树之类的东西、想怎么维护一段字符的排名，等等等等

　　既然这样往后缀数组的方向想行不通，那么我们要从LCP的匹配来考虑

　　直接枚举肯定是不行的，那么就采用倍增（然后我就想到了什么波兰表的历史记录）

　　倍增什么啊，那是静态的

　　应该用二分，二分LCP的长度

　　然后每次我们只要能快速判定两端长度相同的字符串是否相等，那么就解决了这个问题

　　遇到这种字符串比较是否相等的情况，我们应该第一反应想到哈希，不要犹豫太多

　　那么用平衡树维护字符串的哈希值：插入和修改都不难，查询时二分，并查询一段字符的哈希值，判断是否相等即可

# Summary

　　自己的哈希意识太过薄弱，总往后缀数组方面想；字符串匹配问题，要么后缀数组/SAM，要么往哈希想一下。看到题后，两个方法都要过一遍

　　如果题目的操作十分复杂、显然不能用后缀数组的那一套思想进行维护时，不妨考虑哈希，将问题转化为判断两段子串是否相等的子问题，使用平衡树等数据结构支持快速回答，以此间接解决询问

# Code

```c++
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N=100010;
const ull B=133;
char str[N];
int n,curn;
ull bas[N];
inline void swap(int &x,int &y){
    x^=y^=x^=y;
}
namespace T{
    int rt,sz,dest;
    int ch[N][2],fa[N];
    int size[N],key[N];
    ull sum[N];
    inline int who(int u){
        return ch[fa[u]][1]==u;
    }
    inline void pushup(int u){
        size[u]=size[ch[u][0]]+size[ch[u][1]]+1;
        sum[u]=sum[ch[u][0]]+bas[size[ch[u][0]]]*key[u]+bas[size[ch[u][0]]+1]*sum[ch[u][1]];
    }
    inline void rotate(int u){
        int f=fa[u],g=fa[f],c=who(u);
        if(g)
            ch[g][who(f)]=u;
        fa[u]=g;
        ch[f][c]=ch[u][c^1];
        if(ch[f][c])
            fa[ch[f][c]]=f;
        ch[u][c^1]=f;
        fa[f]=u;
        pushup(f);
        pushup(u);
    }
    void splay(int u,int destfa=0){
        for(;fa[u]!=destfa;rotate(u))
            if(fa[fa[u]]!=destfa)
                rotate(who(u)==who(fa[u])?fa[u]:u);
        if(!destfa)
            rt=u;
    }
    void _insert(int &u,int f,int pos,int val){ // insert before pos
        if(!u){
            u=++sz;
            dest=u;
            fa[u]=f;
            size[u]=1;
            key[u]=val;
            pushup(u);
            return;
        }
        if(pos<=size[ch[u][0]]+1)
            _insert(ch[u][0],u,pos,val);
        else
            _insert(ch[u][1],u,pos-(size[ch[u][0]]+1),val);
        pushup(u);
    }
    void insert(int pos,int val){
        _insert(rt,0,pos,val);
        splay(dest);
    }
    void _modify(int &u,int pos,int val){ 
        if(size[ch[u][0]]+1==pos){
            dest=u;
            key[u]=val;
            pushup(u);
            return;
        }
        if(pos<=size[ch[u][0]])
            _modify(ch[u][0],pos,val);
        else
            _modify(ch[u][1],pos-(size[ch[u][0]]+1),val);
        pushup(u);
    }
    void modify(int pos,int val){
        _modify(rt,pos,val);
        splay(dest);
    }
    void _findByPos(int &u,int pos){ 
        if(size[ch[u][0]]+1==pos){
            dest=u;
            return;
        }
        if(pos<=size[ch[u][0]])
            _findByPos(ch[u][0],pos);
        else
            _findByPos(ch[u][1],pos-(size[ch[u][0]]+1));
    }
    int findByPos(int pos){
        _findByPos(rt,pos);
        splay(dest);
        return dest;
    }
    ull query(int l,int r){
        if(l==1&&r==size[rt]) // [1,curn]
            return sum[rt];
        if(l==1){
            int rr=findByPos(r+1);
            splay(rr);
            return sum[ch[rt][0]];
        }
        else if(r==size[rt]){
            int ll=findByPos(l-1);
            splay(ll);
            return sum[ch[rt][1]];
        }
        int ll=findByPos(l-1),rr=findByPos(r+1);
        splay(ll);
        splay(rr,ll);
        return sum[ch[rr][0]];
    }
}
void readData(){
    scanf("%s",str+1);
    n=strlen(str+1);
}
void initBas(){
    bas[0]=1;
    for(int i=1;i<=100000;i++)
        bas[i]=bas[i-1]*B;
}
void buildSplay(){
    for(int i=1;i<=n;i++)
        T::insert(i,str[i]-'a'+1);
}
int query(int a,int b){
    if(a>b) 
        swap(a,b);
    int l=1,r=curn-b+1,mid;
    while(l<=r){
        mid=(l+r)>>1;
        if(T::query(a,a+mid-1)==T::query(b,b+mid-1))
            l=mid+1;
        else
            r=mid-1;
    }
    return r;
}
void answerQuery(){
    curn=n;
    char opt[2];
    int q,a,b;
    scanf("%d",&q);
    while(q--){
        scanf("%s",opt);
        if(opt[0]=='Q'){
            scanf("%d%d",&a,&b);
            printf("%d\n",query(a,b));
        }
        else if(opt[0]=='R'){
            scanf("%d%s",&a,opt);
            T::modify(a,opt[0]-'a'+1);
        }
        else{
            scanf("%d%s",&a,opt);
            T::insert(a+1,opt[0]-'a'+1);
            curn++;
        }
    }
}
int main(){
    readData();
    initBas();
    buildSplay();
    answerQuery();
    return 0;
}
```

