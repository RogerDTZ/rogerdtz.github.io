---
title: 期望
mathjax: true
date: 2019-03-26 20:21:57
tags: 最小生成树
---

# Description

有一个$n​$个点$m​$条边的无向图$G​$，每条边$i​$有长度$w_i​$和价值$v_i​$两种属性

问对于$G$的所有最小生成树，树边价值之和的平均值是多少

$n\le 10^4$，$m \le 2\times 10^5$，长度相同的边不会超过30条

<!-- more -->

# Solution

考虑Kruskal求最小生成树的过程：按边权从小到大贪心地加入边。之所以最小生成树可能有不止一个，是因为相同权值的边有多种组合方式，但所有最小生成树包含的某种权值的边的数量都是相同的

事实上，我们可以按长度从小到大来考虑每一组长度相同的边。使用长度比当前长度小的所有边进行并查集缩点，可得到点集$V$，再以当前长度的所有边作为边集$E$，我们可以得到一张新图$G'=(V,E)$。原来算法中的贪心连接，现在等价于$G'$的某个生成树。因为长度更小的边在考虑时是贪心连接的，所以不论之前的边怎么连接，得到的图连通性都是一样的，而这恰恰是当前决策唯一需要的信息

我们要求的东西现在就只和$G'$的生成树数量相关了。可以利用差分计算出当前长度的某一条边$e$出现的概率，即$G'$的生成树数量减去$G''=(V,E-\left\{e\right\})$的生成树数量。这样一来，贡献也就很好求了

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <cmath>
using std::swap;
using std::fabs;
using std::sort;
typedef long double LD;
const LD EPS=1e-15;
const int N=10000+10;
const int M=200000+10;
int n,m;
struct Edge{
    int u,v;
    int w;
    int value;
    static bool CmpW(const Edge &a,const Edge &b){
        return a.w<b.w;
    }
}e[M];
namespace MatrixTree{
    const int N=60+10;
    int n;
    LD a[N][N];
    void Init(int _n){
        n=_n;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                a[i][j]=0;
    }
    void AddEdge(int u,int v){
        a[u][u]++; a[v][v]++;
        a[u][v]--; a[v][u]--;
    }
    void DelEdge(int u,int v){
        a[u][u]--; a[v][v]--;
        a[u][v]++; a[v][u]++;
    }
    LD Gaussian(int n,LD a[N][N]){
        for(int i=1;i<=n;i++){
            if(fabs(a[i][i])<EPS){
                int t=-1;
                for(int j=i+1;j<=n;j++)
                    if(fabs(a[j][i])>=EPS){
                        t=j;
                        break;
                    }
                if(t==-1)
                    return 0;
                for(int j=i;j<=n;j++) swap(a[i][j],a[t][j]);
            }
            for(int j=i+1;j<=n;j++){
                LD t=a[j][i]/a[i][i];
                for(int k=i;k<=n;k++)
                    a[j][k]-=t*a[i][k];
            }
        }
        LD res=1;
        for(int i=1;i<=n;i++) res*=a[i][i];
        return res;
    }
    LD Calc(){
        static LD t[N][N];
        for(int i=1;i<n;i++)
            for(int j=1;j<n;j++)
                t[i][j]=a[i][j];
        return Gaussian(n-1,t);
    }
}
int dsu[N];
int FindDSU(int x,int *dsu=::dsu){
    return dsu[x]==x?x:(dsu[x]=FindDSU(dsu[x],dsu));
}
void ReadData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
        scanf("%d%d%d%d",&e[i].u,&e[i].v,&e[i].w,&e[i].value);
}
void Solve(){
    for(int i=1;i<=n;i++) dsu[i]=i;
    sort(e+1,e+m+1,Edge::CmpW);
    LD ans=0;
    for(int i=1,j=1;i<=m;i=j){
        for(;j<=m&&e[j].w==e[i].w;j++);
        static int id[N],idCnt;
        static int tdsu[N];
        idCnt=1;
        tdsu[1]=1;
        for(int k=i;k<j;k++){
            int u=FindDSU(e[k].u),v=FindDSU(e[k].v);
            if(u==v)
                continue;
            if(!id[u]){
                id[u]=++idCnt;
                tdsu[idCnt]=idCnt;
            }
            if(!id[v]){
                id[v]=++idCnt;
                tdsu[idCnt]=idCnt;
            }
            int fu=FindDSU(id[u],tdsu),fv=FindDSU(id[v],tdsu);
            if(fu!=fv)
                tdsu[fu]=fv;
        }
        MatrixTree::Init(idCnt);
        for(int i=2;i<=idCnt;i++)
            if(FindDSU(i,tdsu)==i)
                MatrixTree::AddEdge(1,i);
        for(int k=i;k<j;k++){
            int u=FindDSU(e[k].u),v=FindDSU(e[k].v);
            if(u==v)
                continue;
            MatrixTree::AddEdge(id[u],id[v]);
        }
        LD way=MatrixTree::Calc();
        for(int k=i;k<j;k++){
            int u=FindDSU(e[k].u),v=FindDSU(e[k].v);
            if(u==v)
                continue;
            u=id[u]; v=id[v];
            MatrixTree::DelEdge(u,v);
            LD way1=MatrixTree::Calc();
            MatrixTree::AddEdge(u,v);
            ans+=(way-way1)/way*e[k].value;
        }
        for(int k=i;k<j;k++){
            int u=FindDSU(e[k].u),v=FindDSU(e[k].v);
            id[u]=id[v]=0;
            if(u!=v)
                dsu[u]=v;
        }
    }
    printf("%.5lf\n",double(ans));
}
int main(){
    ReadData();
    Solve();
    return 0;
}
```

