---
layout: post
mathjax: true
title: 社保
date: 2018-12-17 09:55:00
tag: [图论---强连通分量,图论---拓扑序,好题]
---
# Description

　　给定一张$n$个点、$m$条边的有向图$G(V,E)$

　　定义$G^T$为将$G$中所有边反向后得到的图

　　记在图$G_0$中$u$可达的点构成的集合为$S(G_0,u)$

　　对于每一个点$u$，请判断其是否满足$S(G,u)\cup S(G^T,u)=V$

　　$n,m \le 10^6$




<!-- more -->
# Solution

　　显然先对原图Tarjan缩点，得到一张DAG。于是问题变为判定每一个点$u$是否能在原DAG或反向DAG中到达其余所有点

　　考虑不合法点的性质：对于一个点$u$，若存在一条边数大于1的路径，其起点位于$u$的上游、终点位于$u$的下游，且中途经过的点不位于$u$的上下游，则路径上除了端点的其余所有点与$u$都是并行关系，无法互达，也就意味着$u$和那些点不合法

　　”并行“的概念令我们联想到了拓扑序中“同层”的概念，是否可以利用拓扑序来解决判定呢？

　　考虑DAG的拓扑序：由于能到达$u$的点的拓扑序一定在$u$之前，且$u$能到达的点的拓扑序一定在$u$之后，则一个点$u$合法，当且仅当拓扑序在$u$前的所有点都能到达$u$，且$u$能到达所有拓扑序在它之后的点，有任何疏漏都将导致不合法

　　下面先给出一种做法：

　　在正向DAG中，对于一个点$u$，记其出边到达点中拓扑序最小的为$v$，则$(top_u,top_v)$之中的所有点全部不合法；在反向DAG中，对于一个点$u$，记其出边到达点中拓扑序最大的为$v$，则$(top_v,top_u)$之中的所有点全部不合法。使用差分标记即可做到$O(n)$的复杂度

　　为什么这样是对的？

　　对于一个不合法的点$u$，若我们将$u$在正反DAG中能到达的点在拓扑序上染黑，则拓扑序中必然存在一些白点。考虑$u$之后的第一个白点$x$，它在反向DAG里出边到达点拓扑序最大的$v$，其拓扑序一定在$u$之前；若$v$拓在$u$和$x$之间，则意味着在正向DAG中$u$能先到达$v$再到达$x$，矛盾。同理，$u$之前的第一个白点$x$在正向DAG里出边到达点拓扑序最小的$v$，其拓扑序一定在$u$之后。综上，一个不合法的点$u$总是会在算法执行到某一个最近的白点时被标记

　　

# Code

```c++
#include <cstdio>
#include <queue>
using namespace std;
namespace IO{
    const int L=50000000;
    char inBuf[L];
    int inPos=0;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
const int INF=1e9;
const int N=1000010;
const int M=1000010;
int n,m;
namespace G{
    int h1[N],h2[N],h3[N],tot;
    struct Edge{
        int v,next;
    }e[N*3];
    int oriCnt,oriEdge[M][2];
    void addEdge(int u,int v,int *h=h1){
        e[++tot]=(Edge){v,h[u]}; h[u]=tot;
        if(h==h1){
            oriCnt++;
            oriEdge[oriCnt][0]=u;
            oriEdge[oriCnt][1]=v;
        }
    }
    int dfn[N],low[N],dfnTimer;
    int bcnt,bel[N];
    int in[N];
    int topLis[N],topPos[N];
    void TarjanDfs(int u){
        static int sta[N],top=0;
        static bool inStack[N];
        dfn[u]=low[u]=++dfnTimer;
        sta[++top]=u; inStack[u]=true;
        for(int i=h1[u],v;i;i=e[i].next){
            v=e[i].v;
            if(!dfn[v]){
                TarjanDfs(v);
                low[u]=min(low[u],low[v]);
            }
            else if(inStack[v])
                low[u]=min(low[u],dfn[v]);
        }
        if(dfn[u]==low[u]){
            bcnt++;
            int x;
            do{
                x=sta[top--];
                inStack[x]=false;
                bel[x]=bcnt;
            }while(x!=u);
        }
    }
    void Tarjan(){
        for(int i=1;i<=n;i++)
            if(!dfn[i])
                TarjanDfs(i);
        for(int i=1;i<=oriCnt;i++){
            int u=oriEdge[i][0],v=oriEdge[i][1];
            if(bel[u]!=bel[v]){
                addEdge(bel[u],bel[v],h2);
                addEdge(bel[v],bel[u],h3);
                in[bel[v]]++;
            }
        }
    }
    void Topsort(){
        static queue<int> q;
        int p=0;
        for(int i=1;i<=bcnt;i++)
            if(!in[i])
                q.push(i);
        while(!q.empty()){
            int u=q.front();
            q.pop();
            topLis[++p]=u;
            topPos[u]=p;
            for(int i=h2[u],v;i;i=e[i].next){
                v=e[i].v;
                in[v]--;
                if(!in[v])
                    q.push(v);
            }
        }
    }
    int sum[N];
    void mark(){
        for(int p=1;p<=bcnt;p++){
            int u=topLis[p];
            int s=n+1;
            for(int i=h2[u],v;i;i=e[i].next){
                v=e[i].v;
                s=min(s,topPos[v]);
            }
            if(p+2<=s){
                sum[p+1]++;
                sum[s]--;
            }
            s=0;
            for(int i=h3[u],v;i;i=e[i].next){
                v=e[i].v;
                s=max(s,topPos[v]);
            }
            if(s+2<=p){
                sum[s+1]++;
                sum[p]--;
            }
        }
        for(int i=2;i<=bcnt;i++) sum[i]+=sum[i-1];
    }
}
void readData(){
    n=getInt(); m=getInt();
    int u,v;
    for(int i=1;i<=m;i++){
        u=getInt(); v=getInt();
        G::addEdge(u,v);
    }
}
void printAnswer(){
    static int ans[N],cnt;
    for(int u=1;u<=n;u++){
        if(!G::sum[G::topPos[G::bel[u]]])
            ans[++cnt]=u;
    }
    printf("%d\n",cnt);
    for(int i=1;i<=cnt;i++) printf("%d ",ans[i]);
    puts("");
}
int main(){
    IO::load();
    readData();
    G::Tarjan();
    G::Topsort();
    G::mark();
    printAnswer();
    return 0;
}
```

