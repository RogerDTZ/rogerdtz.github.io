---
title: 脑部进食
mathjax: true
date: 2019-06-25 07:53:23
tags: [字符串---KMP,概率与期望,高斯消元]
---

# Description

给一个$n$个点的自动机，初始状态是1

每次等概率选择出边转移

若走过的字符串包含$S_1$作为子串，或者包含$S_2$作为子序列，那么游戏结束

求游戏结束的期望步数

如果期望步数趋近于正无穷，输出-1

$n \le 20$，$1 \le \mid S_1 \mid \le 10$，$1 \le \mid S_2 \mid \le 50 $

<!-- more -->

# Solution

注意到$S_2$的匹配进度是逐步递增不会后退的，不妨以$S_2$的匹配进度分层考虑

设$f_{i,u,a}$表示当前$S_2$匹配了$i$位，当前状态为$u$，后缀匹配$S_1$的最长长度为$a$

设$S_2$的下一位为$c$，我们就把所有$c$的转移删除，然后进行饱和转移。每个状态$(u,a)$转移到的点$(v,a')$可以用KMP快速计算，然后对所有$O(n\mid S_1\mid)$个状态高斯消元即可

饱和转移后，强制走一次$c$

由于计算的是期望，因此采用反向转移

注意高斯消元无解并不代表步数趋近于正无穷，有可能无解的变量和答案并不相关。我们可以在主步骤开始之前直接对原图进行判断下列条件是否都成立：

1. 存在从初始状态到达结束状态的路径
2. 不存在一个初始状态能到达的状态，满足它不是结束状态且没有出边

# Code

```c++
#include <cstdio>
#include <cstring>
#include <cmath>

const double EPS=1e-15;
const double DINF=1e30;
const int C=26;
const int N=20+5;
const int L1=10+5;
const int L2=50+5;
const int O=N*L1;

inline void swap(double &x,double &y){
	static double t=0;
	t=x; x=y; y=t;
}

int n,m;
int l1,l2;
char s1[L1],s2[L2];
int trans[N][C],tot[N];
int o,ind[N][L1],who[O][2];
int go[L1][C];
double f[O];

void ReadData(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		int u,v;
		char c[2];
		scanf("%d%d%s",&u,&v,c);
		trans[u][c[0]-'a']=v;
		tot[u]++;
	}
	scanf("%s%s",s1+1,s2+1);
	l1=strlen(s1+1);
	l2=strlen(s2+1);
}

bool reach,exist;
bool vis[N][L1][L2];

void DFS(int u,int a,int b){
	if(vis[u][a][b])
		return;
	vis[u][a][b]=true;
	if(a==l1||b==l2){
		reach=true;
		return;
	}
	bool have=false;
	for(int c=0;c<C;c++)
		if(trans[u][c]){
			have=true;
			int na=go[a][c];
			int nb=b+(c==s2[b+1]-'a');
			DFS(trans[u][c],na,nb);
			if(exist)
				return;
		}
	if(!have&&a<l1&&b<l2)
		exist=true;
}

bool LYY_ZERO(){
	reach=exist=false;
	DFS(1,0,0);
	return !(reach&&!exist);
}

void KMP(){
	static int nex[L1];
	nex[1]=0;
	for(int i=2;i<=l1;i++){
		int j;
		for(j=nex[i-1];j&&s1[j+1]!=s1[i];j=nex[j]);
		nex[i]=(s1[j+1]==s1[i])?j+1:0;
	}
	go[0][s1[1]-'a']=1;
	for(int i=1;i<=l1;i++)
		for(int c=0;c<C;c++)
			go[i][c]=(s1[i+1]-'a'==c)?i+1:go[nex[i]][c];
}

void InitIDMap(){
	o=0;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=l1;j++){
			o++;
			ind[i][j]=o;
			who[o][0]=i; who[o][1]=j;
		}
}

void Gaussian(int n,double a[O][O],double *out){
    for(int i=1;i<n;i++){
        if(fabs(a[i][i])<EPS){
            int t=i;
            for(int j=i+1;j<=n;j++)
                if(fabs(a[j][i])>fabs(a[t][i]))
                    t=j;
            if(fabs(a[t][i])>=EPS){
                for(int k=i;k<=n+1;k++) swap(a[i][k],a[t][k]);
            }else{
                continue;
            }
        }
        for(int j=i+1;j<=n;j++){
            double t=a[j][i]/a[i][i];
            for(int k=i;k<=n+1;k++) a[j][k]-=t*a[i][k];
        }
    }
    for(int i=n;i>=1;i--){
        for(int j=i+1;j<=n;j++)
            a[i][n+1]-=a[i][j]*out[j];
        if(a[i][i]>EPS)
            out[i]=a[i][n+1]/a[i][i];
        else
			out[i]=0;
    }
}

void Work(int ban){
	static double mat[O][O];
	for(int i=1;i<=o;i++)
		for(int j=1;j<=o+1;j++)
			mat[i][j]=0;
	for(int i=1;i<=o;i++){
		int u=who[i][0],a=who[i][1];
		mat[i][i]+=1;
		if(a<l1){
			mat[i][o+1]+=1+f[i];
			for(int c=0;c<C;c++)
				if(c!=ban&&trans[u][c])
					mat[i][ind[trans[u][c]][go[a][c]]]-=(1.0/tot[u]);
		}
	}
	Gaussian(o,mat,f);
}

void Calc(){
	for(int b=l2-1;b>=0;b--){
		int c=s2[b+1]-'a';
		static double tmp[O];
		for(int i=1;i<=o;i++) tmp[i]=f[i];
		for(int i=1;i<=o;i++){
			int u=who[i][0],a=who[i][1];
			f[i]=0;
			if(a<l1&&trans[u][c])
				f[i]=(1.0/tot[u])*tmp[ind[trans[u][c]][go[a][c]]];
		}
		Work(c);
	}
	double ans=f[ind[1][0]];
	printf("%.10lf\n",ans);
}

int main(){
	ReadData();
	KMP();
	if(LYY_ZERO()){
		puts("-1");
	}else{
		InitIDMap();
		Calc();
	}
	return 0;
}
```

