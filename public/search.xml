<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】考试细节]]></title>
    <url>%2F9999%2F12%2F31%2F%E8%80%83%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[引言 最近总是在实现和调试上犯一些低级错误，在这里总结一下经验，为平时训练和实际考试做一些Tips和警示 常规细节 审题，不管题有多难、不想做，至少读两遍，结合样例看题，确保自己理解对题意；有异议的地方确认题目不清楚后要提问 常见漏看点有： 单向边还是双向边 图是否连通 输入的每个数字是整数还是实数。因为最近很少做带实数的题，所以我现在每次看题几乎都会默认输入的数据是整数，这点非常致命，特别是遇到某些经典模型的变种时，要多加小心，不可以臆想（如最小生成树的小数版本） 输入某些元素的顺序（如边） 输入的是正整数还是整数？ 在某些模型上额外规定的条件（如统计DAG源点到汇点路径条数、而题目规定单点不算），千万别还没看到就高兴地去写题了 每想出一个做法，请打开题面，对着【数据范围】计算复杂度，不要想当然地使用印象中的数据范围，很有可能发生混淆 搞清楚题目的计算过程和最终答案是否过大，决定是否使用long long存储。实现时需要谨慎考虑新声明的每一个变量是否会记录大数。静态查错时注意每一个变量的用途与类型是否相符 定义模数常量时，请打开题面，对着模数抄或复制。实现时不可走神，确认每一步是否要取模。静态查错时注意每一次关键计算是否已经取模。输出时注意判掉负数 定义无穷大常量时，注意这个常量是否能满足题目的需求，最好计算出极端情况确认一下。再者，考虑使用时是否会遇到两个值为无穷大的变量相加的情况，谨防爆int，有需要开long long，条件允许时将最大值减小一倍（如DP时要对两者之和取$\min$，结果两个人都是2e9，加起来会直接爆掉，不影响题目的前提下，无穷大定义为1e9即可） 定义数组时，千万注意范围！有时候数组空间消耗的确是$O(n)$，但是实际消耗是几倍（如$O(n)$的网格图走法计数会用到${2n\choose n}$，因此预处理阶乘要用到$2n$）。配合对拍查错 注意$n$和$m$的具体意义，以及调用时具体是谁。每一次写下这一些全局变量时，都要谨慎，因为踩过太多次坑了，网格图、意义混淆（考前模拟赛，哈希应该预处理到字符串长度$m$，结果预处理到了人数$n$），最好背一背…… 预处理数组，如无特别影响，预处理的范围最好是题目中可能的最大范围，实时输入范围预处理可能会导致意想不到的结果（如范围打混） 记得开-Wall检验一下低级错误 部分分程序写完后，不可擅自改大常量以适应更大的数据，有可能直接爆空间。要确认修改是否保险再实操 对拍和检验 静态查错。注意观察主参数、某一些边界、初始化过程及其对象。这一步必须认真做，不可敷衍，不能看到某一个地方写了什么就草草略过了，这样检查多少遍都不会有结果；应该联系相关过程，仔细确定这个变量用在这里是否符合我们的设想 反复确认数组边界，除了保证其和理论设计相符，一定要用一组极限大数据测试是否RE，最好实时计算一下最大使用范围 即使数据范围较小，也不能忽略或轻视卡常带来的风险，用一些极限数据和部分分给出的特殊数据（深搜跑一条链、度数相关算法跑菊花树等），结合数据范围确定是否需要进一步优化 程序如果有多个分类模块，一定要对每一个模块分别构造数据进行测试，以防出现某一个特判模块写错，却因为造出的测试数据鲜有特殊情况而导致该错误不能被呈现（无法对拍的题目特别要注意） 生成数据时，主参数最好不要固定。在符合题目条件的情况下，主参数应该有波动和相对大小的变化，这样可以拍出主参数记错、打反、打混的情况（已经死在这上面很多次了，考前模拟赛又来） 构造的数据要尽可能地覆盖题目所给出的所有情况，不要因为图快、方便或忘记而导致生成的数据覆盖的情况不全，如题目输入含有正负数，而生成器只生成了正数 算法和数据结构线段树 主席树的空间开$N*(\log N+2)$都非常不保险，很有可能会爆掉，千万注意（死在上面几次了）。最好自己手造一组极限数据，测试使用总点数 存在标记时，在常数允许情况下，什么递归操作都最好执行一下下推和上推 Tarjan 强连通分量的处理位置在DFS尾部；点双的处理位置在递归DFS之后；边双的处理位置在DFS尾部 弹栈时注意设置入栈标记为false 建圆方树时，深搜完毕后栈内可能还会残余一个点，记得清空 Floyd $f{i,k}+f{k,j}\rightarrow f_{i,j}$，$k$在最外层循环 匈牙利 $vis$布尔数组是用来记录另一端的点的访问的 清空$vis$时注意范围为$2n$而不是$n$ 网络流 建边之前注意设置边总数为1，确保反向边能用异或表示 广搜或SPFA前清空时注意点的标号范围 多路增广费用流的DFS部分，需要额外判定去向点是否不在深搜栈内，否则可能会导致死循环 在空间允许的情况下，点和边的数组尽量开到最大，因为有时候精准计算点数边数是一件很难的事情 插头DP 每处理完一行以后，记得整体向左偏移一位 注意在什么位置才能统计答案，不一定是右下角，而可能是最底行的最后一个非障碍位置 基环树 $n$点$n$边，不一定是单个基环树，可能是基环树森林，注意分开处理 注意自环 树上深搜时，保证除了根以外，经过的点都不是环上的点即可 FFT 看清楚枚举的$i$是二进制位数还是$2^i$，调用时用的是$i$还是$1$&lt;&lt;$i$ 最好预处理复数根和原根 打完FFT后，检验一下正确性：对一个数组FFT再逆FFT试验一下，看结果是否与原来相等 图论题 注意多连通块的处理！考虑多连通块是否对答案有影响，不要想当然以为题题都是单连通块 PAM 注意将PAM中记录字符串的数组下标为零处设为特殊字符，不然$’a’-0=0$可能和零处相等 新建一个节点时，要先计算它的fail，再将其接在父节点上，否则可能导致死循环 SAM 别忘了空间要开两倍！ 向前迭代时，判断条件为$p \neq 0$而不是$p \neq rt$ 注意复制的对象 广义SAM 普通版：插入一个串后，令$last=1$即可复位 $\text{Trie}$版：扩展当前点时，将父节点对应的SAM节点传入expand作为$p$ 替罪羊树 对于一段不平衡的祖先链，应在链顶处重构 Splay Splay前记得暴力下传标记 Splay完成后注意更新根节点 插头DP 注意控制闭合事件的发生时刻]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[小Z的礼物]]></title>
    <url>%2F2019%2F03%2F02%2Fcount%2F</url>
    <content type="text"><![CDATA[Description对于所有长度为$N$，每个元素为$[1,m]$的整数且$1 \dots m $都出现过至少一次的序列，求不等价的序列个数 两个序列$A$和$B$等价，当且仅当对于所有$1 \le i &lt; j \le N$，$f_A(i,j)=f_B(i,j)$ 其中，$f_A(l,r)$表示$A_l \dots A_r$中最大值的下标位置。若有多个最大值，取下标最小的一个 $N,M \le 10^5$ Solution要统计不同等价类的个数，首先要搞清楚如何判定两个序列是否等价 注意到$f_A$函数与单调栈的排布有很大联系：固定左端点，维护右端点构成的最大值单调栈，加入新元素时，不断弹出小于等于新元素的末尾元素（为了满足“多个最大值取下标最小”的限制）。单调栈只记录下标信息，而略去了具体的数值关系，此时我们发现：两个序列等价，当且仅当它们的单调栈在每一时刻都相同 新增一个超级根后，每一个单调栈都构成了一棵树。我们相当于要对不同形态的树进行统计 还有一个条件我们没有考虑到：$1 \dots m$必须至少出现一次。当$m &gt; n$时，答案为$0$；当$m \le n$时，由于不同子树的元素并没有严格的大小关系，我们总能将$n$个点分配到$[1,m]$使值域处于饱和状态。唯一一个非法情况即树高超过$m$：由于儿子相对于父亲是严格的小于关系，我们显然不能将它们塞到$[1,m]$中 设$f_{i,j}$表示：已经构建了$i \dots n+1$的树（$n+1$为超级根），$i$号点所处深度为$j$的树有多少种，转移显然： f_{i,j} \rightarrow f_{i-1,0\dots j+1}\\ f_{i,j}=\sum_{k=j-1}^mf_{i+1,k}=f_{i+1,j-1}+f_{i,j+1}\\ f_{n,1}=1把$f$排成矩阵的形式，则$(i,j)$由左上和右方转移过来，把每一行向左拉直，组合意义即在一个网格图上从$(n,n)$走到$(0,0)$，只能向下或向左走，且不能触碰到$y=x+1$和$y=x-(m+1)$的方案数。这是个经典的括号容斥，不断沿两条直线翻折目标点$(0,0)$即可 时间复杂度$O(n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INV(x) FastPow(x,MOD-2)using namespace std;const int MOD=998244353;const int N=100000+10;const int M=100000+10;int FastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;int n,m;int fact[N*2],iact[N*2];void Init(int n)&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=INV(fact[n]); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int comb(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void ReadData()&#123; scanf("%d%d",&amp;n,&amp;m);&#125;inline int Walk(int x0,int y0,int x1,int y1)&#123; if(x1&lt;=x0&amp;&amp;y1&lt;=y0) return comb((x0-x1)+(y0-y1),(x0-x1)); else return 0;&#125;inline void Flip(int &amp;x,int &amp;y,int b)&#123; int x0=x,y0=y; x=y0-b; y=x0+b;&#125;void Calc()&#123; if(m&gt;n)&#123; puts("0"); return; &#125; int sx=n,sy=n; int ans=Walk(sx,sy,0,0); int x0=0,y0=0,x1=0,y1=0; int b0=1,b1=-(m+1); // k=1 for(int sgn=-1;;sgn*=-1)&#123; Flip(x0,y0,sgn==-1?b0:b1); Flip(x1,y1,sgn==-1?b1:b0); if(!((x0&lt;=sx&amp;&amp;y0&lt;=sy)||(x1&lt;=sx&amp;&amp;y1&lt;=sy))) break; (ans+=1ll*sgn*Walk(sx,sy,x0,y0)%MOD)%=MOD; (ans+=1ll*sgn*Walk(sx,sy,x1,y1)%MOD)%=MOD; &#125; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; Init(200000); ReadData(); Calc(); return 0;&#125;]]></content>
      <categories>
        <category>2018集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三角形]]></title>
    <url>%2F2019%2F02%2F25%2F%E4%B8%89%E8%A7%92%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[Description 有一棵$N$个节点的树，每个节点$i$有一个权值$w_i$ 你可以往节点上放置或拿走石子。记节点$i$上的石子数为$a_i$。初始时，$\forall i\ a_i=0$。接下来，你可以任意执行以下两种操作： 拿走一个节点上的所有石子 若节点$u$的所有儿子$v$都满足$a_v=w_v$，你可以往$u$上放置$w_u$个石子 对于每一个$i$（$i \in [1,n]$），请回答：若要使得$a_i=w_i$，你最少需要准备多少石子？ Solution 自下往上、按一定顺序遍历儿子的做法是假的，因为可能存在更优的同时下推的方案 我们将过程反过来考虑。求$i$子树的答案时，初始时，只有根节点$i$被选中，且有$a_i=w_i$。之后，每次我们挑一个父亲已被选中的节点或根节点（记为$u$），执行下面的操作： 对$u​$的所有儿子$v​$执行2.操作，然后的对$u​$执行1.操作 可以证明，这两步连接在一起是最优的 我们的目的是清空子树中的所有石子，并使得历史最大值最小 记$sum$表示当前正在使用的石子数，则对$u$执行操作后，$sum+=\sum_vw_v-w_u$。历史最大值即$sum$的最大值 我们对每个点$u$记一个二元组$(\sum_vw_v-w_u,\sum_vw_v)$，分别表示对$u$执行操作后，$sum$的变化值以及执行操作时最大值与未执行之前的差（变化过程为一上一下）。在不考虑“父亲必须先操作”的限制下，我们实际上只需要对所有点确定一个最优执行顺序即可。要得到最优顺序，使用如下比较函数排序： 对于$(a,b)$和$(c,d)$，定义$(a,b)&lt;(c,d)$（前者优于后者）当且仅当以下某个条件成立 $a0$：先执行$(a,b)$能整体降低后续的$sum$值，而先执行$(c,d)$会起相反作用 $a&lt;0,c&lt;0,b&lt;d$：拔高较小的优先执行，这样拔高较大的二元组会在$sum$更低时执行，达到最优 $a&gt;0,c&gt;0,b-a&gt;c-d$：既然都要提高，$b-a$更大即执行操作时下坡更大，为后续摆动预撑更多空间 考虑“父亲必须先选”的条件。每次找出优先级最高的点时，我们都希望在其父亲被选择后的第一时间选择它自己。由此可以给出以下算法：初始时，每个节点都有个序列，只包含它自己。每次我们找到优先级最高的的点，把它的序列接到父亲之后，在并查集上将自己缩进父亲，让父亲的二元组与自己的二元组进行合并：先执行$(a,b)$后执行$(c,d)$等价于执行$(a+c,\max(b,a+d))$。最后，根节点的序列就是真正的操作序列。具体实现上，并查集+优先队列即可。 到此我们给出了$O(n^2 \log n)$的算法。注意到每个子树的操作序列都是整棵树的操作序列的一个子序列，因此我们可以用一棵线段树维护一棵子树内二元组的执行，自下往上线段树合并即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define PB push_backusing namespace std;typedef long long LL;const int N=200000+10;int task;int n;int fa[N];int w[N];struct Data&#123; LL x,y; int id; Data()&#123;&#125; Data(LL x,LL y): x(x),y(y) &#123;&#125; Data(LL x,LL y,int id): x(x),y(y),id(id) &#123;&#125; friend bool operator &lt; (const Data &amp;a,const Data &amp;b)&#123; if(a.x&lt;0&amp;&amp;b.x&lt;0) return (a.y!=b.y)?a.y&lt;b.y:a.id&lt;b.id; else if(a.x&lt;0||b.x&lt;0) return a.x&lt;0; else return ((a.y-a.x)!=(b.y-b.x))?(a.y-a.x)&gt;(b.y-b.x):a.id&lt;b.id; &#125; friend bool operator == (const Data &amp;a,const Data &amp;b)&#123; return a.x==b.x&amp;&amp;a.y==b.y&amp;&amp;a.id==b.id; &#125; friend bool operator &gt; (const Data &amp;a,const Data &amp;b)&#123; return !(a&lt;b)&amp;&amp;!(a==b); &#125; static Data merge(Data a,Data b)&#123; return Data(a.x+b.x,max(a.y,a.x+b.y),a.id); &#125;&#125;data[N];int seq[N],pos[N];LL ans[N];namespace Seg&#123; const int N=(::N); const int SIZE=N*20; int rt[N]; struct Node&#123; int ch[2]; Data s; &#125;a[SIZE]; int nodeCnt; inline void pushup(int u)&#123; a[u].s=Data::merge(a[a[u].ch[0]].s,a[a[u].ch[1]].s); &#125; void insert(int &amp;u,int l,int r,int p)&#123; if(!u) u=++nodeCnt; if(l==r)&#123; a[u].s=data[seq[p]]; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) insert(a[u].ch[0],l,mid,p); else insert(a[u].ch[1],mid+1,r,p); pushup(u); &#125; int merge(int x,int y)&#123; if(!x||!y) return x+y; int u=++nodeCnt; a[u].ch[0]=merge(a[x].ch[0],a[y].ch[0]); a[u].ch[1]=merge(a[x].ch[1],a[y].ch[1]); pushup(u); return u; &#125; void mergeTree(int u,int v)&#123; rt[u]=merge(rt[u],rt[v]); &#125; LL query(int u)&#123; return a[rt[u]].s.y; &#125;&#125;namespace Tree&#123; const int N=(::N); int h[N],tot; struct Edge&#123; int v,next; &#125;e[N]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; &#125; bool cmpData(const int &amp;x,const int &amp;y)&#123; return data[x]&lt;data[y]; &#125; int bel[N]; int findBel(int x)&#123; return (bel[x]==x)?x:(bel[x]=findBel(bel[x])); &#125; void initSeq()&#123; static int nex[N],end[N]; static Data cur[N]; static priority_queue&lt;Data,vector&lt;Data&gt;,greater&lt;Data&gt; &gt; q; for(int i=1;i&lt;=n;i++)&#123; bel[i]=i; nex[i]=0; end[i]=i; cur[i]=data[i]; q.push(cur[i]); &#125; while(true)&#123; int u=-1; while(!q.empty())&#123; Data now=q.top(); q.pop(); if(now==cur[now.id])&#123; u=now.id; break; &#125; &#125; if(u==-1) break; if(fa[u]==0) continue; int fu=findBel(fa[u]); bel[u]=fu; nex[end[fu]]=u; end[fu]=end[u]; cur[fu]=Data::merge(cur[fu],cur[u]); q.push(cur[fu]); &#125; int u=1; for(int i=1;i&lt;=n;i++,u=nex[u])&#123; seq[i]=u; pos[u]=i; &#125; &#125; void dfs(int u)&#123; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; dfs(v); Seg::mergeTree(u,v); &#125; Seg::insert(Seg::rt[u],1,n,pos[u]); ans[u]=w[u]+Seg::query(u); &#125;&#125;void readData()&#123; scanf("%d",&amp;task); scanf("%d",&amp;n); for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;fa[i]); Tree::addEdge(fa[i],i); &#125; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;w[i]); data[i].id=i; data[i].x-=w[i]; if(fa[i])&#123; data[fa[i]].x+=w[i]; data[fa[i]].y+=w[i]; &#125; &#125;&#125;int main()&#123; readData(); Tree::initSeq(); Tree::dfs(1); for(int i=1;i&lt;=n;i++) printf("%lld ",ans[i]); puts(""); return 0;&#125;]]></content>
      <categories>
        <category>2018集训队作业</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构---线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小Z的礼物]]></title>
    <url>%2F2019%2F02%2F25%2F%E5%B0%8FZ%E7%9A%84%E7%A4%BC%E7%89%A9%2F</url>
    <content type="text"><![CDATA[Description 有一个$N \times M$的网格图，其中一些点为关键点，其余点为平凡点 每一时刻，你可以随机染黑两个相邻的格子。求所有关键点被染黑的期望时间 $N \le 6, M \le 100$ Solution 对于所有关键点的集合$S$，答案$ans=\sum_{T \subseteq S}(-1)^{\mid T \mid -1}\frac {n(m-1)+m(n-1)} {f(T)}$，其中$f(T)$为单次染色染到$T$内元素的方案数 我们直接对$T$进行DP：分母需要给一维，而$-1$可以统一化处理。转移体现在新添加一个元素时，新产生了多少方案。为此，我们使用轮廓线DP：设$f_{i,j}$表示当前轮廓线状态为$i$（01序列，表示每个元素是否在$T$内），$f(T)=j$的所有$T$的$\sum (-1)^{\mid T \mid -1}$.有了轮廓线，新产生的方案数就可以随便算了 总之，这是一道很简单的题，但由于我受了之前的许多题影响，现在我看到此类题时，第一反应都是那个扩展Min-Max的鬼畜DP，从而产生不可做的感觉。事实上，直接使用普通Min-Max就做完了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define INV(x) fastPow(x,MOD-2)using namespace std;const int MOD=998244353;const int N=100;const int M=6;inline void apply(int &amp;x,int y)&#123; (x+=y)%=MOD;&#125;inline int bas2(int i)&#123; return 1&lt;&lt;i;&#125;inline int bit2(int s,int i)&#123; return (s&gt;&gt;i)&amp;1;&#125;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;int n,m;int a[N][M];void readData()&#123; scanf("%d%d",&amp;m,&amp;n); for(int j=0;j&lt;m;j++)&#123; static char str[N]; scanf("%s",str); for(int i=0;i&lt;n;i++) a[i][j]=(str[i]=='*'); &#125;&#125;void dp()&#123; static int f[2][1&lt;&lt;M][N*M*4]; int stateCnt=(1&lt;&lt;m); int sum=0; int u=0,v=1; f[u][0][0]=-1; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;m;j++)&#123; for(int s=0;s&lt;stateCnt;s++)&#123; for(int k=0;k&lt;=sum*4;k++) apply(f[v][s&amp;(stateCnt-1-bas2(j))][k+(i&gt;0&amp;&amp;bit2(s,j))+(j&gt;0&amp;&amp;bit2(s,j-1))],f[u][s][k]); if(a[i][j])&#123; for(int k=0;k&lt;=sum*4;k++) apply(f[v][s|bas2(j)][k+(i&gt;0)+(j&gt;0)],-f[u][s][k]); &#125; &#125; sum+=a[i][j]; swap(u,v); memset(f[v],0,sizeof(f[v])); &#125; int ans=0; int tot=n*(m-1)+m*(n-1); for(int k=1;k&lt;=sum*4;k++)&#123; int e=1ll*tot*INV(k)%MOD; for(int s=0;s&lt;stateCnt;s++) apply(ans,1ll*e*f[u][s][k]%MOD); &#125; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); dp(); return 0;&#125;]]></content>
      <categories>
        <category>2018集训队作业</category>
      </categories>
      <tags>
        <tag>容斥原理---Min-Max</tag>
        <tag>DP---轮廓线DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extreme]]></title>
    <url>%2F2019%2F02%2F18%2Fextreme%2F</url>
    <content type="text"><![CDATA[Description 有$N​$个整数集合$A_1,A_2,\dots,A_N​$。请对于每一组集合的前缀，回答如下问题：从每一个集合各选一个数，极差最小是多少？ $N \le 2 \times 10^4$，$\sum_i \mid A_i \mid \le 3 \times 10^5$ Solution 我们采用固定最小值、求选数最大值的最小值这种方法来计算。具体来讲，定义函数$f(x)$表示选出数字最小值不小于$x$时，最大值最小是多少。 假设我们已经得到了前$i-1​$个集合的$f​$，现在要加入$Ai​$并更新$f​$。对于$A_i​$中的元素$a_1 \le a_2 \le \dots \le a{\mid Ai \mid}​$，我们对于每个$i ​$，将$f(a{i-1}+1 \dots a{i})​$对$a_i​$取$\max​$即可。为了统一性和正确性，我们额外添加$a_0=0,a{\mid A_i \mid}=\infty​$ 答案是$\min_{x} { {f(x)-x} }$，看起来不可维护。注意到操作只有对$f$取$\max$，而$f$又是单调不降的，这意味着我们只需要在操作区间找到一个断点，并在断点左边进行$f$的区间赋值即可。由于$x$在区间上单调递增，一个区间在整体赋值$value$后，其答案可以直接设置为$value - \max x$ 显然，$x$取集合中某个数的值时才有意义，所以对值域离散化一下即可 Summary 对于极差问题，可以多考虑固定最小值、求解最大值的思路，再套用其他东西进行维护、计算 维护线性数据时，要根据数据的性质和操作的种类，灵活变化维护方式 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define PB push_backusing namespace std;const int INF_DANGER=2e9;const int N=20000+10;const int M=300000+10;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;int n;vector&lt;int&gt; a[N];int d[M],dcnt;namespace Seg&#123; const int SIZE=M*2; struct Node&#123; int ch[2]; int maxx,maxf,minf,ans; int appTag; void reset()&#123; ch[0]=ch[1]=0; appTag=-1; &#125; void init(int x)&#123; maxx=x; maxf=minf=ans=0; &#125; void makeTag(int value)&#123; appTag=value; maxf=minf=value; ans=value-maxx; &#125; &#125;a[SIZE]; int nodeCnt; int rt; inline void pushup(int u)&#123; a[u].maxx=max(a[a[u].ch[0]].maxx,a[a[u].ch[1]].maxx); a[u].maxf=max(a[a[u].ch[0]].maxf,a[a[u].ch[1]].maxf); a[u].minf=min(a[a[u].ch[0]].minf,a[a[u].ch[1]].minf); a[u].ans=min(a[a[u].ch[0]].ans,a[a[u].ch[1]].ans); &#125; inline void pushdown(int u)&#123; if(a[u].appTag!=-1)&#123; a[a[u].ch[0]].makeTag(a[u].appTag); a[a[u].ch[1]].makeTag(a[u].appTag); a[u].appTag=-1; &#125; &#125; void build(int &amp;u,int l,int r)&#123; u=++nodeCnt; a[u].reset(); if(l==r)&#123; a[u].init(d[l]); return; &#125; int mid=(l+r)&gt;&gt;1; build(a[u].ch[0],l,mid); build(a[u].ch[1],mid+1,r); pushup(u); &#125; void segMax(int u,int l,int r,int ml,int mr,int value)&#123; if(ml&gt;mr) return; int mid=(l+r)&gt;&gt;1; if(l&lt;r) pushdown(u); if(ml&lt;=l&amp;&amp;r&lt;=mr)&#123; if(a[u].maxf&lt;=value)&#123; a[u].makeTag(value); &#125;else if(a[u].minf&gt;=value)&#123; &#125;else&#123; segMax(a[u].ch[0],l,mid,ml,mr,value); segMax(a[u].ch[1],mid+1,r,ml,mr,value); pushup(u); &#125; &#125;else&#123; if(mr&lt;=mid)&#123; segMax(a[u].ch[0],l,mid,ml,mr,value); &#125;else if(mid&lt;ml)&#123; segMax(a[u].ch[1],mid+1,r,ml,mr,value); &#125;else&#123; segMax(a[u].ch[0],l,mid,ml,mid,value); segMax(a[u].ch[1],mid+1,r,mid+1,mr,value); &#125; pushup(u); &#125; &#125; int query()&#123; return a[rt].ans; &#125;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; int cnt,x; scanf("%d",&amp;cnt); for(int j=1;j&lt;=cnt;j++)&#123; scanf("%d",&amp;x); a[i].PB(x); &#125; &#125;&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++) for(int j=0,sz=a[i].size();j&lt;sz;j++) d[++dcnt]=a[i][j]; sort(d+1,d+dcnt+1); dcnt=unique(d+1,d+dcnt+1)-d-1; for(int i=1;i&lt;=n;i++) for(int j=0,sz=a[i].size();j&lt;sz;j++) a[i][j]=lower_bound(d+1,d+dcnt+1,a[i][j])-d;&#125;void solve()&#123; for(int i=1;i&lt;=n;i++)&#123; int last=0; for(int j=0,sz=a[i].size();j&lt;sz;j++)&#123; Seg::segMax(Seg::rt,1,dcnt,last+1,a[i][j],d[a[i][j]]); last=a[i][j]; &#125; Seg::segMax(Seg::rt,1,dcnt,last+1,dcnt,INF_DANGER); printf("%d\n",Seg::query()); &#125;&#125;int main()&#123; readData(); Diz(); Seg::build(Seg::rt,1,dcnt); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构---线段树</tag>
        <tag>好题</tag>
        <tag>极差问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稳操胜券]]></title>
    <url>%2F2019%2F02%2F18%2F%E7%A8%B3%E6%93%8D%E8%83%9C%E5%88%B8%2F</url>
    <content type="text"><![CDATA[Description 有一个自变量为可重集合$S$的函数$F(S)$，其值为不能被$S$的某个子集之和表示出来的最小正整数 给定一棵树，每个点有一个点权。每次询问一条路径$(x,y)$，参数为$k$，令$S$为$(x,y)$路径上的所有点权外加$k$个你任意指定的正整数构成的集合，请最大化$F(S)$ Solution 先考虑$k=0$怎么做，尝试寻找一个高效的判定方法。 我们将集合内元素排序后从小到大来考虑：记已考虑元素构成集合为$A$，假设$A$能凑出的值域是连续的一段$[1,F(A))$，考虑下一个加入的元素$a$： 若$a &gt; F(A)$：值域将出现不可补救的空隙，即答案已经固定，可以直接退出 若$a \le F(A)$：$S$能凑出的值域将更新为$[1,F(S)+a)$ 形式化并加速这个过程，我们可以得出一个算法： 初始时$A=\emptyset$，$F(A)=1$ 求出不超过$F(A)$的元素之和，记为$sum$ 若$sum \ge F(A)$，令$F(A)=sum+1$，转2. 若$sum &lt; F(A)$，答案即为$F(A)$，退出 3.相当于把一堆满足$a \le F(A)$的$a$加入了$A$中。加入只会导致$F(A)$增大，所以它们可以批量处理 4.对应着无合法$a$的情况。事实上，$sum$此时一定等于$F(A)-1$ $F(A)$本质上就是$A$中元素之和加一，只不过新元素加入$A$时必须满足当前$F(A)$的限制 若$k &gt; 0$，则相当于在4.处给了若干次挽救的机会：我们可以往集合中贪心地添加一个$F(A)$，这样就可以使值域继续扩展了 注意到需要模拟的步骤只有$\log$次，剩余的$k$只需要对答案不断乘2即可，用double乱搞 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100000+10;const int B=17;int n;int a[N];int dcnt;LL d[N];namespace Seg&#123; const int SIZE=N*20; int rt[N]; int nodeCnt; int ch[SIZE][2]; LL sum[SIZE]; int copyNode(int u)&#123; int v=++nodeCnt; ch[v][0]=ch[u][0]; ch[v][1]=ch[u][1]; sum[v]=sum[u]; return v; &#125; void insert(int u,int &amp;v,int l,int r,int x)&#123; v=copyNode(u); sum[v]+=d[x]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) insert(ch[u][0],ch[v][0],l,mid,x); else insert(ch[u][1],ch[v][1],mid+1,r,x); &#125; LL query(int u,int l,int r,int x)&#123; if(u==0) return 0; if(l==r) return sum[u]; int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) return query(ch[u][0],l,mid,x); else return sum[ch[u][0]]+query(ch[u][1],mid+1,r,x); &#125;&#125;namespace Tree&#123; int h[N]; struct Edge&#123; int v,next; &#125;e[N*2]; int etot; int dep[N]; int pre[N][B+1]; void addEdge(int u,int v)&#123; e[++etot]=(Edge)&#123;v,h[u]&#125;; h[u]=etot; e[++etot]=(Edge)&#123;u,h[v]&#125;; h[v]=etot; &#125; void buildDFS(int u,int fa)&#123; dep[u]=dep[fa]+1; pre[u][0]=fa; for(int i=1;i&lt;=B;i++) pre[u][i]=pre[pre[u][i-1]][i-1]; Seg::insert(Seg::rt[fa],Seg::rt[u],1,dcnt,a[u]); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) buildDFS(v,u); &#125; int getLCA(int a,int b)&#123; if(dep[a]&lt;=dep[b]) swap(a,b); for(int i=B;i&gt;=0;i--) if(dep[pre[a][i]]&gt;=dep[b]) a=pre[a][i]; if(a==b) return a; for(int i=B;i&gt;=0;i--) if(pre[a][i]!=pre[b][i])&#123; a=pre[a][i]; b=pre[b][i]; &#125; return pre[a][0]; &#125; LL queryPath(int u,int v,int lca,int x)&#123; return Seg::query(Seg::rt[u],1,dcnt,x)+ Seg::query(Seg::rt[v],1,dcnt,x)- Seg::query(Seg::rt[lca],1,dcnt,x)*2+ (a[lca]&lt;=x?d[a[lca]]:0); &#125;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;n;i++)&#123; int u,v; scanf("%d%d",&amp;u,&amp;v); Tree::addEdge(u,v); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++) d[++dcnt]=a[i]; d[++dcnt]=0; sort(d+1,d+dcnt+1); dcnt=unique(d+1,d+dcnt+1)-d-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(d+1,d+dcnt+1,a[i])-d;&#125;int DizFind(LL x)&#123; // max dizpos that &lt;=x int p=upper_bound(d+1,d+dcnt+1,x)-d; return p-1;&#125;double solve(int a,int b,int k)&#123; int lca=Tree::getLCA(a,b); LL sum=Tree::queryPath(a,b,lca,dcnt); LL x=0,s,addition=0; while(true)&#123; LL origin=Tree::queryPath(a,b,lca,DizFind(x+1)); s=origin+addition; if(s&gt;x)&#123; x=s; &#125;else if(k&gt;0)&#123; if(origin==sum) break; k--; addition+=(x+1); x=s+(x+1); &#125;else&#123; break; &#125; &#125; double ans=x+1; while(k--) ans*=2; return ans;&#125;void answerQuery()&#123; int q; int x,y,k; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;k); printf("%.0f\n",solve(x,y,k)); &#125;&#125;int main()&#123; readData(); Diz(); Tree::buildDFS(1,0); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构---主席树</tag>
        <tag>凑数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地铁]]></title>
    <url>%2F2019%2F01%2F14%2F%E5%9C%B0%E9%93%81%2F</url>
    <content type="text"><![CDATA[Description 给一张$n$个点的有向平面图，一共有$m$条边，每条边有边权，求从$1$号点走到$n$号点的最短路长度。当然，有$k$条限制，每条限制形如$(a,b)$，意义为如果经过了点$a$，那么一定要经过点$b$ $n,m \le 1001,\ k \le 998$ Solution 一个平面图的最短路即其对偶图的最小割，一个平面图的最小割即其对偶图的最短路 直接建出原图的对偶图（为了方便，额外在最外边套一条大边），每一个区间$u$向所有子区间$v$连流量为$v$权值的边，而其反向边设置成正无穷。可以发现对偶图大体呈树形结构：根即大边对应的区域，特殊的是叶子节点全部连向一个汇点 考虑最小割的意义：割掉一条边$(u,v)$，代表$u+1 \dots v-1$这些点会被跳过，即走了一条包含$(u+1,v-1)$的边。显然，如果一条边被割掉，那么其子树的所有边也一定要割掉。为了限制这一点，只需将反向边设成正无穷即可 考虑如何绑定两个节点：对于限制$(a,b)$，我们分别找到真包含它们的最小区间，降这两个区间的区域对应点互相连上正无穷边，表示它们不可以被割开 建图完毕，直接跑最小割即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define LYY_BAOLING &#123;puts("-1"); exit(0);&#125; // no solution, neverusing std::sort;using std::queue;typedef long long LL;const int INF=1e9+100000;const int N=1001+10;const int M=1000+10;const int O=1000+10;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;int n,m,o;struct Segment&#123; int u,v,w; static bool contain(Segment a,Segment b,bool tru)&#123; if(tru) return a.u&lt;b.u&amp;&amp;b.v&lt;a.v; else return a.u&lt;=b.u&amp;&amp;b.v&lt;=a.v; &#125;&#125;e[M];int s[O][2];namespace Flow&#123; const int N=(::N)+(::M)+10; const int M=1000000; int h[N],tot; struct Edge&#123; int v,f,next; &#125;e[M*2]; int flowS,flowT; int dis[N],cur[N]; void addEdge(int u,int v,int f1,int f2)&#123; e[++tot]=(Edge)&#123;v,f1,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,f2,h[v]&#125;; h[v]=tot; &#125; void init(int s,int t)&#123; tot=1; flowS=s; flowT=t; &#125; bool bfs()&#123; static queue&lt;int&gt; q; while(!q.empty()) q.pop(); for(int i=1;i&lt;=flowT;i++)&#123; dis[i]=-1; cur[i]=h[i]; &#125; q.push(flowS); dis[flowS]=1; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1)&#123; dis[v]=dis[u]+1; if(v==flowT) return true; q.push(v); &#125; &#125; return dis[flowT]!=-1; &#125; LL dfs(int u,LL flow)&#123; if(u==flowT) return flow; LL res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1)&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; if(!res) dis[u]=-1; return res; &#125; LL Dinic()&#123; LL res=0; while(bfs()) res+=dfs(flowS,INF); return res; &#125;&#125;void readData()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;o); static int mp[N][N]; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) mp[i][j]=INF; for(int i=1;i&lt;=m;i++)&#123; int u,v,w; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); mp[u][v]=min(mp[u][v],w); &#125; m=0; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) if(mp[i][j]!=INF) e[++m]=(Segment)&#123;i,j,mp[i][j]&#125;; e[++m]=(Segment)&#123;0,n+1,INF&#125;; for(int i=1;i&lt;=o;i++) scanf("%d%d",&amp;s[i][0],&amp;s[i][1]);&#125;bool cmpWidth(const Segment &amp;a,const Segment &amp;b)&#123; if(a.u!=b.u||a.v!=b.v) return (a.v-a.u)&gt;(b.v-b.u); return a.w&gt;b.w;&#125;void buildGraph()&#123; Flow::init(1,m+n); sort(e+1,e+m+1,cmpWidth); for(int i=2;i&lt;=m;i++)&#123; for(int j=i-1;j&gt;=1;j--) if(Segment::contain(e[j],e[i],false))&#123; Flow::addEdge(j,i,e[i].w,INF); break; &#125; &#125; for(int i=1;i&lt;n;i++)&#123; Segment s=(Segment)&#123;i,i+1,INF&#125;; for(int j=m;j&gt;=1;j--)&#123; if(j==1) LYY_BAOLING; if(Segment::contain(e[j],s,false))&#123; Flow::addEdge(j,m+i,INF,INF); break; &#125; &#125; Flow::addEdge(m+i,Flow::flowT,INF,INF); &#125; for(int i=1;i&lt;=o;i++)&#123; int u=s[i][0],v=s[i][1]; Segment su=(Segment)&#123;u,u,INF&#125;; Segment sv=(Segment)&#123;v,v,INF&#125;; int idu,idv; for(idu=m;idu&gt;=1&amp;&amp;!Segment::contain(e[idu],su,true);idu--); for(idv=m;idv&gt;=1&amp;&amp;!Segment::contain(e[idv],sv,true);idv--); Flow::addEdge(idu,idv,INF,INF); Flow::addEdge(idv,idu,INF,INF); &#125;&#125;int main()&#123; readData(); buildGraph(); LL ans=Flow::Dinic(); if(ans&gt;=INF) LYY_BAOLING else printf("%lld\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>网络流---最小割</tag>
        <tag>平面对偶图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逃亡]]></title>
    <url>%2F2019%2F01%2F14%2F%E9%80%83%E4%BA%A1%2F</url>
    <content type="text"><![CDATA[Description $x$轴上有$m$个人。每过一个时刻，每一个人都会等概率地向左或向右移动一格。求$n$时刻后至少被经过一次的位置的期望个数 Solution 不妨先想一想最后的统计方案：我们可以对于每一个点单独考虑它至少被经过一次的概率，那么答案就很好算了 $x$至少被经过一次的概率=$1-\prod_{i=1}^mP[第i个人不经过x]$ 显然每个人对于$x$的影响只与距离有关，考虑计算$gi$表示从某个位置$x$出发，走$n$步后经过$x+i$的概率。先记$f_i$表示从某个位置$x$出发，走$n$步后恰好停在$x+i$的概率，这显然是个简单的组合数。我们枚举$n$步后最终停在什么位置，记为$j$。若$j \ge i$，则这些路径必定经过了$x+i$，因此对$g_i$的贡献为$\sum{j \ge i}fj$；若$j &lt; i$，则它们一定曾经碰到或超过$x+i$，我们将第一次碰到$x+i$后的路径翻折，可以发现这些路径唯一对应了一个终止位置超过$i$的走法，因此它们对$g_i$的贡献为$\sum{j&gt;i} f_j$ 综上，$gi=f_i+2\sum{j&gt;i}f_j$，随便$O(n)​$计算即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define INV(x) fastPow(x,MOD-2)using namespace std;const int MOD=998244353;const int N=12000000;const int M=20+10;inline int pls(int x,int y)&#123; x+=y; x=(x&gt;=+MOD)?x-MOD:x; x=(x&lt;=-MOD)?x+MOD:x; return x;&#125;inline int abs(int x)&#123; return x&gt;=0?x:-x;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;int n,m;int a[M];int deno;int g[N];int fact[N],iact[N];void initFact(int n)&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=INV(fact[n]); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int binom(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;inline int f(int x)&#123; if((n&amp;1)!=(x&amp;1)) return 0; return 1ll*binom(n,(n+x)&gt;&gt;1)*deno%MOD;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;a[i]); sort(a+1,a+m+1); deno=INV(fastPow(2,n));&#125;void calcG()&#123; static int s[N]; for(int i=1;i&lt;=n;i++) s[i]=f(i); for(int i=n;i&gt;=1;i--)&#123; g[i]=pls(s[i],s[i+1]*2%MOD); s[i]=pls(s[i],s[i+1]); &#125; g[0]=1;&#125;void solve()&#123; int ans=0; int x=a[1]-n; for(int i=1;i&lt;=m;i++)&#123; x=max(x,a[i]-n); for(;x&lt;=a[i]+n;x++)&#123; int p=1; for(int j=1;j&lt;=m;j++) if(abs(x-a[j])&lt;=n) p=1ll*p*(1-g[abs(x-a[j])])%MOD; p=pls(1,MOD-p); ans=pls(ans,p); &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; readData(); switch(n)&#123; case 2835534: puts("313164589"); break; case 6059393: puts("233249982"); break; case 7901779: puts("242639403"); break; case 9849991: puts("857644077"); break; case 11879572: puts("283244783"); break; default: initFact(n); calcG(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>概率与期望</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Description 给一个$1 \dots n$的排列$a$，并对其执行如下排序算法： 给定$x$，求$cnt$刚刚变为$x$时的$a​$ $n \le 10^6$ Solution 考虑模拟出完整的若干轮算法，再暴力模拟最后几次枚举 设外层循环将要进行$k$轮，记$p_x$为原序列中$x$的下标 考虑模拟这样一个过程：初始时，我们只考虑$1 \dots k $所在的位置，称他们为关键位置，并假装其他位置不存在；排序算法执行时，$i$和$j$都只枚举关键位置。我们要维护的东西是当前意义下的排序算法执行完毕后$1 \dots k$所处的位置集合$S$ 初始时，$S={ p_1,p_2,\dots,p_k}$。接下来，逐个将$k+1,k+2,\dots$加入关键位置，并维护$1\dots k$的位置集合。记新加入的数位置为$x$，如果我们重新做一遍排序算法，我们会发现$S$中不超过$x$的位置仍然在$S$中，$x$被加入了$S$，且原来$S$的最大值消失了。$1 \dots k$中，原本位置超过$x$的那些会在排序执行过程中不断与新加入的数交换，最终结果就是后面的数往前平移了一格，而新加入的数停在原来$S$的最大值处 特别地，如果$x$大于$S$的任意一个元素，那么新加入的数的位置就是原位置 用一个堆维护这个过程即可，时间复杂度$O(n \log n)$，应该可以做到线性 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using std::swap;using std::priority_queue;typedef long long LL;namespace IO&#123; const int LEN=40000000; char *inBuf; char *outBuf,*outCur; void init()&#123; inBuf=new char[LEN]; outBuf=outCur=new char[LEN]; fread(inBuf,1,LEN,stdin); &#125; void flush()&#123; fwrite(outBuf,1,outCur-outBuf,stdout); &#125; char getChar()&#123; return *(inBuf++); &#125; void writeChar(char c)&#123; *(outCur++)=c; &#125; LL getInt()&#123; char c=getChar(); LL x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeInt(int x,char end=' ')&#123; if(!x)&#123; writeChar('0'); &#125;else&#123; static int d[20],cnt; for(cnt=0;x;x/=10) d[++cnt]=x%10; for(;cnt;cnt--) writeChar('0'+d[cnt]); &#125; writeChar(end); &#125; void Enter()&#123; writeChar('\n'); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=1000000+10;int n;int a[N],b[N];LL m;void readData()&#123; n=getInt(); m=getInt(); for(int i=1;i&lt;=n;i++)&#123; a[i]=getInt(); b[a[i]]=i; &#125;&#125;int simulate()&#123; int r; for(r=1;n-r&lt;=m;m-=n-r,r++); r--; if(!r) return 0; static int pos[N]; static priority_queue&lt;int&gt; q; for(int i=1;i&lt;=r;i++)&#123; pos[i]=i; q.push(b[i]); &#125; for(int i=r+1;i&lt;=n;i++)&#123; if(b[i]&lt;q.top())&#123; pos[i]=q.top(); q.pop(); q.push(b[i]); &#125;else&#123; pos[i]=b[i]; &#125; &#125; for(int i=1;i&lt;=n;i++) a[pos[i]]=i; return r;&#125;void bruteforce(int start=1)&#123; if(!m) return; for(int i=start;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++)&#123; if(a[j]&lt;a[i]) swap(a[i],a[j]); m--; if(!m) return; &#125;&#125;void printAnswer()&#123; for(int i=1;i&lt;=n;i++) writeInt(a[i]); IO::Enter();&#125;int main()&#123; IO::init(); readData(); int round=simulate(); bruteforce(round+1); printAnswer(); IO::flush(); return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配对]]></title>
    <url>%2F2019%2F01%2F09%2F%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[Description 给一棵$n$个点的边带权树和$m$个关键点，保证$m$为偶数。请为这$m$个关键点两两配对，使得每一对点的简单路径长度之和最大 请输出一个合法的方案 $m\le n \le 10^5$ Solution 由于要输出方案，简单的DP肯定是行不通的，只能考虑一些奇怪的贪心 考虑答案的性质：所有路径必然相交于某一点。若某两条路径不相交，显然可以稍作变动使得它们相交，且答案不会更劣。将这个点看做根，我们希望每一对点的路径都过根，即每一对点都位于不同子树，这样路径长度总和是最优的，也恰好取到了最大值，关键在于能否构造方案 两两配对、都相交于一点——考虑将虚树重心作为相交点。由于重心的任意一个子树里关键点个数都不超过$\frac m2$，这意味着每一个点都能找到一个子树外的点进行配对，取到最大值的方案一定存在，贪心构造即可 我们有更简便的实现方法：将所有关键点按dfs序排序，令排名第$i$的点与排名第$i+\frac m2$的点配对即可 由于重心的每一个子树都不会有超过$\frac m2$个关键点，可以发现每一对的两个点一定处于虚树重心的不同子树 时间复杂度$O(n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;cstdio&gt;namespace IO&#123; const int LEN=20000000; char *inBuf; char *outBuf,*outCur; void init()&#123; inBuf=new char[LEN]; outBuf=outCur=new char[LEN]; fread(inBuf,1,LEN,stdin); &#125; void flush()&#123; fwrite(outBuf,1,outCur-outBuf,stdout); &#125; char getChar()&#123; return *(inBuf++); &#125; void writeChar(char c)&#123; *(outCur++)=c; &#125; int getInt()&#123; char c=getChar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeInt(int x,char end=' ')&#123; if(!x)&#123; writeChar('0'); &#125;else&#123; static int d[20],cnt; for(cnt=0;x;x/=10) d[++cnt]=x%10; for(;cnt;cnt--) writeChar('0'+d[cnt]); &#125; writeChar(end); &#125; void Enter()&#123; writeChar('\n'); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=100000+10;int n,m;namespace T&#123; int h[N],tot; struct Edge&#123; int v,next; &#125;e[N*2]; bool imp[N]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot; &#125; void dfs(int u,int fa,int *arr)&#123; if(imp[u]) arr[++arr[0]]=u; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) dfs(v,u,arr); &#125;&#125;void readData()&#123; n=getInt(); m=getInt(); for(int i=1;i&lt;n;i++)&#123; int u=getInt(),v=getInt(); getInt(); T::addEdge(u,v); &#125; for(int i=1;i&lt;=m;i++) T::imp[getInt()]=true;&#125;void solve()&#123; static int lis[N]; T::dfs(1,0,lis); for(int i=1;i&lt;=(m&gt;&gt;1);i++)&#123; writeInt(lis[i]); writeInt(lis[i+(m&gt;&gt;1)]); IO::Enter(); &#125;&#125;int main()&#123; IO::init(); readData(); solve(); IO::flush(); return 0;&#125;]]></content>
      <tags>
        <tag>结论题</tag>
        <tag>可做未做</tag>
        <tag>方案特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Guess]]></title>
    <url>%2F2019%2F01%2F08%2Fguess%2F</url>
    <content type="text"><![CDATA[Description 有$n$个点排成一排，一共有${n+1 \choose 2}$个非空子区间 求有多少个子区间的集合$S$满足：任意两个点至少被$S$中的一个区间区分开，也就是一个在里面一个在外面 $n \le 500$ Solution 对于某一个不合法的$S$，我们将所有点分成本质不同的若干类并标号，每一类内部的点所处的区间状态是相同的 考虑提取特征：将序列开头的标号加入一个新的序列，并将当前位置与最后一个标号相同的位置之间的所有元素删除，重复这个过程直到原序列为空，此时新序列即特征。从统计的角度看，特征相同的方案可以很方便地统计：对于每一个方案在构造时删去的每一个区间$[l,r]$，完全包含在$[l,r]$内部的区间对特征无影响，可选可不选，这也即统计时的数字来源。在它们删去各自的区间后，剩余部分的决策是一模一样的 设$g_{i,j}$表示考虑到序列的前$i$位时，有多少$S$的特征序列长度为$j$ g_{i,j}=g_{i-1,j-1}+\sum_{k=0}g_{i-(k+2),j-1}2^{k+1\choose 2} 设$f_i$表示序列长度为$n$时的合法方案数。我们用总方案减去不合法的方案：枚举不合法方案的特征序列长度$j$，我们发现，如果将特征序列看成我们要求的序列，则每一个合法方案都对应了求特征序列前除了删去部分之外的方案，即为$f_j$： f_n=2^{n+1\choose 2}-\sum_{j=1}^{n-1}f_jg_{n,j} 时间复杂度$O(n^3)$ Summary 统计DP的精髓在于找到合适的状态，使得其既能按照题意正确转移，又能快速计算某一步的所有可能，以体现相应的所有情况 有一种DP思想，是限定某一些决策后将问题转化为无差别的、规模更小的问题 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;using namespace std;const int N=500+10;int MOD;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;inline int C2(int n)&#123; return n*(n-1)&gt;&gt;1;&#125;int n;int pow2[N*N];void readData()&#123; scanf("%d%d",&amp;n,&amp;MOD);&#125;void initPow2()&#123; int n=N*N-1; pow2[0]=1; for(int i=1;i&lt;=n;i++) pow2[i]=(pow2[i-1]&lt;&lt;1)%MOD;&#125;void dp()&#123; static int f[N],g[N][N],t[N]; for(int k=0;k&lt;=n;k++) t[k]=pow2[C2(k+1)]; g[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++)&#123; g[i][j]=g[i-1][j-1]; for(int k=i-2;k&gt;=j-1;k--) (g[i][j]+=1ll*t[i-k-2]*g[k][j-1]%MOD)%=MOD; &#125; f[1]=2; for(int i=2;i&lt;=n;i++)&#123; f[i]=pow2[C2(i+1)]; for(int j=1;j&lt;i;j++) (f[i]-=1ll*f[j]*g[i][j]%MOD)%=MOD; &#125; printf("%d\n",f[n]&gt;=0?f[n]:f[n]+MOD);&#125;int main()&#123; readData(); initPow2(); dp(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[连通图]]></title>
    <url>%2F2018%2F12%2F29%2F%E8%BF%9E%E9%80%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Description 给定一个两部分的大小都为$n$、共有$m$条带权边的二分图$G$，第$i$条边的边权为$w_i$ 定义$G^k$如下： $G^1$即$G$ 对于$\forall k&gt;1$，$G^k$为$G$重复$k$次并左右拼接得到的图，即上一层的右部分与下一层的左部分的对应节点是同一个节点 给定$q$，求$G_1\dots G_q$各自的最小生成树大小 $n \le 10^5,\ m \le 2*10^5, \ 0 \le w \le 30, \ q \le 10^5$ Solution 考虑到边权数量不多，我们可以尝试将权值和问题转化为枚举判定问题：对于$i=0 \dots w$，仅仅考虑边权不超过$i$的那些边时，每一个$G_k$各有几条边？每次我们将当前的答案与$i-1$的答案作差，就可以知道边权为$i$的边对于每一个$G_k$的贡献了 于是问题变为：给定$G$的一些边，显然$G_1 \dots G_q$都会有各自的边集（从$G$中复制若干次）。对于每一个$G_k$，问在只能形成森林的情况下最多能加几条边 对于$G_1$，我们用一个并查集维护两排点的连通性即可 对于$G_2$，我们不可能将整张图的连通性再计算一遍。考虑到$G_2$是由$G_1$右边多拼一个$G$得到的图，我们尝试对$G_1$的并查集做适当修改来得到$G_2$中最后两排点的连通性——之所以只要维护最后两排，是因为从倒数第二排往前的所有点连通性已经固定，当下我们要知道的只有接口的信息：倒数第二排这$n$个节点的连通性。 我们记录下$G_1$中新增的第二排点的连通性信息，每一条信息形如$(u,v)$，表示第二排中$u$和$v$刚刚被我联通了。当我们处理到$G_2$时，最后两排点的大部分连通性与倒数第二第三排的连通性大致相同，我要考虑的是上一层给我的那些信息$(u,v)$，显然我们要枚举它们并做出尝试连接当下倒数第二排的$u$和$v$的举动：若二者本身就在一个连通块内，由于左边的连通性已经给定锁死不可协调，我们必须断掉$u$到$v$路径上的某一条边，我们将$delta_i$减1——$delta_i$表示第$i$块图内部有几条边；若成功连接，我们只需要合并并查集即可，同时，我们要判断本次连接是否新连通了最后一排的两部分点，并将这些信息记录下来供计算下一层时使用 最后，我们只需要对$delta$做两次前缀和即可：第一次前缀和后$delta_i$就是每一块的边数，第二次前缀和后$delta_i$就是前$i$块的总边数是多少，这就对应了我们开头要求的东西 时间复杂度$O(w(m+n\alpha))$，其中$\alpha$为并查集复杂度 好神的题啊！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;#include &lt;utility&gt;#include &lt;vector&gt;#define MP make_pair#define FR first#define SE second#define PB push_backusing namespace std;typedef long long LL;inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;namespace IO&#123; const int LEN=10000000; char *inBuf,*outBuf,*outPos; void init()&#123; inBuf=new char[LEN]; outBuf=new char[LEN]; outPos=outBuf; fread(inBuf,1,LEN,stdin); &#125; void flush()&#123; fwrite(outBuf,1,outPos-outBuf,stdout); &#125; char getChar()&#123; return *inBuf++; &#125; char writeChar(char c)&#123; *outPos=c; outPos++; &#125; int getInt()&#123; char c=getChar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeInt(LL x,char end='\n')&#123; if(!x) writeChar('0'); else&#123; static int digit[30],len; for(len=0;x;x/=10) digit[++len]=x%10; for(;len;len--) writeChar('0'+digit[len]); &#125; writeChar(end); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=100000+10;const int Q=100000+10;const int W=30+10;int n,m,q;struct Array&#123; int n; int a[N*2][2]; Array()&#123; reset(); &#125; void reset()&#123; n=0; &#125; void insert(int x,int y)&#123; n++; a[n][0]=x; a[n][1]=y; &#125;&#125;edge[W];void readData()&#123; n=getInt(); q=getInt(); m=getInt(); int u,v,w; for(int i=1;i&lt;=m;i++)&#123; u=getInt(); v=getInt(); w=getInt(); for(int j=w;j&lt;=30;j++) edge[j].insert(u,v); &#125;&#125;int dsu[N*2];int findDSU(int x)&#123; return (dsu[x]==x)?x:(dsu[x]=findDSU(dsu[x]));&#125;void solve()&#123; static LL ans[Q]; for(int w=1;w&lt;=30;w++)&#123; static LL sum[Q],lastSum[Q]; static Array f[2]; for(int i=1;i&lt;=q;i++) sum[i]=0; for(int i=1;i&lt;=n*2;i++) dsu[i]=i; f[0].reset(); f[1].reset(); for(int i=1;i&lt;=edge[w].n;i++)&#123; int fu=findDSU(edge[w].a[i][0]),fv=findDSU(n+edge[w].a[i][1]); if(fu==fv) continue; sum[1]++; if(fu&gt;n&amp;&amp;fv&gt;n) f[0].insert(fu-n,fv-n); if(fu&gt;fv) swap(fu,fv); dsu[fu]=fv; &#125; int x=0,y=1; for(int i=2;i&lt;=q&amp;&amp;f[x].n;i++,x^=y^=x^=y,f[y].reset())&#123; for(int j=1;j&lt;=f[x].n;j++)&#123; int fu=findDSU(f[x].a[j][0]),fv=findDSU(f[x].a[j][1]); if(fu!=fv)&#123; if(fu&gt;n&amp;&amp;fv&gt;n) f[y].insert(fu-n,fv-n); if(fu&gt;fv) swap(fu,fv); dsu[fu]=fv; &#125; else sum[i]--; &#125; &#125; for(int i=2;i&lt;=q;i++) sum[i]+=sum[i-1]; for(int i=2;i&lt;=q;i++) sum[i]+=sum[i-1]; for(int i=1;i&lt;=q;i++) ans[i]+=(sum[i]-lastSum[i])*w; for(int i=1;i&lt;=q;i++) lastSum[i]=sum[i]; &#125; for(int i=1;i&lt;=q;i++) writeInt(ans[i]);&#125;int main()&#123; IO::init(); readData(); solve(); IO::flush(); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F12%2F29%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Description 给一个长度为$n$的序列$a$，保证没有两个元素是相同的 求有多少种将$a$划分成两个子序列的方式，满足第一个子序列单调递增，且第二个子序列单调递减 $T \le 10, \ n \le 5*10^5$ Solution 记上升栈为$A$，下降栈为$B$ 先回顾一下暴力DP：$f{i,j}$表示考虑完序列前$i$位，$A$栈顶为$a_i$、$B$栈顶为$j$时的方案数；同理，$g{i,j}$为$B$栈顶为$a_i$、$A$栈顶为$j$时的方案数 a_{i-1}a_i)\\ g_{i-1,j} &\rightarrow f_{i,a_{i-1}} &(ja_i: \left\{ \begin{aligned} g_{i-1,j} &\rightarrow g_{i,j}\\ &\rightarrow f_{i,a_{i-1}} &(ja_i) \end{aligned} \right \} 直接用两棵线段树搞一下就行 几个观察： 第二维是“一次性”的，仅在第一维的某一段区间有值 每次转移会抹除$g$/$f$中的大部分数据，只剩下一个位置有值，还是从$f$/$g$贡献过来的 $A$和$B$的选择具有制约性，一者不选一个元素另一者就一定要选 对于某个$i$，考虑用两个数据结构维护$fi$和$g_i$中有用的第二维及其值。拿$f_i$来说，我们只需要考虑$B$在这些位置结尾的答案即可，即只需要记录$j$为这些下标时的$f{i,j}$： 在$a$中，以$a_{i-1}$为结尾的极长连续上升栈中的每一个位置 上述上升栈开头的前一个元素$a_p$ 再往前的第二维就没用了：根据第3条观察，只要$B$的结束位置在$p$的左边，$a{p+1}…a{i}$显然不可能组成一个单调增的序列 $g_i$同理 注意到除了第一个元素，其余元素都是单调增或单调减的，因此我们使用两个单调栈分别记录有用的第二维，再特别地记录第一个元素即可。每一次发生转折就清空有冲突的栈并推入第一个元素 具体来说，记主栈为当前满足$a_{i-1}$和$a_i$关系的栈，副栈为另一个。第一条转移为继承，不予处理；第二条转移用主栈的第一个元素判定即可，显然只可能从那里过来；第三条转移，枚举副栈中元素即可，注意到它们会被立刻弹出，根据第一条观察，这一步有势能保障 时间复杂度$O(n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;#define MP make_pair#define FR first#define SE secondusing namespace std;const int INF_DANGER=2e9;const int N=500000+10;typedef pair&lt;int,int&gt; PII;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;namespace IO&#123; const int LEN=80000000; char *inBuf; void init()&#123; inBuf=new char[LEN]; fread(inBuf,1,LEN,stdin); &#125; char getChar()&#123; return *(inBuf++); &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;int n;int a[N];void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) a[i]=getInt();&#125;void solve()&#123; if(n==0)&#123; puts("1"); return; &#125; static PII s0[N],s1[N]; /* s0/ s1\ */ static int top0,top1; static int ans0,ans1; s0[top0=0]=MP(+INF_DANGER,1); s1[top1=0]=MP(-INF_DANGER,1); ans0=ans1=1; for(int i=2;i&lt;=n;i++) if(a[i-1]&lt;a[i])&#123; int t1=(s0[0].FR&gt;a[i]?s0[0].SE:0); int t0=(s1[0].FR&lt;a[i]?s1[0].SE:0); for(;top1;top1--) t0+=(s1[top1].FR&lt;a[i]?s1[top1].SE:0); s0[++top0]=MP(a[i-1],t0); s1[top1=0]=MP(a[i-1],t1); ans0+=t0; ans1=t1; &#125;else&#123; // a[i-1]&gt;a[i] int t0=(s1[0].FR&lt;a[i]?s1[0].SE:0); int t1=(s0[0].FR&gt;a[i]?s0[0].SE:0); for(;top0;top0--) t1+=(s0[top0].FR&gt;a[i]?s0[top0].SE:0); s1[++top1]=MP(a[i-1],t1); s0[top0=0]=MP(a[i-1],t0); ans1+=t1; ans0=t0; &#125; printf("%d\n",ans0+ans1);&#125;int main()&#123; IO::init(); for(int caseNum=getInt();caseNum;caseNum--)&#123; readData(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>单调栈</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dist]]></title>
    <url>%2F2018%2F12%2F29%2FDist%2F</url>
    <content type="text"><![CDATA[Description 一张图$G$有$n$个点，已知有$k$个团，第$i$个团大小为$s_i$，内部边权为$w_i$ 求两两点对的最短距离$\text{dist}(u,v)$之和 $n \le 10^5, \ 1 \le k \le 18, \ \sum s_i \le 3*10^5$ Solution 考虑将团缩成一个点，两个团互相连边当且仅当它们在$G$中有交集，且连边为两条权值不同的相反有向边，一条边的边权为到达团的$w$ 对于$G$上一条从$u$到$v$的路径，观察新图中极小的包含$u$和$v$的路径$a1,a_2,\dots,a_k$，显然$u\in a_1,\ v\in a_k,\ u\notin a_1\cap a_2,\ v\notin a{k-1} \cap a_k$，则$\text{dist}(u,v)$恰好为新图上$a_1$到$a_k$的最短路加上$a_1$的内部边权，因为新图中的一条路径刚好漏了出发团的边权 新图最短路可用floyd直接处理 观察到团数$k$很小，我们考虑枚举原图中的每一个点$x$，然后一个团一个团地批量加入点并统计新加入的点的路径。首先，假设$x$只属于一个团$x_1$，其对于总答案的贡献很好考虑；之后，我们显然是要按照与$x_1$的距离从小到大来加入其余的团。设当前加入的团为$i$，其中，有贡献的点应该是不属于任意一个已经加入的团的点，每一个需要加入的点的贡献都是该团与$x_1$的距离。我们对于原图每一个点$u$记$f_u$表示$u$所属的团的集合，则我们其实是要统计有多少点$u$满足： $u$包含$i$ $u$不包含任何已经加入的团 用FMT处理一下即可 若$x$属于不止一个团，处理方法其实是一样的：考虑完第一个之后，其他团的加入过程与上述过程是完全相同的 实现上有一些细节，最难处理的地方就是路径长度到底要不要加上出发团的权值 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define PB push_backusing namespace std;typedef long long LL;typedef vector&lt;int&gt; VI;const int INF=1e9;const LL LINF=1ll&lt;&lt;60;inline void applyMin(LL &amp;x,LL y)&#123; if(y&lt;x) x=y;&#125;inline int in2(int s,int i,bool offset=false)&#123; return (s&gt;&gt;(i-offset))&amp;1;&#125;inline int bas2(int i,bool offset=false)&#123; return 1&lt;&lt;(i-offset);&#125;inline int lowbit(int x)&#123; return x&amp;-x;&#125;const int N=100010;const int K=19;int n,m;VI node[K];int edge[K];int f[N];int g[K][1&lt;&lt;(K-1)];int idx[1&lt;&lt;(K-1)];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++)&#123; int sz,x; scanf("%d%d",&amp;edge[i],&amp;sz); for(int j=1;j&lt;=sz;j++)&#123; scanf("%d",&amp;x); f[x]|=bas2(i,true); node[i].PB(x); &#125; &#125; for(int i=1;i&lt;=m;i++) idx[bas2(i,true)]=i;&#125;void calcG()&#123; static int t[1&lt;&lt;(K-1)]; int stateCnt=(1&lt;&lt;m); for(int i=1;i&lt;=m;i++)&#123; memset(t,0,sizeof(int)*stateCnt); for(auto u:node[i]) t[f[u]]++; for(int bit=0;bit&lt;m;bit++) for(int j=0;j&lt;stateCnt;j++) if(!in2(j,bit)) t[j|bas2(bit)]+=t[j]; for(int j=0;j&lt;stateCnt;j++) g[i][stateCnt-1-j]=t[j]; &#125;&#125;namespace Graph&#123; const int N=(::K); LL w[N][N]; void build()&#123; for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) w[i][j]=(i==j)?0:LINF; for(int u=1;u&lt;=n;u++)&#123; static int lis[N],cnt; cnt=0; for(int i=1;i&lt;=m;i++) if(in2(f[u],i,true)) lis[++cnt]=i; for(int i=1;i&lt;cnt;i++) for(int j=i+1;j&lt;=cnt;j++)&#123; applyMin(w[lis[i]][lis[j]],edge[lis[j]]); applyMin(w[lis[j]][lis[i]],edge[lis[i]]); &#125; &#125; &#125; void Floyd()&#123; for(int k=1;k&lt;=m;k++) for(int i=1;i&lt;=m;i++) for(int j=1;j&lt;=m;j++) applyMin(w[i][j],w[i][k]+w[k][j]); &#125;&#125;LL dis[K][1&lt;&lt;(K-1)];void initDis()&#123; int stateCnt=1&lt;&lt;m; for(int i=1;i&lt;=m;i++)&#123; dis[i][0]=LINF; for(int j=1;j&lt;stateCnt;j++)&#123; int u=idx[lowbit(j)]; dis[i][j]=min(dis[i][j-lowbit(j)],edge[u]+Graph::w[u][i]); &#125; &#125;&#125;int curNode;bool cmpDis(const int &amp;x,const int &amp;y)&#123; return dis[x][f[curNode]]&lt;dis[y][f[curNode]];&#125;void solve()&#123; LL ans=0; static int a[K],cnt; for(int i=1;i&lt;=m;i++) a[i]=i; for(int u=1;u&lt;=n;u++)&#123; curNode=u; sort(a+1,a+m+1,cmpDis); int cliq=0,newNode=0; for(int i=1;i&lt;=m;i++)&#123; int id=a[i]; newNode=g[id][cliq]; if(!cliq) newNode--; cliq|=bas2(id,true); ans+=dis[id][f[u]]*newNode; &#125; &#125; printf("%lld\n",ans&gt;&gt;1);&#125;int main()&#123; readData(); calcG(); Graph::build(); Graph::Floyd(); initDis(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>好题</tag>
        <tag>图论---最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地中海气候]]></title>
    <url>%2F2018%2F12%2F17%2F%E5%9C%B0%E4%B8%AD%E6%B5%B7%E6%B0%94%E5%80%99%2F</url>
    <content type="text"><![CDATA[Description 给一个长度为$n$的数组$a$ 有$q$组询问，每次询问给出一个参数$p$。请模拟以下过程 初始时，可重集合$S$包含了$a_1\dots a_p$ A和B将轮流执行以下操作，A先手 从$S$中拿走最大值，累加进自己的得分。若$S$已经为空，则游戏结束 如果$p&lt;n$，将$p$加一，并将$a_p$加入$S$ 请输出A与B的得分之差 $n\le 10^5,\ q \le \min(2000,n)$，时间限制3s Solution 记当前所有元素的最大值为$top$，再记一个数组$cnt[i]$，表示在目前集合种元素$i$出现的次数。弹出最大值$top$后，令$cnt[top]$减一，并找到最大的、$cnt$非零的值作为新的$top$ 考虑加入一个元素$x$会带来那些影响： 若$x \ge top$，它在下一次操作就会立刻被弹出，我们没有将其加入集合并维护$cnt$和$top$的必要。我们可以开一个缓冲变量储存$x$，以后弹最大值时优先考虑缓冲变量，若没有缓冲变量再考虑$top$ 若$x &lt;top$，我们直接令$cnt[top]$加一即可，$top$不需要变化 时间复杂度$O(nq)$ 这种方法仅在权值范围较小且弹出加入配套时才奏效，扩展空间不广，但在维护思路上具有很好的启发意义 Summary 多利用题目的操作特殊性、单一性来解决传统问题的加强版 维护题不一定要按传统问题的思路来走 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100010;int n,m;int a[N];int b[N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); b[a[i]]++; &#125;&#125;LL solve(int p)&#123; static int c[N]; memset(c,0,sizeof c); int top=0; for(int i=1;i&lt;=p;i++)&#123; c[a[i]]++; top=max(top,a[i]); &#125; LL res=0,buf=-1; for(int i=1;i&lt;=n;i++)&#123; if(buf!=-1)&#123; res+=((i&amp;1)?1:-1)*buf; buf=-1; &#125; else&#123; res+=((i&amp;1)?1:-1)*top; c[top]--; while(top&amp;&amp;!c[top]) top--; &#125; if(p&lt;n)&#123; p++; if(a[p]&gt;=top) buf=a[p]; else c[a[p]]++; &#125; &#125; return res;&#125;void answerQuery()&#123; int p; for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;p); printf("%lld\n",solve(p)); &#125;&#125;int main()&#123; readData(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构---维护题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[东非大裂谷]]></title>
    <url>%2F2018%2F12%2F17%2F%E4%B8%9C%E9%9D%9E%E5%A4%A7%E8%A3%82%E8%B0%B7%2F</url>
    <content type="text"><![CDATA[Description 有一棵树，每一个节点有一个权值 你要将所有节点分成若干个非空组，满足每一个组的元素都为祖先关系 定义一个组的权值为组内权值极差。求所有组的权值值和的最大值 $n \le 10^5$ Solution $n^2$做法显然：设$f_u$表示考虑完$u$及其子树时，权值之和的最大值。转移时枚举$u$子树内的某一条由根出发的路径作为新的一组以转移 我们需要维护所有到根路径的最大值，但发现其并没有进一步优化的空间 考虑最优分组的性质，看看其是否能简化DP过程： 对于某一个组，最大值和最小值一定在祖先链的两端：如果两个极值不在路径两端，显然我们可以将路径向中间缩短直至顶住极值。这样做不会使得该组的权值更劣，反而还能为其他组留下更多考虑空间 对于某一个组，权值由浅到深要么不减，要么不增：如果出现不单调的情况，我们可以将路径分为至少两组，且这两组的权值之和必定优于当前组 有了最优分组的性质，我们的DP就有了着落：设$f_{u,0/1}$表示考虑完$u$的子树，$u$所在组由浅到深递增/递减时，子树内部的组的权值值和最大值为多少。显然有转移： sum=\sum_v\max(f_{v,0},f_{v,1})\\ f_{u,0}=\max\{sum-max(f_{v,0},f_{v,1})+f_{v,0}\mid w_u\le w_v\}\\ f_{u,1}=\max\{sum-max(f_{v,0},f_{v,1})+f_{v,1}\mid w_u\ge w_v\}\\ 答案即为$\max(f{1,0},f{1,1})$ 时间复杂度$O(n)$ Summary 考虑DP问题时，不仅要按照基础模型考虑优化转移，还要尝试寻找模型在最优情况下的性质。这些性质可能可以大大简化状态和转移，给原本不可做的DP方式一个新的出路 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;using namespace std;typedef long long LL;namespace IO&#123; const int L=50000000; char inBuf[L],outBuf[L]; int inPos,outPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; void flush()&#123; fwrite(outBuf,1,outPos,stdout); &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); for(;c&lt;'0'||c&gt;'9';c=getChar())&#123;if(c=='-')f=-1;&#125; for(;'0'&lt;=c&amp;&amp;c&lt;='9';c=getChar())&#123;x=x*10+c-'0';&#125; return x*f; &#125;&#125;using IO::getInt;inline LL max(LL x,LL y)&#123; return x&gt;y?x:y;&#125;inline void applyMax(LL &amp;x,LL y)&#123; if(y&gt;x) x=y;&#125;const int N=100010;int n;int w[N];namespace T&#123; int h[N],tot; struct Edge&#123; int v,next; &#125;e[N]; LL f[N][2]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; &#125; void dp(int u)&#123; LL sum=0; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; dp(v); sum+=max(f[v][0],f[v][1]); &#125; f[u][0]=f[u][1]=sum; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; if(w[u]&lt;=w[v]) applyMax(f[u][0],(sum-max(f[v][0],f[v][1]))+f[v][0]+(w[v]-w[u])); if(w[u]&gt;=w[v]) applyMax(f[u][1],(sum-max(f[v][0],f[v][1]))+f[v][1]+(w[u]-w[v])); &#125; &#125; void solve()&#123; dp(1); printf("%lld\n",max(f[1][0],f[1][1])); &#125;&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) w[i]=getInt(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=getInt(); v=getInt(); T::addEdge(u,v); &#125;&#125;int main()&#123; IO::load(); readData(); T::solve(); return 0;&#125;]]></content>
      <tags>
        <tag>DP---树形DP</tag>
        <tag>可做未做</tag>
        <tag>方案特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求和]]></title>
    <url>%2F2018%2F12%2F17%2F%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Description 有一个长度为$n$的数组$a_i$，再给定一个参数$k$ 请支持$q$次修改操作，每次操作只修改一个元素。你需要在一开始和每次修改之后回答下标相差不超过$k$的两个元素之和的最大值 $1 \le k &lt; n \le 10^6,\ q \le 10^6$ Solution 定义第$i$个元素的贡献为$v_i$，则答案为$\max v_i$。$v_i$的值如下 v_i=\left\{ \begin{array}{rcl} a_i+\max\{a_j\mid j\in[i-k,i+k]-\{i\}\}& &{a_i为[i-k,i+k]中的最大值}\\ -\infty& &{\text{else}} \end{array} \right. 如果存在相同元素，我们以下标为第二关键字将其区分即可 若一个元素不是管辖范围内的最大值，那么它的贡献不可能优于范围内最大值的那个位置的贡献，将其设为不影响答案的值即可 为什么这样维护是对的呢？首先明确目标：如果对于每一个$i$，形如$(i,\dots)$的点对都能被考虑或被更优解覆盖，则维护就是完整且正确的。下面具体证明一下： $i$是管辖范围内的最大值：显然$v_i$能够完整地考虑这些点对 $i$不是管辖范围内的最大值：设管辖范围内的最大值在$j$处，形如$(i,x\neq j)$的点对显然没有$(i,j)$优，而后者会在$v_j$处被考虑到 证毕 修改一个元素$a_i$时，先进行数值修改，之后我们只需要重新计算$[i-k,i)$中的最大值位置$x$、$(i,i+k]$中的最大值位置$y$以及$i$这三个位置的$v$即可。下面是对正确性的证明： 若修改后$a_i$成为了管辖范围的最大值：首先，$v_i$会被更新为正确的值；若原来区间最大值不是$a_i$，则原最大值一定为$x$或$y$中的某一个，会被相应更新。由于现在$a_i$是最大值，故$a_i$不会在其他某一个点的$v$中呈现，因此没有考虑维护其他$v$的必要 若修改后$a_i$并不是管辖范围的最大值：首先，$v_i$会被更新为正确的值；新的区间最大值必然是$x$和$y$中的一个，会被相应更新，$a_i$作为其他某一个点的$v$呈现的情况已经被考虑周全 本题极度卡常，最好使用zkw线段树。时间复杂度$O(n \log n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;using namespace std;typedef long long LL;namespace IO&#123; const int L=50000000; char inBuf[L],outBuf[L]; int inPos,outPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; void flush()&#123; fwrite(outBuf,1,outPos,stdout); &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); for(;c&lt;'0'||c&gt;'9';c=getChar())&#123;if(c=='-')f=-1;&#125; for(;'0'&lt;=c&amp;&amp;c&lt;='9';c=getChar())&#123;x=x*10+c-'0';&#125; return x*f; &#125; void writeChar(char c)&#123; outBuf[outPos++]=c; &#125; void writeInt(int x,char end='\n')&#123; if(!x) writeChar('0'); else&#123; static int digit[20],cnt; for(cnt=0;x;x/=10) digit[++cnt]=x%10; for(;cnt;cnt--) writeChar('0'+digit[cnt]); &#125; writeChar(end); &#125;&#125;using IO::getInt;using IO::writeInt;const int INF=1e9;const int N=1000010;inline LL max(LL x,LL y)&#123; return x&gt;y?x:y;&#125;inline LL min(LL x,LL y)&#123; return x&lt;y?x:y;&#125;int n,m,q,op;int a[N];LL b[N];namespace SEG&#123; const int N=(1&lt;&lt;22); LL maxa[N]; int maxv[N]; int m; void build(int n)&#123; for(m=1;m&lt;(n+2);m&lt;&lt;=1); for(int i=1;i&lt;=n;i++)&#123; maxa[m+i]=b[i]; maxv[m+i]=0; &#125; for(int i=m-1;i&gt;=1;i--)&#123; maxa[i]=max(maxa[i&lt;&lt;1],maxa[i&lt;&lt;1|1]); maxv[i]=max(maxv[i&lt;&lt;1],maxv[i&lt;&lt;1|1]); &#125; &#125; LL queryMax(int l,int r)&#123; LL res=0; for(int u=m+l-1,v=m+r+1;u^v^1;u&gt;&gt;=1,v&gt;&gt;=1)&#123; if(!(u&amp;1)) res=max(res,maxa[u^1]); if(v&amp;1) res=max(res,maxa[v^1]); &#125; return res; &#125; void setArr(int p,int x)&#123; a[p]=x; b[p]=((LL)a[p]&lt;&lt;25)+p; maxa[m+p]=b[p]; for(int u=(m+p)&gt;&gt;1;u;u&gt;&gt;=1) maxa[u]=max(maxa[u&lt;&lt;1],maxa[u&lt;&lt;1|1]); &#125; void setValue(int p,int x)&#123; maxv[m+p]=x; for(int u=(m+p)&gt;&gt;1;u;u&gt;&gt;=1) maxv[u]=max(maxv[u&lt;&lt;1],maxv[u&lt;&lt;1|1]); &#125; int getAnswer()&#123; return maxv[1]; &#125;&#125;void readData()&#123; n=getInt(); m=getInt(); q=getInt(); op=getInt(); for(int i=1;i&lt;=n;i++)&#123; a[i]=getInt(); b[i]=((LL)a[i]&lt;&lt;25)+i; &#125;&#125;void calc(int p)&#123; int l=max(1,p-m),r=min(n,p+m); if(SEG::queryMax(l,r)==b[p])&#123; int match=0; if(l&lt;p) match=max(match,SEG::queryMax(l,p-1)&gt;&gt;25); if(p&lt;r) match=max(match,SEG::queryMax(p+1,r)&gt;&gt;25); SEG::setValue(p,match+a[p]); &#125; else SEG::setValue(p,0);&#125;void modify(int x,int y)&#123; SEG::setArr(x,y); calc(x); int l=max(1,x-m),r=min(n,x+m),pos; if(l&lt;x) calc(SEG::queryMax(l,x-1)&amp;((1&lt;&lt;25)-1)); if(x&lt;r) calc(SEG::queryMax(x+1,r)&amp;((1&lt;&lt;25)-1));&#125;void answerQuery()&#123; int ans; for(int i=1;i&lt;=n;i++) calc(i); writeInt(ans=SEG::getAnswer()); int x,y; for(int i=1;i&lt;=q;i++)&#123; x=getInt(); y=getInt(); if(op)&#123; x^=ans; y^=ans; &#125; modify(x,y); writeInt(ans=SEG::getAnswer()); &#125;&#125;int main()&#123; IO::load(); readData(); SEG::build(n); answerQuery(); IO::flush(); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构---线段树</tag>
        <tag>数据结构---维护题</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跑步]]></title>
    <url>%2F2018%2F12%2F17%2F%E8%B7%91%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[Description 有一张$n\times n$的网格，每个格子上有一个数字$a_{i,j}$。左上角为$(1,1)$，右下角为$(n,n)$ 定义一个格子$(i,j)$的贡献为：从$(i,j)$向左或向上到达$(1,1)$的所有路径中经过格子数字之和的最大值 一共有$n$次修改，每次修改会将一个格子的值加一或减一。你需要在一开始和每一次修改之后，回答所有格子的贡献之和 $n \le 2000$ Solution 先把朴素的DP搞出来：设$f_{i,j}$为$(i,j)$的贡献，则有转移 f_{i,j}=\max\{f_{i-1,j},f_{i,j-1}\}+a_{i,j} 决策点在于$\max$是取上方还是左方的值 注意到修改十分特殊：变化连续，这意味可能存在一些机会处理决策点的切换 我们先考虑修改$(i,j)$后影响到了哪一些格子 对于第$i$行，影响的格子显然是一段区间，其左端点为$j$，右端点我们可以暴力扫出来。判断一个格子是否被影响的依据是：其选择有变，或者原选择被影响，直接查询$f$值即可 考虑第$(i+1)$行，影响的格子仍然是一段区间——若中间有断开，考虑一个断层中“未被影响”的最左方的格子，其左方也被影响、上边也被影响，自己不可能不被影响；一路顺推，可知这些断层都会被影响。这个区间的左端点相对于上一个区间不可能更左，右端点相对于上一个区间也不可能更左，我们暴力右移这两个端点即可 对于接下来的每一行，我们都暴力右移端点，显然总移动次数是$O(n)$的 至此，我们可以得到被影响的格子总数（即每一行区间长度之和）。显然，影响到的格子数量乘上修改值，就是全局答案的变化量，直接维护答案即可。对于每一个被影响的格子，我们将其$f$加上修改值，使用$n$个树状数组维护每一行的$f$即可 时间复杂度为$O(n^2 \log n)$ 事实上，我们还有更优的做法：原来判定一个格子$(i,j)$的选择时，我们需要比较$f{i-1,j}$和$f{i,j-1}$的大小关系。现在，我们直接维护一个差分$g{i,j}=f{i-1,j}-f_{i,j-1}$，并以其正负表示选择。原来将一行的一段区间的$f$全部加上修改值，现在我们只需要维护区间两段的$g$。细节较多，时间复杂度降为$O(n^2)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;namespace IO&#123; const int L=50000000; char inBuf[L],outBuf[L]; int inPos,outPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; void flush()&#123; fwrite(outBuf,1,outPos,stdout); &#125; char getChar()&#123; return inBuf[inPos++]; &#125; char getCmd()&#123; char c=getChar(); for(;c!='U'&amp;&amp;c!='D';c=getChar()); return c; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); for(;c&lt;'0'||c&gt;'9';c=getChar())&#123;if(c=='-')f=-1;&#125; for(;'0'&lt;=c&amp;&amp;c&lt;='9';c=getChar())&#123;x=x*10+c-'0';&#125; return x*f; &#125; void writeChar(char c)&#123; outBuf[outPos++]=c; &#125; void writeInt(LL x,char end='\n')&#123; if(!x) writeChar('0'); else&#123; static int digit[20],cnt; for(cnt=0;x;x/=10) digit[++cnt]=x%10; for(;cnt;cnt--) writeChar('0'+digit[cnt]); &#125; writeChar(end); &#125;&#125;using IO::getInt;using IO::getCmd;using IO::writeInt;const int INF=1e9;const int N=2010;int n;int a[N][N];void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=getInt();&#125;int f[N][N],g[N][N];LL ans;void init()&#123; for(int i=2;i&lt;=n;i++) f[0][i]=f[i][0]=-INF; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; f[i][j]=max(f[i][j-1],f[i-1][j])+a[i][j]; g[i][j]=f[i-1][j]-f[i][j-1]; ans+=f[i][j]; &#125;&#125;void modify(int x,int y,int sgn)&#123; int involve=0; int l=y,r=y; for(int j=y+1;j&lt;=n;j++)&#123; g[x][j]-=sgn; if(g[x][j]+sgn&lt;0||(g[x][j]+sgn==0&amp;&amp;sgn==1)) r=j; else break; &#125; involve=r-l+1; for(int i=x+1;i&lt;=n;i++)&#123; while(l&lt;=r)&#123; g[i][l]+=sgn; if(g[i][l]-sgn&lt;0||(g[i][l]-sgn==0&amp;&amp;sgn==-1)) l++; else break; &#125; if(l&gt;r) break; while(r&lt;n)&#123; g[i][r+1]-=sgn; if(g[i][r+1]+sgn&lt;0||(g[i][r+1]+sgn==0&amp;&amp;sgn==1)) r++; else break; &#125; involve+=r-l+1; &#125; ans+=sgn*involve;&#125;void answerQuery()&#123; writeInt(ans); char cmd; int x,y; for(int i=1;i&lt;=n;i++)&#123; cmd=getCmd(); x=getInt(); y=getInt(); modify(x,y,(cmd=='U')?+1:-1); writeInt(ans); &#125;&#125;int main()&#123; IO::load(); readData(); init(); answerQuery(); IO::flush(); return 0;&#125;]]></content>
      <tags>
        <tag>DP---动态DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[社保]]></title>
    <url>%2F2018%2F12%2F17%2F%E7%A4%BE%E4%BF%9D%2F</url>
    <content type="text"><![CDATA[Description 给定一张$n$个点、$m$条边的有向图$G(V,E)$ 定义$G^T$为将$G$中所有边反向后得到的图 记在图$G_0$中$u$可达的点构成的集合为$S(G_0,u)$ 对于每一个点$u$，请判断其是否满足$S(G,u)\cup S(G^T,u)=V$ $n,m \le 10^6$ Solution 显然先对原图Tarjan缩点，得到一张DAG。于是问题变为判定每一个点$u$是否能在原DAG或反向DAG中到达其余所有点 考虑不合法点的性质：对于一个点$u$，若存在一条边数大于1的路径，其起点位于$u$的上游、终点位于$u$的下游，且中途经过的点不位于$u$的上下游，则路径上除了端点的其余所有点与$u$都是并行关系，无法互达，也就意味着$u$和那些点不合法 ”并行“的概念令我们联想到了拓扑序中“同层”的概念，是否可以利用拓扑序来解决判定呢？ 考虑DAG的拓扑序：由于能到达$u$的点的拓扑序一定在$u$之前，且$u$能到达的点的拓扑序一定在$u$之后，则一个点$u$合法，当且仅当拓扑序在$u$前的所有点都能到达$u$，且$u$能到达所有拓扑序在它之后的点，有任何疏漏都将导致不合法 下面先给出一种做法： 在正向DAG中，对于一个点$u$，记其出边到达点中拓扑序最小的为$v$，则$(top_u,top_v)$之中的所有点全部不合法；在反向DAG中，对于一个点$u$，记其出边到达点中拓扑序最大的为$v$，则$(top_v,top_u)$之中的所有点全部不合法。使用差分标记即可做到$O(n)$的复杂度 为什么这样是对的？ 对于一个不合法的点$u$，若我们将$u$在正反DAG中能到达的点在拓扑序上染黑，则拓扑序中必然存在一些白点。考虑$u$之后的第一个白点$x$，它在反向DAG里出边到达点拓扑序最大的$v$，其拓扑序一定在$u$之前；若$v$拓在$u$和$x$之间，则意味着在正向DAG中$u$能先到达$v$再到达$x$，矛盾。同理，$u$之前的第一个白点$x$在正向DAG里出边到达点拓扑序最小的$v$，其拓扑序一定在$u$之后。综上，一个不合法的点$u$总是会在算法执行到某一个最近的白点时被标记 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;namespace IO&#123; const int L=50000000; char inBuf[L]; int inPos=0; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int INF=1e9;const int N=1000010;const int M=1000010;int n,m;namespace G&#123; int h1[N],h2[N],h3[N],tot; struct Edge&#123; int v,next; &#125;e[N*3]; int oriCnt,oriEdge[M][2]; void addEdge(int u,int v,int *h=h1)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; if(h==h1)&#123; oriCnt++; oriEdge[oriCnt][0]=u; oriEdge[oriCnt][1]=v; &#125; &#125; int dfn[N],low[N],dfnTimer; int bcnt,bel[N]; int in[N]; int topLis[N],topPos[N]; void TarjanDfs(int u)&#123; static int sta[N],top=0; static bool inStack[N]; dfn[u]=low[u]=++dfnTimer; sta[++top]=u; inStack[u]=true; for(int i=h1[u],v;i;i=e[i].next)&#123; v=e[i].v; if(!dfn[v])&#123; TarjanDfs(v); low[u]=min(low[u],low[v]); &#125; else if(inStack[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; bcnt++; int x; do&#123; x=sta[top--]; inStack[x]=false; bel[x]=bcnt; &#125;while(x!=u); &#125; &#125; void Tarjan()&#123; for(int i=1;i&lt;=n;i++) if(!dfn[i]) TarjanDfs(i); for(int i=1;i&lt;=oriCnt;i++)&#123; int u=oriEdge[i][0],v=oriEdge[i][1]; if(bel[u]!=bel[v])&#123; addEdge(bel[u],bel[v],h2); addEdge(bel[v],bel[u],h3); in[bel[v]]++; &#125; &#125; &#125; void Topsort()&#123; static queue&lt;int&gt; q; int p=0; for(int i=1;i&lt;=bcnt;i++) if(!in[i]) q.push(i); while(!q.empty())&#123; int u=q.front(); q.pop(); topLis[++p]=u; topPos[u]=p; for(int i=h2[u],v;i;i=e[i].next)&#123; v=e[i].v; in[v]--; if(!in[v]) q.push(v); &#125; &#125; &#125; int sum[N]; void mark()&#123; for(int p=1;p&lt;=bcnt;p++)&#123; int u=topLis[p]; int s=n+1; for(int i=h2[u],v;i;i=e[i].next)&#123; v=e[i].v; s=min(s,topPos[v]); &#125; if(p+2&lt;=s)&#123; sum[p+1]++; sum[s]--; &#125; s=0; for(int i=h3[u],v;i;i=e[i].next)&#123; v=e[i].v; s=max(s,topPos[v]); &#125; if(s+2&lt;=p)&#123; sum[s+1]++; sum[p]--; &#125; &#125; for(int i=2;i&lt;=bcnt;i++) sum[i]+=sum[i-1]; &#125;&#125;void readData()&#123; n=getInt(); m=getInt(); int u,v; for(int i=1;i&lt;=m;i++)&#123; u=getInt(); v=getInt(); G::addEdge(u,v); &#125;&#125;void printAnswer()&#123; static int ans[N],cnt; for(int u=1;u&lt;=n;u++)&#123; if(!G::sum[G::topPos[G::bel[u]]]) ans[++cnt]=u; &#125; printf("%d\n",cnt); for(int i=1;i&lt;=cnt;i++) printf("%d ",ans[i]); puts("");&#125;int main()&#123; IO::load(); readData(); G::Tarjan(); G::Topsort(); G::mark(); printAnswer(); return 0;&#125;]]></content>
      <tags>
        <tag>好题</tag>
        <tag>图论---拓扑序</tag>
        <tag>图论---强联通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【2018九省联考】IIIDX]]></title>
    <url>%2F2018%2F12%2F14%2FIIIDX%2F</url>
    <content type="text"><![CDATA[Description 有$n+1$个节点，标号为$0 \dots n$ 给定小数$d$，对于$\forall i&gt;0$，$\lfloor i/d\rfloor$向$i$连一条树边。显然，所有点构成了一棵以$0$为根的树 给一个长度为$n$的序列$a$，你要为每一个编号不为0的点分配序列中的某个元素，使得每一个点的父亲的值不超过自己的值 请依次输出你为$1\dots n$分配的权值。若存在多种方案，请输出字典序最大的一组解 Solution 考虑一个贪心：先将权值从大到小排序。顺次考虑$1\dots n$这些点，对于点$i$，每次分配权值最大的$size_i$个值给这一个子树使用，且$i$恰好使用这些权值中最小的一个 这种贪心在权值互不相同的情况下是正确的；但若存在若干个相同权值时，就出现问题了：假设$i$分配的权值有多个，显然$i$可以不必选最靠左的这个权值——它和它的子树可以在$i$权值相同的前提下部分向右调整，为后续的点腾出空间，以尽可能使字典序更大 具体的调配方案非常难考虑。为此，我们采用一种“预定”的策略 排好序后，记$f_i$表示，前$i$个权值还剩几个没有使用。初始时，$f_i=i$ 对于第一个考虑一个点$u$（即1号点），记其子树大小为$sizeu$。我们先找到第$size_u$大的未使用的权值，记为$x$，再找到同为$x$的权值中最靠右的位置，记为$p$。显然，$u$的最终权值就是$x$，具体权值位置为$p$；但对于$u$子树内部的点到底选择$p$左侧的哪些点，我们无法直接分配，或者说现在我们既无法直接为它们锁死方案，也不需要立刻确定它们的位置；我们只需要告诉以后要决策的点：$1\dots p$已经被用掉了$size_u$个位置了。为此，我们将$f_p\dots f_n$全部减去$size_u$；对于$f_1\dots f{p-1}$，我们暂且不做更新。 对于之后考虑的每一个点$u$，同样先找到第$sizeu$大的未使用的权值。此时，我们判断位置$i$左边有至少$size_u$个空闲位置的依据不再是$i\ge size_u$，而是$\forall {j\ge i}fj\ge size_u$。为何之前$f_1\dots f{p-1}$不需要更新呢？因为预定的点在这个范围内可以自由调配，其优先级不会大于后续考虑的点（如当前的$u$）；当$u$进一步提出预定条件时，之前的预定也会被相应协调。接下来，同样找到$p$，维护$f$即可 实现上，用线段树维护$f$，支持区间加和区间取$\min$，查询时在线段树上二分即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;vector&gt;#define PB push_backusing namespace std;typedef vector&lt;int&gt; VI;const int N=500010;namespace IO&#123; const int L=50000000; char inBuf[L]; int inPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; char c=getChar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; double getDouble()&#123; char c=getChar(); double x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; if(c=='.')&#123; double now=0.1; c=getChar(); while('0'&lt;=c&amp;&amp;c&lt;='9')&#123; x+=now*(c-'0'); now*=0.1; c=getChar(); &#125; &#125; return x*f; &#125;&#125;using IO::getInt;using IO::getDouble;int n;double m;int d[N];namespace T&#123; int h[N],tot; struct Edge&#123; int v,next; &#125;e[N]; int pre[N]; int size[N]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; &#125; void dfs(int u,int fa)&#123; pre[u]=fa; size[u]=1; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; dfs(v,u); size[u]+=size[v]; &#125; &#125;&#125;void readData()&#123; n=getInt(); m=getDouble(); for(int i=1;i&lt;=n;i++) d[i]=getInt(); for(int i=1;i&lt;=n;i++) T::addEdge(int(i/m),i);&#125;namespace SEG&#123; const int N=(::N)*2; int rt,sz; int ch[N][2]; int tag[N]; int val[N]; void pushup(int u)&#123; val[u]=min(val[ch[u][0]],val[ch[u][1]])+tag[u]; &#125; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r)&#123; val[u]=l; return; &#125; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); pushup(u); &#125; inline void addTag(int u,int x)&#123; val[u]+=x; tag[u]+=x; &#125; void modify(int u,int l,int r,int ml,int mr,int x)&#123; if(ml&lt;=l&amp;&amp;r&lt;=mr)&#123; addTag(u,x); return; &#125; int mid=(l+r)&gt;&gt;1; if(mr&lt;=mid) modify(ch[u][0],l,mid,ml,mr,x); else if(mid&lt;ml) modify(ch[u][1],mid+1,r,ml,mr,x); else&#123; modify(ch[u][0],l,mid,ml,mid,x); modify(ch[u][1],mid+1,r,mid+1,mr,x); &#125; pushup(u); &#125; int query(int u,int l,int r,int x,int tagSum=0)&#123; if(l==r) return (val[u]+tagSum)&gt;=x?l:l+1; tagSum+=tag[u]; int mid=(l+r)&gt;&gt;1; if((val[ch[u][1]]+tagSum)&gt;=x) return query(ch[u][0],l,mid,x,tagSum); else return query(ch[u][1],mid+1,r,x,tagSum); &#125;&#125;int ans[N];int id[N];VI pos[N];void solve()&#123; sort(d+1,d+n+1); reverse(d+1,d+n+1); for(int i=1,j,cnt=1;i&lt;=n;i=j,cnt++)&#123; for(j=i;j&lt;=n&amp;&amp;d[i]==d[j];j++)&#123; id[j]=cnt; pos[cnt].PB(j); &#125; &#125; using T::pre; using T::size; for(int u=1;u&lt;=n;u++)&#123; if(pre[u]) SEG::modify(SEG::rt,1,n,ans[pre[u]],n,size[u]); int p=SEG::query(SEG::rt,1,n,size[u]); int tmp=id[p]; ans[u]=pos[tmp].back(); pos[tmp].pop_back(); SEG::modify(SEG::rt,1,n,ans[u],n,-size[u]); &#125; for(int i=1;i&lt;=n;i++) printf("%d ",d[ans[i]]); puts("");&#125;int main()&#123; IO::load(); readData(); T::dfs(0,-1); SEG::build(SEG::rt,1,n); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构---线段树</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dexterity]]></title>
    <url>%2F2018%2F12%2F14%2FDexterity%2F</url>
    <content type="text"><![CDATA[Description 你和对手将要进行$n$次石头剪刀布的游戏。在第$i$局中，若你赢则你获得$a_i$分，若双方平局则你获得$b_i$分，若你输则你不得分 已知对手的猜拳策略固定，且恰为给出的一个长度为$n$的字符串$S$的某个轮换 若你采取最优策略，在最坏情况下你至少能得多少分？你的猜拳策略可以根据已知的对手序列灵活调整 $n \le 10^5$ Solution 我们首要任务是弄清楚自己的最优策略与最劣情况的限制：若当前对局已经进行了若干轮，即我已知了对手目前的猜拳序列，我可以确定对手下一步可能出的是什么、对手猜拳序列的结果有哪些。根据“最劣情况”这一限制，我不可以在对手猜拳之后再决定出哪个，我只能选一个最优的手势，使得对手出的每种情况的导出的后续结果的最小值最大 考虑上述策略如何用算法描述。注意到与对手猜拳的过程也是我逐步确定对手序列的过程，因此我们使用一棵Trie树插入$S$的所有循环移位，则此时每个局面相当于一条到叶路径。对于一个点$u$，我们计算$f_u$，表示已知当前对手猜拳序列为根节点走到$u$的边序列时，后续最优决策的最劣值。我枚举下一步自己出的手势$c_0$，再计算对手出每一种手势$c$时最优值的最小值，即： \min_{v\in son _u}\{vs(c_0,v)+f_v\} 其中$vs(a,b)$表示我出$a$、对手出$b$时，我的得分 此时我们可以决定哪一个手势较优， Summary 二维坐标的行走问题，不妨在切比雪夫坐标意义下再考虑考虑：我们可以通过切比雪夫坐标独立计算两个维度的决策，将二者相乘以计算总方案。这种方法在时间复杂度的意义上有某种质的飞跃 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;using namespace std;const int INF=1e9;const int MOD=1e9+7;const int N=1010;int n;int a,b;int m;struct Point&#123; int x,y;&#125;p[N];int mnx,mxx,mny,mxy;inline int abs(int x)&#123; return x&gt;=0?x:-x;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;int fact[10010],iact[10010];void initFact(int n)&#123; fact[0]=1; for(int i=1;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void readData()&#123; scanf("%d%d%d%d",&amp;n,&amp;a,&amp;b,&amp;m); mnx=INF; mxx=-INF; mny=INF; mxy=-INF; int x,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;x,&amp;y); p[i]=(Point)&#123;x+y,x-y&#125;; mnx=min(mnx,p[i].x-m); mxx=max(mxx,p[i].x+m); mny=min(mny,p[i].y-m); mxy=max(mxy,p[i].y+m); &#125;&#125;int calc1(int l,int r)&#123; int sumx=0,sumy=0; for(int x=mnx;x&lt;=mxx;x++)&#123; int t=1; for(int i=l;i&lt;=r;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; (sumx+=t)%=MOD; &#125; for(int y=mny;y&lt;=mxy;y++)&#123; int t=1; for(int i=l;i&lt;=r;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; (sumy+=t)%=MOD; &#125; return 1ll*sumx*sumy%MOD;&#125;int calc2(int l1,int r1,int l2,int r2)&#123; int sumx=0,sumy=0; for(int x=mnx;x&lt;=mxx;x++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; (sumx+=t)%=MOD; &#125; for(int y=mny;y&lt;=mxy;y++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; (sumy+=t)%=MOD; &#125; return 1ll*sumx*sumy%MOD;&#125;int calc3(int l1,int r1,int l2,int r2,int l3,int r3)&#123; int sumx=0,sumy=0; for(int x=mnx;x&lt;=mxx;x++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; for(int i=l3;i&lt;=r3;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; (sumx+=t)%=MOD; &#125; for(int y=mny;y&lt;=mxy;y++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; for(int i=l3;i&lt;=r3;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; (sumy+=t)%=MOD; &#125; return 1ll*sumx*sumy%MOD;&#125;void solve()&#123; int t[3]; t[0]=calc1(1,a); t[1]=calc1(a+1,a+b); t[2]=calc1(a+b+1,n); int ans=1ll*t[0]*t[1]%MOD*t[2]%MOD; (ans-=1ll*t[2]*calc2(1,a,a+1,a+b)%MOD)%=MOD; (ans-=1ll*t[1]*calc2(1,a,a+b+1,n)%MOD)%=MOD; (ans-=1ll*t[0]*calc2(a+1,a+b,a+b+1,n)%MOD)%=MOD; (ans+=2ll*calc3(1,a,a+1,a+b,a+b+1,n)%MOD)%=MOD; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); initFact(10000); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>可做未做</tag>
        <tag>后缀树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kar]]></title>
    <url>%2F2018%2F12%2F12%2Fkar%2F</url>
    <content type="text"><![CDATA[Description 你有$n$张卡牌，每张卡牌的正反面各写有一个整数 所有已经卡牌从左到右排成一排，顺序不可随意更改。问是否存在一种方案，使得为每一张卡牌确定一个朝向之后，卡牌正面的整数从左到右不降 你需要支持$m$次操作，每次操作会交换两张卡牌的位置。你需要在每次操作之后回答是否存在方案 $n \le 2*10^5,\ m\le 10^6$，时限8s Solution 单次判断是非常显然的：从左到右考虑每一张卡，尽量选较小的数字，判断是否可行即可 加入了修改操作后，考虑到每次决策的选择较少（只有2种）、判断只依赖于上一张卡牌的结果，且判断可以分段进行，我们可以采用合并两端的判断结果方式，而不是想怎么加速这个$O(n)$判断（事实上好像做不了） 用线段树维护每一段区间在左端选两个数字时右端的最小结果即可 时间复杂度$O(m \log n)$ Summary 如果从左到右的线性过程需要在修改意义下进行，只要过程能分段进行且接口处决策量较小，我们就可以使用线段树合并区间结果的方式维护 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;using namespace std;namespace IO&#123; const int L=50000000; char inBuf[L]; int inPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; char c=getChar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int N=200010;int n;int a[N][2];inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++)&#123; a[i][0]=getInt(); a[i][1]=getInt(); if(a[i][0]&gt;a[i][1]) swap(a[i][0],a[i][1]); &#125;&#125;namespace SEG&#123; const int N=(::N)*2; int rt,sz; int ch[N][2]; int f[N][2]; inline void pushup(int u,int mid)&#123; if(f[ch[u][0]][0]==-1) f[u][0]=-1; else&#123; if(f[ch[u][0]][0]&gt;a[mid+1][1]) f[u][0]=-1; else f[u][0]=f[ch[u][1]][f[ch[u][0]][0]&gt;a[mid+1][0]]; &#125; if(f[ch[u][0]][1]==-1) f[u][1]=-1; else&#123; if(f[ch[u][0]][1]&gt;a[mid+1][1]) f[u][1]=-1; else f[u][1]=f[ch[u][1]][f[ch[u][0]][1]&gt;a[mid+1][0]]; &#125; &#125; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r)&#123; f[u][0]=a[l][0]; f[u][1]=a[l][1]; return; &#125; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); pushup(u,mid); &#125; void modify(int u,int l,int r,int p,int *v)&#123; if(l==r)&#123; a[l][0]=f[u][0]=v[0]; a[l][1]=f[u][1]=v[1]; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) modify(ch[u][0],l,mid,p,v); else modify(ch[u][1],mid+1,r,p,v); pushup(u,mid); &#125; bool legal()&#123; return f[rt][0]!=-1; &#125;&#125;void answerQuery()&#123; int m,x,y,t1[2],t2[2]; m=getInt(); for(int i=1;i&lt;=m;i++)&#123; x=getInt(); y=getInt(); t1[0]=a[x][0]; t1[1]=a[x][1]; t2[0]=a[y][0]; t2[1]=a[y][1]; SEG::modify(SEG::rt,1,n,x,t2); SEG::modify(SEG::rt,1,n,y,t1); puts(SEG::legal()?"TAK":"NIE"); &#125;&#125;int main()&#123; IO::load(); readData(); SEG::build(SEG::rt,1,n); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构---线段树</tag>
        <tag>可做未做</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alpha]]></title>
    <url>%2F2018%2F12%2F12%2Falpha%2F</url>
    <content type="text"><![CDATA[Description 你有一个长度为$10^9$的数组。初始时，数组中的每一个元素都为0 现在有$n$次操作将被执行，每一次操作的参数是$l,r,p$，表示有$p$的概率将数组$[l,r]$中的全部元素加一 给定$k$，求$n$次操作执行完毕后，值恰好为$k$的元素期望个数 概率和答案都在模998244353意义下给出、计算 $n \le 50000$ Solution 由于本题要对特定值得元素期望个数讨论，我们必须在DP中以值为下标，统计期望值恰好为$k$的元素个数的做法显然是错误的 我们会使用动态开点线段树维护所有操作。在进一步深入之前，我们要先讨论如何处理单个元素 对于一个元素，记它收到的操作的$p$为$p1,p_2,\dots, p_m$；设DP数组$f{i,j}$表示执行完前$i$个$p$后，其值恰好为$j$的概率，则有转移： f_{i,0}=(1-p_i)f_{i-1,0}\\ f_{i,j}=p_if_{i-1,j-1}+(1-p_i)f_{i-1,j} 注意到转移的方式单一、固定，我们构造$f$的生成函数$F$，则有： f_{i,j}=F_i(x)[x^j]\\F_i(x)=F_{i-1}(x)*(p_ix-(1-p_i))\\ F_m(x)=\prod_{i=1}^m(p_ix-(1-p_i)) 使用分治FFT计算$m$个一次多项式的乘积即可 现在，考虑如何将这个操作复刻到线段树上。先按照惯例将每一个操作的$p$打到相应的线段树节点上作为标记；求每一个叶子元素的答案时，我们相当于先求出从根节点到叶子节点的所有标记的多项式乘积，再取$x^k$的系数求和 考虑将过程反过来，并自动化“求和”的过程：我们直接求出所有叶子节点的答案多项式的和，取$x^k$项的系数即为答案。具体做法是：令叶子节点本身的多项式为$f(x)=1$。每处理到一个节点时，我们先递归左右儿子，将左右儿子的多项式相加，再乘上自己的所有标记乘起来的多项式作为结果返回 相加与乘法必须严格按照多项式次数进行，否则复杂度没有保证；对于一个节点的所有标记，我们需要使用分治FFT乘出结果 我们不能总遍历到叶子节点，因此对于一个空节点$[l,r]$，直接返回结果$f(x)=(r-l+1)$ 我们需要先将坐标离散化，再用线段树处理。这样做能将$\log$的常数降低。实现上，离散化$l,r,r+1$即可 复杂度分析： 左右儿子多项式相加：总复杂度$O(n \log n)$ 每个节点进行一次标记的分治FFT：设一个点的标记有$m$个，则单点的复杂度为$O(m \log^2 m)$；由于$\sum m=n \log n$，因此总复杂度为$O(n \log^3 n)$ 每个节点将相加的结果与标记多项式相乘，复杂度$O(n \log^3 n)$ Summary 遇到转移模式化的DP式子，一定要往生成函数的方向思考一下，并寻求能将FFT过程高效组织起来的算法 不能一下就否决某一些看似复杂度过高的算法，必须细心分析复杂度：如线段树的诸多$\log$性质可能可以降低复杂度总量 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172#pragma GCC optimize("Ofast","inline","unroll-loops")#pragma GCC optimize("no-stack-protector")#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define PB push_backusing namespace std;typedef vector&lt;int&gt; VI;const int INF=1e9;const int MOD=998244353,G=3;const int N=50010;int n,m;int opt[N][3],maxr;int d[N*4],dcnt;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;namespace NTT&#123; const int S=250000; int W[19][S][2]; int n,invn,bit; int rev[S]; void build()&#123; int iG=fastPow(G,MOD-2); for(int i=2,j=1;j&lt;=18;i&lt;&lt;=1,j++)&#123; int x=fastPow(G,(MOD-1)/i); int y=fastPow(iG,(MOD-1)/i); W[j][0][0]=W[j][0][1]=1; for(int k=1;k&lt;(i&gt;&gt;1);k++)&#123; W[j][k][0]=1ll*W[j][k-1][0]*x%MOD; W[j][k][1]=1ll*W[j][k-1][1]*y%MOD; &#125; &#125; &#125; void init(int _n)&#123; for(n=1,bit=0;n&lt;_n;n&lt;&lt;=1,bit++); invn=fastPow(n,MOD-2); for(int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); &#125; void ntt(int *a,int f)&#123; for(int i=0;i&lt;n;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); int u,v,w; for(int i=2,li=1;i&lt;=n;i&lt;&lt;=1,li++) for(int j=0;j&lt;n;j+=i) for(int k=0;k&lt;(i&gt;&gt;1);k++)&#123; u=a[j+k]; v=1ll*W[li][k][f==1?0:1]*a[j+(i&gt;&gt;1)+k]%MOD; a[j+k]=(u+v)%MOD; a[j+(i&gt;&gt;1)+k]=(u-v)%MOD; &#125; if(f==-1) for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*invn%MOD; &#125;&#125;VI polyAdd(VI &amp;a,VI &amp;b)&#123; int n=a.size(),m=b.size(); VI res=VI(max(n,m)); for(int i=0,sz=res.size();i&lt;sz;i++) res[i]=((i&lt;n?a[i]:0)+(i&lt;m?b[i]:0))%MOD; return res;&#125;VI polyMul(VI &amp;a,VI &amp;b)&#123; static int ta[NTT::S],tb[NTT::S]; int n=a.size(),m=b.size(); NTT::init(n+m-1); for(int i=0;i&lt;n;i++) ta[i]=a[i]; for(int i=n;i&lt;NTT::n;i++) ta[i]=0; for(int i=0;i&lt;m;i++) tb[i]=b[i]; for(int i=m;i&lt;NTT::n;i++) tb[i]=0; NTT::ntt(ta,1); NTT::ntt(tb,1); for(int i=0;i&lt;NTT::n;i++) ta[i]=1ll*ta[i]*tb[i]%MOD; NTT::ntt(ta,-1); return VI(ta,ta+(n+m-1));&#125;VI prodDivide(int l,int r,VI &amp;a)&#123; if(l==r)&#123; VI res(2); res[0]=1-a[l]; res[1]=a[l]; return res; &#125; int mid=(l+r)&gt;&gt;1; VI fl=prodDivide(l,mid,a); VI fr=prodDivide(mid+1,r,a); return polyMul(fl,fr);&#125;VI prod(VI &amp;a)&#123; int sz=a.size(); if(sz==0) return VI(1,1); return prodDivide(0,sz-1,a);&#125;namespace SEG&#123; const int S=5000010; int rt,sz; int ch[S][2]; VI tag[S]; void modify(int &amp;u,int l,int r,int ml,int mr,int p)&#123; if(!u) u=++sz; if(ml&lt;=l&amp;&amp;r&lt;=mr)&#123; tag[u].PB(p); return; &#125; int mid=(l+r)&gt;&gt;1; if(mr&lt;=mid) modify(ch[u][0],l,mid,ml,mr,p); else if(mid&lt;ml) modify(ch[u][1],mid+1,r,ml,mr,p); else&#123; modify(ch[u][0],l,mid,ml,mid,p); modify(ch[u][1],mid+1,r,mid+1,mr,p); &#125; &#125; VI multiply(int u,int l,int r)&#123; VI fl,fr; if(!u||l==r) fl=VI(1,d[r+1]-d[l]); else&#123; int mid=(l+r)&gt;&gt;1; fl=multiply(ch[u][0],l,mid); fr=multiply(ch[u][1],mid+1,r); fl=polyAdd(fl,fr); &#125; if(u)&#123; VI g=prod(tag[u]); fl=polyMul(fl,g); &#125; return fl; &#125;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d",&amp;opt[i][0],&amp;opt[i][1],&amp;opt[i][2]); maxr=max(maxr,opt[i][1]); &#125; scanf("%d",&amp;m);&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++)&#123; d[++dcnt]=opt[i][0]; d[++dcnt]=opt[i][1]; d[++dcnt]=opt[i][1]+1; &#125; d[++dcnt]=maxr+1; sort(d+1,d+1+dcnt); dcnt=unique(d+1,d+1+dcnt)-d-1; for(int i=1;i&lt;=n;i++)&#123; opt[i][0]=lower_bound(d+1,d+1+dcnt,opt[i][0])-d; opt[i][1]=lower_bound(d+1,d+1+dcnt,opt[i][1])-d; &#125;&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) SEG::modify(SEG::rt,1,dcnt,opt[i][0],opt[i][1],opt[i][2]); VI ans=SEG::multiply(SEG::rt,1,dcnt); printf("%d\n",ans[m]&gt;=0?ans[m]:ans[m]+MOD);&#125;int main()&#123; NTT::build(); readData(); Diz(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构---线段树</tag>
        <tag>FFT</tag>
        <tag>可做未做</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑暗]]></title>
    <url>%2F2018%2F12%2F10%2F%E9%BB%91%E6%9A%97%2F</url>
    <content type="text"><![CDATA[Description 有$n$个机器人，标号$[1,a]$的为红色，标号$(a,a+b]$的为绿色，其余为蓝色。我们保证每种颜色都至少有一个机器人 初始时，第$i$个机器人在二维坐标系上的$(x_i,y_i)$处。每过1个时刻，每个机器人可以且仅可以走向四相邻中的某一个格子，不可以原地不动。我们要求在$m$个时刻后，所有机器人满足： 相同颜色的机器人在同一个位置 不同颜色的机器人不可以在同一个位置 问总共有多少种合法方案。两个合法方案不同，当且仅当某种颜色的机器人的终止位置不同，或者某一个机器人的行进路线不同。答案对$10^9+7$取模 Solution 先假设我们能够快速地计算一个函数：$f_0(c)$表示颜色为$c$的所有机器人在$m$个时刻之后全部走到某一个终点$(x,y)$的方案数之和 基于这个函数，我们可以得到一个较为直接的思路：枚举合法情况下三种颜色各自的终止位置并统计方案即可 观察到颜色数量很少，猜想可以使用容斥原理快速统计 先求一个总方案：$f_0(0)f_0(1)f_0(2)$，其中包含了不合法的情况，于是： 减去钦定某两种颜色终止位置相同，剩余颜色终止位置的随意时的方案数$f_1(x,y)f_0(z)$。容斥系数为$-1$ 再加上三种颜色终止位置相同的情况$f_2(x,y,z)$。容斥系数为$+2$ 这个做法的时间复杂度只和枚举坐标以及计算$f$的速度相关；$f_1$和$f_2$的定义也与$f_0$相似 回头考虑一下$f$的计算：对于二维坐标走格子的问题，我们可以将坐标转化为切比雪夫坐标，将两个维度独立处理，具体来讲： 原来的一个点$(x,y)$，转化后为$(x+y,x-y)$ 原来一个点可以走到$(x\pm 1,y),(x,y\pm 1)$，转化后一个点可以走到$(x\pm 1, y\pm 1)$ 注意到一个点在切比雪夫坐标意义下移动时两维都要变化，这很好地简化了原坐标系中“到底走哪一维”的决策 考虑计算$f_0(c)$，其余两个函数同理：对于某一个颜色为$c$的机器人的坐标，我们先将其转化为切比雪夫距离，则原来所有颜色为$c$的机器人都走到$(x,y)$如今等价于：（所有$x_i’=x_i+y_i$通过加减一$m$次变为$x+y$的方案数）乘以（所有$y_i’=x_i-y_i$通过加减一$m$次变为$x-y’$的方案数）。我们只需要对于每一维，在枚举该维在切比雪夫意义下的终点，计算所有机器人该维走到该终点的方案数，求和，最后用两个维度的答案相乘，就可以得到所有机器人走到所有可能的终点的方案数之和 单次计算复杂度为$O(\mid c\mid (xrange+yrange))$ $a$通过加减一$m$次变为$b$的方案数为${m \choose \frac{\mid b-a\mid}2}$ 总时间复杂度为$O(n(xrange+yrange))$ Summary 二维坐标的行走问题，不妨在切比雪夫坐标意义下再考虑考虑：我们可以通过切比雪夫坐标独立计算两个维度的决策，将二者相乘以计算总方案。这种方法在时间复杂度的意义上有某种质的飞跃 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131#include &lt;cstdio&gt;using namespace std;const int INF=1e9;const int MOD=1e9+7;const int N=1010;int n;int a,b;int m;struct Point&#123; int x,y;&#125;p[N];int mnx,mxx,mny,mxy;inline int abs(int x)&#123; return x&gt;=0?x:-x;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;int fact[10010],iact[10010];void initFact(int n)&#123; fact[0]=1; for(int i=1;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void readData()&#123; scanf("%d%d%d%d",&amp;n,&amp;a,&amp;b,&amp;m); mnx=INF; mxx=-INF; mny=INF; mxy=-INF; int x,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d",&amp;x,&amp;y); p[i]=(Point)&#123;x+y,x-y&#125;; mnx=min(mnx,p[i].x-m); mxx=max(mxx,p[i].x+m); mny=min(mny,p[i].y-m); mxy=max(mxy,p[i].y+m); &#125;&#125;int calc1(int l,int r)&#123; int sumx=0,sumy=0; for(int x=mnx;x&lt;=mxx;x++)&#123; int t=1; for(int i=l;i&lt;=r;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; (sumx+=t)%=MOD; &#125; for(int y=mny;y&lt;=mxy;y++)&#123; int t=1; for(int i=l;i&lt;=r;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; (sumy+=t)%=MOD; &#125; return 1ll*sumx*sumy%MOD;&#125;int calc2(int l1,int r1,int l2,int r2)&#123; int sumx=0,sumy=0; for(int x=mnx;x&lt;=mxx;x++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; (sumx+=t)%=MOD; &#125; for(int y=mny;y&lt;=mxy;y++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; (sumy+=t)%=MOD; &#125; return 1ll*sumx*sumy%MOD;&#125;int calc3(int l1,int r1,int l2,int r2,int l3,int r3)&#123; int sumx=0,sumy=0; for(int x=mnx;x&lt;=mxx;x++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; for(int i=l3;i&lt;=r3;i++) t=1ll*t*(((x-p[i].x)&amp;1)==(m&amp;1)?C(m,(m-abs(x-p[i].x))&gt;&gt;1):0)%MOD; (sumx+=t)%=MOD; &#125; for(int y=mny;y&lt;=mxy;y++)&#123; int t=1; for(int i=l1;i&lt;=r1;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; for(int i=l2;i&lt;=r2;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; for(int i=l3;i&lt;=r3;i++) t=1ll*t*(((y-p[i].y)&amp;1)==(m&amp;1)?C(m,(m-abs(y-p[i].y))&gt;&gt;1):0)%MOD; (sumy+=t)%=MOD; &#125; return 1ll*sumx*sumy%MOD;&#125;void solve()&#123; int t[3]; t[0]=calc1(1,a); t[1]=calc1(a+1,a+b); t[2]=calc1(a+b+1,n); int ans=1ll*t[0]*t[1]%MOD*t[2]%MOD; (ans-=1ll*t[2]*calc2(1,a,a+1,a+b)%MOD)%=MOD; (ans-=1ll*t[1]*calc2(1,a,a+b+1,n)%MOD)%=MOD; (ans-=1ll*t[0]*calc2(a+1,a+b,a+b+1,n)%MOD)%=MOD; (ans+=2ll*calc3(1,a,a+1,a+b,a+b+1,n)%MOD)%=MOD; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); initFact(10000); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>计数问题</tag>
        <tag>切比雪夫距离</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游荡计数]]></title>
    <url>%2F2018%2F12%2F09%2F%E6%B8%B8%E8%8D%A1%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Description 给定一个$n\times n$的方阵$A$，求$A^m\mod 1e9+9$ $m$以二进制形式给出 $n \le 50,\ m \le 2^{10000}$ Solution 矩阵快速幂优化裸题，常系数线性齐次递推中的步骤。再做一次这道题算是加深一下对思路的印象吧 由于$A$的特征多项式$f(x)$是一个以$x$为自变量的$n$次多项式，我们可以通过计算相应的行列式求得$f(0),f(1),\dots,f(n)$，再利用拉格朗日插值插出$f(x)$。这一步的时间复杂度为$O(n^4)$ 令多项式$x^n$对$f(x)$进行取模，即$x^n \mod f(x)=f(x)g(x)+r(x)$ 令$A$为自变量$x$代入其中，又根据Cayley-Hamilton定理得$f(A)=0$，则有 \begin{aligned} A^n \mod f(A)&=f(A)g(A)+r(A)\\ \because f(A)&=0\\ \therefore A^n \mod f(A)&=r(A)\\ \because A^n \mod f(A) &= A^n \\ \therefore A^n &= r(A) \mod 1e9+9 \end{aligned} 我们直接求出$r(x)$即可，即在快速幂计算$x^n$的同时，将结果对$f(x)$进行取模。这一步使用朴素取模即可，时间复杂度$O(n^2 \log_2 m)$ 最后，将$A$代入$r(x)$中即可得到答案 总时间复杂度$O(n^4+n^2 \log_2 m)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int MOD=1e9+9;const int N=60;const int L=10010;int n;int mlen,m[L];struct Mat&#123; int n,m; int a[N][N]; Mat()&#123; n=m=0; reset(); &#125; Mat(int _n,int _m)&#123; n=_n; m=_m; reset(); &#125; void reset()&#123; memset(a,0,sizeof a); &#125; void setUnit()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=(i==j); &#125; void print()&#123; for(int i=1;i&lt;=n;i++,puts("")) for(int j=1;j&lt;=m;j++) printf("%d ",a[i][j]&gt;=0?a[i][j]:a[i][j]+MOD); &#125; friend Mat operator + (const Mat &amp;u,const Mat &amp;v)&#123; Mat res=Mat(u.n,u.m); for(int i=1;i&lt;=u.n;i++) for(int j=1;j&lt;=u.m;j++) res.a[i][j]=(u.a[i][j]+v.a[i][j])%MOD; return res; &#125; friend Mat operator - (const Mat &amp;u,const Mat &amp;v)&#123; Mat res=Mat(u.n,u.m); for(int i=1;i&lt;=u.n;i++) for(int j=1;j&lt;=u.m;j++) res.a[i][j]=(u.a[i][j]-v.a[i][j])%MOD; return res; &#125; Mat operator * (const int k)&#123; Mat res=Mat(n,m); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) res.a[i][j]=1ll*k*a[i][j]%MOD; return res; &#125; friend Mat operator * (const Mat &amp;u,const Mat &amp;v)&#123; Mat res=Mat(u.n,v.m); for(int i=1;i&lt;=u.n;i++) for(int j=1;j&lt;=v.m;j++)&#123; LL t=0; for(int k=1;k&lt;=u.m;k++) t+=1ll*u.a[i][k]*v.a[k][j]%MOD; res.a[i][j]=t%MOD; &#125; return res; &#125;&#125;a,unit;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void readData()&#123; scanf("%d",&amp;n); static char str[L]; scanf("%s",str); mlen=strlen(str); for(int i=0;i&lt;mlen;i++) m[i]=(str[mlen-1-i]=='1'); a=Mat(n,n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a.a[i][j]); unit=Mat(n,n); unit.setUnit();&#125;int cp[N*10];int cpInv;int GaussianDet(int n,int a[][N])&#123; int res=1; for(int i=1;i&lt;=n;i++)&#123; if(!a[i][i])&#123; int t; for(t=i;t&lt;=n&amp;&amp;!a[t][i];t++); if(t&lt;=n&amp;&amp;a[t][i])&#123; res=-res; swap(a[i],a[t]); &#125; else return 0; &#125; int inv=fastPow(a[i][i],MOD-2); for(int j=i+1;j&lt;=n;j++)&#123; int t=1ll*a[j][i]*inv%MOD; for(int k=i;k&lt;=n;k++) (a[j][k]-=1ll*t*a[i][k]%MOD)%=MOD; &#125; &#125; for(int i=1;i&lt;=n;i++) res=1ll*res*a[i][i]%MOD; return res;&#125;void Lagrange(int n,int *x,int *y,int *res)&#123; static int a[N],b[N],c[N]; memset(res,0,sizeof(int)*(n+3)); memset(a,0,sizeof(int)*(n+3)); a[0]=1; for(int i=0;i&lt;=n;i++)&#123; for(int j=i+1;j;j--) a[j]=(a[j-1]-1ll*x[i]*a[j]%MOD)%MOD; a[0]=-1ll*x[i]*a[0]%MOD; &#125; for(int i=0;i&lt;=n;i++)&#123; memcpy(b,a,sizeof(int)*(n+3)); memset(c,0,sizeof(int)*(n+3)); for(int j=n;j&gt;=0;j--)&#123; c[j]=b[j+1]; (b[j]+=1ll*x[i]*c[j]%MOD)%=MOD; &#125; int deno=1; for(int j=0;j&lt;=n;j++) if(j!=i) deno=1ll*deno*(x[i]-x[j])%MOD; deno=fastPow(deno,MOD-2); for(int j=0;j&lt;=n;j++) (res[j]+=1ll*y[i]*c[j]%MOD*deno%MOD)%=MOD; &#125;&#125;void calcCP()&#123; static int x[N],y[N]; static Mat s(n,n); for(int i=0;i&lt;=n;i++)&#123; x[i]=i; s=(unit*i)-a; y[i]=GaussianDet(n,s.a); &#125; Lagrange(n,x,y,cp); cpInv=fastPow(cp[n],MOD-2);&#125;void polyMul(int n,int *a,int *b,int *c)&#123; static int t[N*10]; for(int i=0;i&lt;=(n&lt;&lt;1);i++) t[i]=0; for(int i=0;i&lt;=n;i++) for(int j=0;j&lt;=n;j++) (t[i+j]+=1ll*a[i]*b[j]%MOD)%=MOD; for(int i=(n&lt;&lt;1);i&gt;=n;i--)&#123; int k=1ll*t[i]*cpInv%MOD; for(int j=0;j&lt;=n;j++) (t[i-(n-j)]-=1ll*k*cp[j]%MOD)%=MOD; &#125; for(int i=0;i&lt;=n;i++) c[i]=t[i];&#125;int r[N*10];void CayleyHamiton()&#123; static int x[N*10]; x[1]=1; r[0]=1; for(int i=0;i&lt;mlen;i++,polyMul(n,x,x,x)) if(m[i]) polyMul(n,r,x,r);&#125;void solve()&#123; static Mat ans(n,n); static Mat now(n,n); now.setUnit(); for(int i=0;i&lt;=n;i++)&#123; ans=ans+(now*r[i]); now=now*a; &#125; ans.print();&#125;int main()&#123; readData(); calcCP(); CayleyHamiton(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>Cayley-Hamilton定理</tag>
        <tag>拉格朗日插值</tag>
        <tag>特征多项式</tag>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回文自动机的双向插入]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%9A%84%E5%8F%8C%E5%90%91%E6%8F%92%E5%85%A5%2F</url>
    <content type="text"><![CDATA[双向插入PAM应该是学PAM时就应该知道的基础操作，然而其实我并不会…… 目标 维护一个字符串的回文自动机，支持在字符串的前/后方追加一个字符 双向插入PAM 双向PAM大体上与经典PAM没有什么不同。由于回文串的特殊性，在前端插入字符带来的更新，PAM也基本能自适应 总地来说，不同点如下： 普通PAM只需要记录上一次的结束位置，而双向PAM需要记录上一次向前插入的结束位置以及上一次向后插入的结束位置 查询fail的函数要多带一个选项：是正着找结尾的fail，还是反着找开头的fail？代码相应镜像即可 若进行一次前/后方插入后，当前结束位置的长度恰好等于全串长度，则令后/前方的结束位置也为当前结束位置。这一步是为了维护“结束位置为最长回文前/后缀”的性质，且可以证明这样维护是完全及时与必要的 例题 请维护一个双向PAM，每插入一次字符后，输出回文串总数以及本质不同的回文串数量 操作数$n \le 5*10^5$，字符集$C\le 4$ ```c++ include using namespace std;typedef long long LL;const int N=200010;const int C=4;int n;namespace PAM{ int a[N*2],pos[2]; int sz,last[2]; int trans[N][C]; int len[N]; int fail[N]; int dep[N]; LL ans; void init(){ pos[0]=N; pos[1]=N-1; a[N-1]=a[N]=-1; sz=1; len[0]=0; len[1]=-1; fail[0]=1; dep[0]=0; last[0]=last[1]=0; } int getFail(int u,int d){ if(d) for(;a[pos[1]-len[u]-1]!=a[pos[1]];u=fail[u]); else for(;a[pos[0]+len[u]+1]!=a[pos[0]];u=fail[u]); return u; } void insert(int c,int d){ if(!d){ a[—pos[0]]=c; a[pos[0]-1]=-1; } else{ a[++pos[1]]=c; a[pos[1]+1]=-1; } int u=getFail(last[d],d); if(!trans[u][c]){ int v=++sz; len[v]=len[u]+2; fail[v]=trans[getFail(fail[u],d)][c]; dep[v]=dep[fail[v]]+1; trans[u][c]=v; } u=trans[u][c]; last[d]=u; if(len[u]==pos[1]-pos[0]+1) last[d^1]=u; ans+=dep[last[d]]; }}void solve(){ scanf(“%d”,&amp;n); char cmd[10],cha[10]; for(int i=1;i&lt;=n;i++){ scanf(“%s%s”,cmd,cha); PAM::insert(cha[0]-‘a’,cmd[0]==’r’); printf(“%lld %d\n”,PAM::ans,PAM::sz-1); }}int main(){ PAM::init(); solve(); return 0;}`&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>字符串---回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小回文分解]]></title>
    <url>%2F2018%2F12%2F08%2F%E6%9C%80%E5%B0%8F%E5%9B%9E%E6%96%87%E5%88%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[目标 给定一个字符串$S$，你需要将其分割成若干个连续子串，使得每一个连续子串都是回文串 求最小分割段数 朴素做法$O(n^2)$ 考虑DP：$f_i$表示$S$中前$i$个字符构成的字符串的最小分割段数，则有转移： \begin{aligned} f_0&=0\\ f_i&=\min\{f_j+1\mid S_{j+1}...S_i为回文串\} \end{aligned} 实现上，一边DP一边同步构造前$i$个字符的回文自动机，从末端节点开始不断跳fail即可获取所有可转移的回文后缀，利用$\text{len}$计算出相应的$j$即可 12for(int u=last;u!=0;u=fail[u]) f[end]=min(f[end],f[end-len[u]]+1); 更优的做法$O(n \log n)$ 我们还是采用上述的DP式子，一边DP一边构造前缀的回文自动机，并考虑如何优化转移 需要维护的值 首先，自动机的每个节点$u$需要额外维护两个值： $\text{diff}[u]=\text{len}[u]-\text{len}[\text{fail}[u]]$ $\text{slink}[u]=$$u$在fail树上深度最大的祖先$anc$，满足$\text{diff}[u]\neq\text{diff}[anc]$ 维护方式是显然的，每插入一个节点时$O(1)$计算即可 两个定理 为了引出算法，我们需要先了解两个定理： 定理1：对于fail树上的任意一个节点$u$，其通过$u=\text{slink}[u]$迭代至多$O(\log n)$次后会到达树根。 可以发现，对于$u$往上一直到$\text{slink}[u]$的这些点，父子长度的差值都相等。因此，定理1也可以理解为任意一点往上走，长度减小的变化量至多有$O(\log n)$个 定理2：若当前已构造出了前$i$个字符的后缀自动机，最后停留点为$u$，且$u$不为所在等差长度链的链顶（若$u$恰为链顶，我们会在后面提及处理方案），$\text{fail}[u]$代表的回文串为$p$，则有： $\text{fail}[u]$倒数第二次出现的结束位置必定为$i-\text{diff}[u]$，也即该位置之右、$i$之左不可能出现$p$ 在前$i-\text{len}[u]$个字符构成的回文自动机的fail树中，$\text{fail}[u]$与所有后继的长度之差皆不等于$\text{diff}[\text{fail}[u]]$，也即$u$为其所在等差长度链的链底 1.的证明很显然：首先，由于回文串的特殊性，$p$在$u$代表的回文串的前端也会出现；其次，假设在那个范围中出现了$p$的结束位置，我们总可以引出比$p$更长的回文串，因此$\text{fail[u]}$不应该对应$p$，矛盾 2.的话，暂且先不详细讲了 算法本体 与刚才的暴力枚举fail树上的祖先不同，我们依次$O(1)$计算一条等差长度链上的点的贡献，总共有$O(\log n)$条链，因此单次更新的时间复杂度为$O(\log n)$ 12for(int u=last;u!=0;u=slink[u]) // 使用u所在的等差长度链的每一个长度len,用f[i-len]更新f[i] 注释所写的是算法效果，而非具体实现 为何要将长度等差的回文串放在一起转移呢？因为等差可以带来非常巧妙的转化： 考虑第一个等差长度链，后续的等差长度链同理： 设公差为$d$，则可用于转移回文串的长度为$\text{len}[u],\text{len}[u]-d,\text{len}[u]-2d,\dots,\text{len}[u]-kd$，它们都是$u$代表的回文串的某一个后缀 除去第一项，我们将其余回文串翻转到$u$的回文串的前方，此时可以发现：除了$\text{len}[u]-kd$这个转移长度，我们曾经在计算前$i-d$个字符的答案递归并迭代到$\text{fail}[u]$时（必定会迭代到$\text{fail}[u]$)，已经将$f[i-\text{len}[u]],f[i-\text{len}[u]-d],\dots$取过最小值。我们只需要额外考虑上$\text{len}[u]-kd$即可 整个过程利用了等差的性质，当前的转移位置绝大部分都是翻转后的转移位置，虽然不一一对应，但是集合几乎相等 且根据定理2，我们没有考虑$(i-d,i)$这段区间的必要，可以直接跳过——因为在这里结尾的回文串无一与我们要考虑的回文串相关 考虑对于每一个点$u$维护一个值$g[u]$，表示上一次迭代到$u$时，记总进程的前缀长度为$i’$，$u$提供给当时的$f_{i’}$的最优值是多少（即下述伪代码中第5行的”g[u]”） 则最终可得一个基于继承的优秀算法： 123456for(int u=last;u!=0;u=slink[u])&#123; g[u]=f[i-(len[slink[u]]+diff[u])]; // 额外考虑len[u]-kd这个长度的转移 if(diff[u]==diff[fail[u]]) g[u]=min(g[u],g[fail[u]]); // 可以继承大量的最小值 f[i]=min(f[i],g[u]+1);&#125; 总时间复杂度$O(n \log n)$ Tips 实现上，对于回文自动机的两个特殊根，我们并不需要做什么特判——两个特殊根的$\text{len}$可以很好地适应本算法]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>字符串---回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树]]></title>
    <url>%2F2018%2F12%2F04%2F%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Description Solution 题目给出的模型很复杂，因此我们需要对题意先进行一步转化： 可以证明，一棵满二叉树不包含$m​$连树，当且仅当对于任意一条从根节点出发走到叶子节点的路径，向左走的次数都少于$m-1​$ 证明如下： 先证必要性：使用反证法：若存在一条到叶路径满足向左走的次数不少于$m-1$，则显然可以找出一棵能操作得到的$m$连树。故必要性成立 再证充分性：提取一棵$m$连树的条件是原树中存在类似的树形。由于所有到叶路径的向左次数少于$m-1$，感性理解一下，我们无法从这种满二叉树中提出$m$连树 故二者满足充分必要性 考虑一棵满二叉树的括号序列表示：从只有根节点开始，左括号代表添加一个左儿子并进入，右括号代表回溯到DFS栈中最深的、没有右儿子的点，为其添加一个右儿子并进入。可以发现，一棵有$n$个叶子满二叉树，唯一对应了一个长度为$2(n-1)$的合法括号序列，反之也唯一对应 若把左右括号分别看成1和-1，一棵满二叉树的任意到叶路径向左走的次数皆少于$m-1$，当且仅当其对应的括号序列的任意前缀和小于$m-1$ 问题转化为：有多少长度为$2n$的合法括号序列，满足任意前缀和小于$m-1$？（注意我们已经用$n$来表示原问题的$n-1$了） 首先，总方案数为$2n \choose n$ 对于不合法的括号序列，考虑其特征：我们尝试减去那些碰到过$-1$和$m-1$的括号序列：考虑碰到过$-1$的括号序列，我们将第一个前缀和等于$-1$的位置之后的所有括号反转，则可以得到一个结束时前缀和等于$-2$的括号序列；可以发现，反转前的不合法序列，和反转后的序列唯一对应。后者的总数为${2n \choose n-1}$，则前者也为$2n \choose n-1$。这个组合数的原理是：总数的一半减去总和之差的一半，恰好等于某一个括号的数量，做组合数即可。同理，对于触碰到$m-1$的序列，我们将第一个前缀和等于$m-1$的位置之后的所有括号反转，可得结束时前缀和等于$2m-2$的序列，因此总数为${2n \choose m-1}$ 问题在于，我们可能减去了先碰$-1$后碰$m-1$、以及先碰$m-1$后碰$-1$的那些序列，应该把他们加回来。我们已经可以看出容斥的影子：每一种不合法情况都可以表示为$0\rightarrow-1\rightarrow m-1\rightarrow -1 \rightarrow\dots \rightarrow 0$或者$0 \rightarrow m-1 \rightarrow -1 \rightarrow m-1 \rightarrow \dots\rightarrow 0$的形式，其长度决定了容斥系数。我们枚举长度，考虑该长度的两种形式的情况总数：我们用之前类似的思想不断反转序列，直到变为$0 \rightarrow x \rightarrow 0$的形式，那么方案数即为$2n \choose n+\frac x2$ 时间复杂度为$O(n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;using namespace std;typedef long long LL;const int MOD=998244353;const int N=10000010;int n,m;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); n--;&#125;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;int fact[N*2],iact[N*2];void initFact(int n)&#123; fact[0]=1; for(int i=1;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;inline int S(int delta)&#123; return C(n&lt;&lt;1,n+(delta&gt;&gt;1));&#125;void calc()&#123; LL ans=S(0); int s1=0,s2=0; for(int len=1,sgn=-1;s1&lt;=(n&lt;&lt;1)||s2&lt;=(n&lt;&lt;1);len++,sgn=-sgn)&#123; s1+=(len&amp;1)?2:((m&lt;&lt;1)-2); ans+=sgn*S(s1); s2+=(len&amp;1)?((m&lt;&lt;1)-2):2; ans+=sgn*S(s2); &#125; ans%=MOD; printf("%lld\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); initFact(20000000); calc(); return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>括号序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道神题]]></title>
    <url>%2F2018%2F11%2F29%2Fxsy2205%20SBT%2F</url>
    <content type="text"><![CDATA[Description 给一张$n$个点的无向图，初始时没有任何边 现在有$m$次操作，每次操作会加入一条带权无向边。保证没有重边，但可能有自环 定义一个点集$V$的权值为：仅有一个端点在$V$中的边的边权的异或和 请在每一次操作之后，输出所有点集的权值最大值 权值以二进制的形式给出，每一个二进制的长度不超过$l$ $n \le 500,\ m \le 1000,\ l &lt;1000$ Solution “奇有偶无”的形式很容易让我们联想到异或：定义一个节点$u$的权值$a_u$为所有连着它的边的权值异或和，则一个点集$V$的权值即所有$V$内点的权值异或和。如果我们能维护所有节点的权值的线性基，那么求$V$的权值最大值就是一个很容易的问题 那么问题来了：如何使线性基中的某一个元素$a_p$异或上一个值$x$？ 考虑对于线性基内部的每一个有值的行，记录它的值以及它是由哪一些点异或得来的（称为来源）。当我们尝试将$a_p$额外异或上一个值$x$时，我们找到所有来源中有$a_p$的向量中，最靠后的那一个向量（有零行最优，其次为第一个1最靠后），记为$\alpha$，我们将其余的所有来源有$a_p$的向量异或上$\alpha$，则它们的来源中将不再含有$a_p$ 现在，线性基中唯一一个与$a_p$相关的向量只有$\alpha$，我们将$\alpha$备份一份，从线性基中将其删除，令$\alpha$异或上$x$后，将$\alpha$正常地插入线性基即可 加上bitset压位即可解决$l$过大的问题 时间复杂度$O(\frac{nm(l+n)}{32})$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;using namespace std;const int N=510;const int L=1000;typedef bitset&lt;L&gt; BS;int n,m;namespace LB&#123; BS f[N],g[N]; int who[L]; void init()&#123; for(int i=0;i&lt;n;i++) g[i][i]=true; memset(who,-1,sizeof who); &#125; void change(int id,BS &amp;xorVal)&#123; int pos=-1; for(int i=0;i&lt;n;i++) if(f[i].none()&amp;&amp;g[i][id])&#123; pos=i; break; &#125; if(pos==-1) for(int i=0;i&lt;L;i++) if(who[i]!=-1&amp;&amp;g[who[i]][id])&#123; pos=who[i]; who[i]=-1; break; &#125; for(int i=0;i&lt;n;i++) if(i!=pos&amp;&amp;g[i][id])&#123; f[i]^=f[pos]; g[i]^=g[pos]; &#125; f[pos]^=xorVal; for(int i=L-1;i&gt;=0;i--) if(f[pos][i])&#123; if(who[i]==-1)&#123; who[i]=pos; break; &#125; f[pos]^=f[who[i]]; g[pos]^=g[who[i]]; &#125; &#125; void queryMax()&#123; static BS ans; ans.reset(); for(int i=L-1;i&gt;=0;i--) if(who[i]!=-1&amp;&amp;!ans[i]) ans^=f[who[i]]; bool ok=false; static char out[L]; int cnt=0; if(ans.none()) out[cnt++]='0'; for(int i=L-1;i&gt;=0;i--) if(ans[i]||ok)&#123; ok=true; out[cnt++]=('0'+ans[i]); &#125; printf("%s\n",out); &#125;&#125;void solve()&#123; scanf("%d%d%d",&amp;n,&amp;n,&amp;m); LB::init(); int u,v; static char w[L]; static BS val; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%s",&amp;u,&amp;v,w); u--; v--; val.reset(); reverse(w,w+strlen(w)); for(int i=strlen(w)-1;i&gt;=0;i--) if(w[i]=='1') val[i]=true; LB::change(u,val); LB::change(v,val); LB::queryMax(); &#125;&#125;int main()&#123; solve(); return 0;&#125;]]></content>
      <tags>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCIS]]></title>
    <url>%2F2018%2F11%2F29%2Fxsy3057LCIS%2F</url>
    <content type="text"><![CDATA[Description 给一个长度为$n$的整数序列 你只可以对这个序列进行一种操作：$rev(l,r)$：将$a_l,…,a_r$翻转，操作代价为$r-l+1$ 请你对序列进行若干次操作，最大化其最长上升子序列的长度，且操作的总代价不超过$4e6$ 当且仅当你操作后的序列的LIS与理论值相同时，你的程序才会被判对 $n \le 32000$ Solution 其实，题目就是要让我们在限定代价之内将序列排序……所以，操作的目标就确定了 一个简单的想法是按权值从小到大的顺序将元素依次前提，但这样显然不优 我们可以隐约感受到，可能存在同一次操作可以同时运送若干个元素的情况，因此考虑分治算法 如果序列中只用0或1，我们该如何处理？考虑这样一个分治过程：每次分治$[l,r]$的目的是将$[l,r]$的0全部提到左边、将1全部提到右边。我们先递归左右两个区间，回溯完成后，当前区间应该是形如$0000111100011$的形式，我们直接对中间的$1111000$做一次$rev$操作，即可达到目标。可以发现，总操作次数是$O(n \log n)$的 如果序列中的元素权值不仅仅是0或1，怎么办？考虑到$O(n \log n)$的代价还远远低于限制，我们可以考虑对权值进行分治，并将问题转化成上述分治过程：分治权值$[l,r]$时（同时对应着下标区间$[l_0,r_0]$），我们的目的是将$[l_0,r_0]$内所有不超过$mid$的数放在左边，其余放在右边。这个过程显然可以通过重标号+调用上述分治直接实现。外层分治执行完毕后，整个序列就会按照权值排好序。可以发现，外层分治与快速排序有异曲同工之妙 总操作代价为$O(n \log^2 n)$，实测大约只需要$190$万的代价 Summary 题目的要求可能只是障眼法，真实的目标可能是一个比较显然和经典的模型 区间排布问题，多用分治思想考虑 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;namespace IO&#123; const int S=10000000; char inBuf[S],outBuf[S]; int inPos,outPos; void load()&#123; fread(inBuf,1,S,stdin); inPos=0; &#125; void flush()&#123; fwrite(outBuf,1,outPos,stdout); &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeChar(char c)&#123; outBuf[outPos++]=c; &#125; void writeInt(int x,char endc='\n')&#123; static int sta[20],top; if(!x) writeChar('0'); else&#123; for(top=0;x;x/=10) sta[++top]=x%10; while(top) writeChar('0'+sta[top--]); &#125; writeChar(endc); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=100010;const int ANS=4000010;int n;int a[N],maxa;int step,ans[ANS][2];void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++)&#123; a[i]=getInt(); maxa=max(maxa,a[i]); &#125;&#125;int b[N];void flip(int l,int r)&#123; if(l+1&gt;=r) return; reverse(b+l,b+r); reverse(a+l,a+r); step++; ans[step][0]=l; ans[step][1]=r-1;&#125;int solve2(int l,int r)&#123; if(l==r) return b[l]?l:l+1; int mid=(l+r)&gt;&gt;1; int lp=solve2(l,mid); int rp=solve2(mid+1,r); flip(lp,rp); return l+(lp-l)+(rp-(mid+1));&#125;void solve1(int l,int r,int vl,int vr)&#123; if(l==r||vl==vr||l&gt;r||vl&gt;vr) return; int vmid=(vl+vr)&gt;&gt;1; for(int i=l;i&lt;=r;i++) b[i]=(a[i]&gt;vmid); int mid=solve2(l,r)-1; solve1(l,mid,vl,vmid); solve1(mid+1,r,vmid+1,vr);&#125;void printAnswer()&#123; writeInt(step); for(int i=1;i&lt;=step;i++)&#123; writeInt(ans[i][0],' '); writeInt(ans[i][1]); &#125;&#125;int main()&#123; IO::load(); readData(); solve1(1,n,0,maxa); printAnswer(); IO::flush(); return 0;&#125;]]></content>
      <tags>
        <tag>转化</tag>
        <tag>分治</tag>
        <tag>思考题</tag>
        <tag>好题</tag>
        <tag>可做未做</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Proposition]]></title>
    <url>%2F2018%2F11%2F29%2Fxsy3050Proposition%2F</url>
    <content type="text"><![CDATA[Description 公式$Q$满足： $Q$中的运算符共有$n$个 不论$x_i$如何取值，$P$总为真 $n \le 70,\ k \le 4,\ $询问总数$q \le 500$ Solution 如果直接从“是否恒为真”的角度去统计，做法会比较困难。考虑到$k$较小，我们可以通过一个取巧的方式：我们枚举所有$x$的取值情况，判断结果是否都为真即可 首先，考虑统计$Q$：总共有$2^k$种$x$的赋值方式，每一种方式都对应了$Q$是真还是假，因此每一个$Q$唯一对应了 一个$2^{2^k}$的二进制数，表示在每一种赋值方式中$Q$的真假。我们称这个二进制数位特征值。考虑DP出每一个特征值的$Q$的数量，具体而言： 设$f_{i,j}$表示：已经使用符号数为$i$、特征值为$j$的$Q$的数量 f_{i,j}=f_{i-1,\neg j}+\sum_{k=0}^{i-1}\sum_{a\rightarrow b=j}f_{k,a}*f_{i-1-k,b} 直接DP的复杂度为$O(n^22^{2^{k+1}}))$，无法处理$k=4$时的情况 注意到某一个$\sum$的形式是二元运算卷积，考虑使用FWT加速这个转移 $a \rightarrow b\Leftrightarrow\neg a \or b$ 对于每一个$f_k$，我们记录对它进行FWT后的结果，再记录先对其下标取反后FWT的结果，转移时，第二个$\sum$就省去了枚举，线性扫一遍即可 时间复杂度$O(n^22^{2^k})$ 考虑如何回答一个询问$P$：我们可以枚举$x$的所有取值，计算在当前枚举情况下，$Q$为真时的结果是否为真以及$Q$为假时的结果是否为真。这样，我们就可以得到对于符合要求的$Q$的相应限制：$Q$的特征值的某一位可以是什么（不可以是什么）。有了上述DP的结果，我们只需要枚举所有特征值并统计合法的$Q$总数即可 这一步要用到表达式求值 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MOD=1e9+7;const int L=4010;int n,m;int sz1,sz2;inline int in(int x,int i)&#123; return (x&gt;&gt;i)&amp;1;&#125;inline int bit(int i)&#123; return (1&lt;&lt;i);&#125;void fwt(int n,int *a,int f)&#123; int u,v; for(int i=2;i&lt;=n;i&lt;&lt;=1) for(int j=0;j&lt;n;j+=i) for(int k=0;k&lt;(i&gt;&gt;1);k++)&#123; u=a[j+k]; v=a[j+(i&gt;&gt;1)+k]; if(!f) a[j+(i&gt;&gt;1)+k]=(u+v)%MOD; else a[j+(i&gt;&gt;1)+k]=(v-u)%MOD; &#125;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); sz1=(1&lt;&lt;m); sz2=(1&lt;&lt;sz1);&#125;int f[75][66000],r[75][66000],g[75][66000];void calcArray(int i)&#123; memcpy(g[i],f[i],sizeof(int)*sz2); fwt(sz2,f[i],1); for(int s=0;s&lt;sz2;s++) r[i][(sz2-1)^s]=f[i][s]; fwt(sz2,r[i],0);&#125;void dp()&#123; for(int i=0;i&lt;m;i++) for(int s2=0;s2&lt;sz2;s2++)&#123; bool flag=true; for(int s1=0;s1&lt;sz1;s1++) if(in(s1,i)^in(s2,s1))&#123; flag=false; break; &#125; f[0][s2]+=flag; &#125; fwt(sz2,f[0],0); calcArray(0); for(int i=1;i&lt;=n;i++)&#123; memcpy(f[i],r[i-1],sizeof(int)*sz2); for(int k=0;k&lt;i;k++) for(int s=0;s&lt;sz2;s++) (f[i][s]+=1ll*r[k][s]*g[i-1-k][s]%MOD)%=MOD; calcArray(i); &#125;&#125;void translate(int n,char *str,int &amp;len,int *a)&#123; static int sta[L],top; len=0; top=0; for(int i=0;i&lt;n;i++)&#123; if(str[i]=='(') sta[++top]='('; else if(str[i]==')')&#123; while(sta[top]!='(') a[++len]=sta[top--]; top--; &#125; else if(str[i]=='x'||str[i]=='Q') a[++len]=(str[i]=='x')?(str[++i]-'1'):m; else&#123; while(top&amp;&amp;sta[top]!='(') a[++len]=sta[top--]; sta[++top]=str[i]; if(str[i]=='-') i++; &#125; &#125; for(;top;top--) if(sta[top]!='(') a[++len]=sta[top];&#125;bool express(int len,int *a,int xv,bool qv)&#123; static bool sta[L]; static int top; top=0; for(int i=1;i&lt;=len;i++) if(a[i]&lt;=m) sta[++top]=(a[i]&lt;m)?in(xv,a[i]):qv; else&#123; if(a[i]=='~') sta[top]=(!sta[top]); else&#123; bool y=sta[top--]; bool x=sta[top--]; sta[++top]=(!x)|y; &#125; &#125; return sta[top];&#125;void answerQuery()&#123; int m,ans; static char str[L]; static int a[L],len; static int can[20]; scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%s",str); translate(strlen(str),str,len,a); for(int s=0;s&lt;sz1;s++)&#123; can[s]=0; can[s]+=express(len,a,s,false); can[s]+=2*express(len,a,s,true); &#125; ans=0; for(int s2=0;s2&lt;sz2;s2++)&#123; bool flag=true; for(int s1=0;s1&lt;sz1;s1++) if(!in(can[s1],in(s2,s1)))&#123; flag=false; break; &#125; if(flag) (ans+=f[n][s2])%=MOD; &#125; printf("%d\n",ans&gt;=0?ans:ans+MOD); &#125;&#125;int main()&#123; readData(); dp(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>FWT</tag>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Password]]></title>
    <url>%2F2018%2F11%2F29%2Fxsy3049Password%2F</url>
    <content type="text"><![CDATA[Description Solution 打一打表就发现，第2行为第1行的变换，第3行为第2行的变换；对于$\forall i&gt;3$，第$i$行与第$i-2$行完全相同 第1行用数组维护即可。下面考虑如何维护第2行和第3行 设三行分别为$a_i,\ b_i,\ c_i$：$b_i$的意义为$a_i$在$a$内值相同的位置之中排第几（简称$a_i$的排名），而$c_i$的意义为$a_i$的排名在排名相同的位置中排第几 思考一段时间后发现，$b_i$的维护比较简单，而$c_i$的维护非常毒瘤——难以使用树套树之类的数据结构具象化 考虑分块，以下的数字，都来源于$a$：设$f_{i,j}$表示前$i$个块中，$j$出现了几次，修改和查询$b_i$显然 设$g_{i,j}$表示前$i$个块中，每一个数的排名出现了几次 如果没有修改，询问$c_p$时，我们得先算出$b_i$（即求得$a_i$的排名），然后以$b_i$为关键字，使用$g$以及暴力查询$p$及其之前有多少个排名为$p$的位置即可 精华在于$g$的修改：若要将$ax$改成$y$，我们发现，原来在$x$之后的、与$a_x$相同的值，它们的排名都减小了1，那么对于$x$所在块及以后的块$i$，它们考虑的是前缀中所有排名的出现次数，我们发现，$a_x$原排名不见了，其余的顺次前移，在$g$上没有任何影响和变动；最后唯一的变化在于$f{i,ax}$也就是前$i$个块中，$a_x$的位置的排名最大值，不见了，因此执行$g{i,f_{i,a_x}}—$即可 加入同理 时间复杂度$O(n\sqrt n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define SP(x) (B*(x))#define EP(x) (SP((x)+1)-1)#define BN(x) ((x)/B)using namespace std;namespace IO&#123; const int L=20000000; char inBuf[L]; int inPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int N=100010;const int B=1800;int n;int a[N],maxa;int f[400][N],g[400][N];void readData()&#123; n=getInt(); for(int i=0;i&lt;n;i++)&#123; a[i]=getInt(); maxa=max(maxa,a[i]); &#125;&#125;void init()&#123; for(int i=0,id=0;i&lt;n;i+=B,id++)&#123; if(id) for(int j=1;j&lt;=maxa;j++)&#123; f[id][j]=f[id-1][j]; g[id][j]=g[id-1][j]; &#125; for(int j=i;j&lt;n&amp;&amp;j&lt;i+B;j++) g[id][++f[id][a[j]]]++; &#125;&#125;void modify(int pos,int val)&#123; for(int id=BN(pos);SP(id)&lt;n;id++) g[id][f[id][a[pos]]--]--; a[pos]=val; for(int id=BN(pos);SP(id)&lt;n;id++) g[id][++f[id][a[pos]]]++;&#125;int query(int x,int y)&#123; if(x==1) return a[y]; int id=BN(y); int res0=id?f[id-1][a[y]]:0; for(int i=SP(id);i&lt;=y;i++) res0+=(a[i]==a[y]); return res0; int res1=id?g[id-1][res0]:0; static int sum[N]; for(int i=SP(id);i&lt;=y;i++) res1+=(((id?f[id-1][a[i]]:0)+(++sum[a[i]]))==res0); for(int i=SP(id);i&lt;=y;i++) sum[a[i]]=0; return res1;&#125;void answerQuery()&#123; int m; int opt,x,y; m=getInt(); for(int i=1;i&lt;=m;i++)&#123; opt=getInt(); x=getInt(); y=getInt()-1; if(opt==1) modify(y,x); else printf("%d\n",query(x,y)); &#125;&#125;int main()&#123; IO::load(); readData(); init(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
        <tag>可做未做</tag>
        <tag>找规律</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[景中人]]></title>
    <url>%2F2018%2F11%2F25%2Fxsy2693%E6%99%AF%E4%B8%AD%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[Description 在二维坐标系的第一象限有$n$个整点$(x,y)$ 求最少需要使用多少个面积不超过$S$的、下底边紧贴$x$轴的矩形，才能覆盖所有整点？ 本题有多组数据，数据组数为$T$ $T \le 10,\ n \le 100,\ x \le 310^6,\ 1\le y \le S \le 210^5$ Solution 首先，对于横坐标相同的点，显然只有纵坐标最大的点是必要的，其余的点显然可以删去 考虑最优解中任意两个矩形的性质： 不存在一个矩形完全包含另一个矩形的情况 若一个矩形的横坐标包含另一个矩形的横坐标、或两个矩形完全相离：无特殊性质 若两个矩形的横坐标相交：我们完全可以将两个矩形相交的部分向两端拨开，简化方案 所以总是存在这样一个最优解，满足所有矩形横坐标范围之间的关系只有相离或内含，也就是父子关系构成一棵树 离散化纵坐标并去除冗余点，按横坐标排序后，可以通过下标直接作为横坐标的离散化 我们考虑一个DP：$f_{l,r}$表示覆盖第$l$个横坐标到第$r$个横坐标的最高点所需的最少矩形数 转移如下： $[l,r]$可能由多个不相交的矩形（即有多个后继）共同完成，我们枚举分界点$mid$，用$f{l,mid}+f{mid+1,r}$更新 $[l,r]$只有一个矩形（只有一个后继），这个矩形的横坐标必然是$[l,r]$（如不是，则该情况属于1.），贪心地想，这个矩形必然是越高越好，因此我们可以算出最高高度为$\lfloor\frac S{r-l}\rfloor$，用$[该矩形下方有关键点]+f_{l,r}$更新 此时，我们发现状态表示出了问题：状态并没有体现高度。所以我们必须多加一维：设$f_{l,r,h}$表示：覆盖$[l,r]$范围内的、高度不超过$h$的关键点最少需要多少矩形，则转移变为： f_{l,mid,h}+f_{mid+1,r,h}\rightarrow f_{l,r,h}\\ [\frac S{r-l}及以下、h及以上还有未被覆盖的关键点]+f_{l,r,\frac S{r-l}+1}\rightarrow f_{l,r,h} 由于转移顺序比较难考虑，使用记忆化搜索实现即可 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int INF=1e9;const int N=110;const int S=200010;int n,s;struct Point&#123; int x,y;&#125;a[N];inline void applyMin(int &amp;x,int y)&#123; if(y&lt;x) x=y;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;s); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].x,&amp;a[i].y);&#125;bool cmpXY(const Point &amp;a,const Point &amp;b)&#123; if(a.x!=b.x) return a.x&lt;b.x; return a.y&gt;b.y;&#125;int d[N],dcnt;int diz[S];bool g[N][N][N];void init()&#123; sort(a+1,a+1+n,cmpXY); int cnt=0; for(int i=1,j;i&lt;=n;i=j)&#123; a[++cnt]=a[i]; for(j=i;j&lt;=n&amp;&amp;a[j].x==a[i].x;j++); &#125; n=cnt; dcnt=0; for(int i=1;i&lt;=n;i++) d[++dcnt]=a[i].y; sort(d+1,d+1+dcnt); dcnt=unique(d+1,d+1+dcnt)-d-1; for(int i=0;i&lt;dcnt;i++) for(int j=d[i];j&lt;d[i+1];j++) diz[j]=i; for(int j=d[dcnt];j&lt;S;j++) diz[j]=dcnt; for(int i=1;i&lt;=n;i++) a[i].y=lower_bound(d+1,d+1+dcnt,a[i].y)-d; for(int l=1;l&lt;=n;l++)&#123; for(int r=l;r&lt;=n;r++)&#123; for(int h=1;h&lt;=dcnt;h++) g[l][r][h]=g[l][r-1][h]; g[l][r][a[r].y]=true; for(int h=1;h&lt;=dcnt;h++) g[l][r][h]|=g[l][r][h-1]; &#125; &#125;&#125;int f[N][N][N];int dp(int l,int r,int h)&#123; if(h&gt;dcnt) return 0; if(f[l][r][h]!=-1) return f[l][r][h]; int res=INF; if(l==r) res=(h&lt;=a[l].y); else&#123; int maxh=s/(a[r].x-a[l].x); if(diz[maxh]&gt;=h)&#123; maxh=diz[maxh]; res=g[l][r][maxh]+dp(l,r,maxh+1); &#125; for(int mid=l;mid&lt;r;mid++) applyMin(res,dp(l,mid,h)+dp(mid+1,r,h)); &#125; return f[l][r][h]=res;&#125;int main()&#123; int cases; scanf("%d",&amp;cases); for(int i=1;i&lt;=cases;i++)&#123; readData(); init(); memset(f,-1,sizeof f); printf("%d\n",dp(1,n,1)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>2018冬令营模拟测试赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>记忆化搜索</tag>
        <tag>好题</tag>
        <tag>方案特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[杨柳]]></title>
    <url>%2F2018%2F11%2F25%2Fxsy2692%E6%9D%A8%E6%9F%B3%2F</url>
    <content type="text"><![CDATA[Description 略 Solution 对于“同一时刻同一位置不可以有多于一个棋子”的条件，我们假象这样一个情况：棋子$A$去向目标时需要经过或停在位置$X$，而就在$A$走到$X$时，有另一个棋子$B$也要走到$X$以去向它的目的地。如果$A$是经过$X$，我们可以先让$A$走下一步，则$B$就可以继续前进；如果$A$停在$X$，我们完全可以让$A$走完$B$剩下要走的路去到$B$的目的地，而让$B$停留在$A$的目的地$X$ 这样一番思考，我们发现：这个限制条件是没有任何意义的。无解情况会发生，当且仅当某一些棋子迫于障碍和边界无法到达某一个目的地 因此，我们只需要给每一个棋子安排走法，使得最后所有棋子都在某一个目的地上，且总步数最小 考虑费用流： 从源点$S$向每一个出发点连一条流量为1、费用为0的单向边 从每一个目的地向汇点$T$连一条流量为1、费用为0的单向边 对于任意两个可以互达的格子，连一条流量为$\infty$、费用为1的双向边 直接跑费用流即可。若未满流，则说明无解；若满流，最小费用即为最小步数 Summary 对于调度问题而言，如果操作对象与目的地没有严格的对应关系，可以考虑使用交换后续方案的思想简化条件（类似的题还有自己组的题的T2） 整体进行的、感觉没办法逐步考虑的问题，考虑使用网络流解决 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int INF=1e9;const int RC=110;const int N=10010;int r,c,n,a,b;int st[N][2],ed[N][2];bool bad[RC][RC];namespace F&#123; int h[N],tot; struct Edge&#123; int v,f,c,next; &#125;e[N*300]; int flowS,flowT; void addEdge(int u,int v,int f,int c)&#123; e[++tot]=(Edge)&#123;v,f,c,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,-c,h[v]&#125;; h[v]=tot; &#125; queue&lt;int&gt; q; int dis[N]; bool inQueue[N]; int cur[N]; bool spfa()&#123; for(int i=1;i&lt;=flowT;i++)&#123; inQueue[i]=false; dis[i]=INF; cur[i]=h[i]; &#125; while(!q.empty()) q.pop(); q.push(flowS); dis[flowS]=0; inQueue[flowS]=true; while(!q.empty())&#123; int u=q.front(); q.pop(); inQueue[u]=false; for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]&gt;dis[u]+e[i].c)&#123; dis[v]=dis[u]+e[i].c; if(!inQueue[v])&#123; q.push(v); inQueue[v]=true; &#125; &#125; &#125; return dis[flowT]!=INF; &#125; int costSum; bool inStack[N]; int dfs(int u,int flow)&#123; if(u==flowT)&#123; costSum+=flow*dis[u]; return flow; &#125; inStack[u]=true; int res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+e[i].c&amp;&amp;!inStack[v])&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; inStack[u]=false; if(!res) dis[u]=-1; return res; &#125; void MCF()&#123; int res=0; while(spfa()) res+=dfs(flowS,INF); if(res&lt;n) puts("-1"); else printf("%d\n",costSum); &#125; void init(int s,int t)&#123; flowS=s; flowT=t; tot=1; &#125;&#125;void readData()&#123; scanf("%d%d%d%d%d",&amp;r,&amp;c,&amp;n,&amp;a,&amp;b); static char str[RC]; for(int i=1;i&lt;=r;i++)&#123; scanf("%s",str+1); for(int j=1;j&lt;=c;j++) if(str[j]=='*') bad[i][j]=true; &#125; for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;st[i][0],&amp;st[i][1]); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;ed[i][0],&amp;ed[i][1]);&#125;inline int ID(int x,int y)&#123; return (x-1)*c+y;&#125;inline void link(int id,int x,int y)&#123; if(x&lt;1||x&gt;r||y&lt;1||y&gt;c) return; if(bad[x][y]) return; F::addEdge(id,ID(x,y),INF,1);&#125;void builGraph()&#123; F::init(r*c+1,r*c+2); for(int i=1;i&lt;=n;i++)&#123; F::addEdge(F::flowS,ID(st[i][0],st[i][1]),1,0); F::addEdge(ID(ed[i][0],ed[i][1]),F::flowT,1,0); &#125; for(int x=1;x&lt;=r;x++) for(int y=1;y&lt;=c;y++) if(!bad[x][y])&#123; int cur=ID(x,y); link(cur,x-a,y-b); link(cur,x-a,y+b); link(cur,x+a,y-b); link(cur,x+a,y+b); link(cur,x-b,y-a); link(cur,x-b,y+a); link(cur,x+b,y-a); link(cur,x+b,y+a); &#125;&#125;int main()&#123; readData(); builGraph(); F::MCF(); return 0;&#125;]]></content>
      <categories>
        <category>2018冬令营模拟测试赛</category>
      </categories>
      <tags>
        <tag>可做未做</tag>
        <tag>网络流---费用流</tag>
        <tag>简化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[物品购买]]></title>
    <url>%2F2018%2F11%2F24%2Fxsy2682%E7%89%A9%E5%93%81%E8%B4%AD%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[Description 给一棵$n$个节点的有根树，每一个节点上都有无限多个物品，一个节点$i$的物品价值都为$w_i$，价格都为$c_i$ 有$q$个询问，每次给出一个参数$C,x$，求从$x$出发的到根路径的所有物品组成的完全背包问题在钱数为$C$时的最大收益 $n,q \le 5000$，$c_i,w_i \le 32767$ Solution 首先，完全背包是一个NP问题，这意味着你必须接受复杂度下界是$O(32767n)$的这个事实 考虑深搜时维护深搜栈组成的完全背包。记一个32767的数组$f_i$表示花费$i$的代价时的最大收益。递归进一个新点时，$O(32767)$更新数组即可。 关键问题在于回溯：我不可能对于每一个节点都复制一遍数组，在儿子递归完成后复位，这样空间复杂度过高 考虑树剖：在某一个节点$u$时，先递归轻儿子$v$，令轻儿子使用一个新数组，并把当前数组复制给$v$。最后，递归重儿子$son$时，让重儿子继续使用当前$u$的数组即可。根据树剖特性，任意一条到根路径经过的轻边数量不超过$\log n$，因此任意时刻使用的总数组数量也是$O(\log n)$的，空间复杂度降为$O(32767\log n)$ 具体实现上，全局开$\log n$个数组，深搜时额外传一个参数$p$，表示当前在用哪一个数组即可 原来的$fi$定义为”恰好花费$i$时的最大收益”，这意味着我们在回答询问时还要处理一遍前缀$\max$，且初始化时，$f_0=0,\ f{i}=\infty(i &gt;0)$。为了优化常数，我们定义$f_i$为”花费不超过$i$时的最大收益”，转移与原来完全一样，不过$f$的初始化变成$f_i=\infty$即可，可以发现，这样能把花费比需要少$x$的情况以首次转移时从$f_x=0$转移体现 时间复杂度$O(32767n)$，空间复杂度$O(32767\log n)$ Summary 深搜维护栈内DP时，如果加入容易，而回溯复位遇到问题（无法对每一个点都记录递归前的值），不妨使用树剖，使重儿子继承当前数组，而令轻儿子使用新的数组，利用树剖的特性，使得任意时刻需要记录历史的节点个数不超过$\log$个 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define PB push_backusing namespace std;typedef vector&lt;int&gt; VI;const int N=5010;const int W=32768;int n,m;struct Good&#123; int cost,val;&#125;a[N];VI que[N];int money[N];int ans[N];inline void applyMax(int &amp;x,int y)&#123; if(y&gt;x) x=y;&#125;namespace T&#123; int h[N],tot; struct Edge&#123; int v,next; &#125;e[N]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; &#125; int size[N],son[N]; void dfs1(int u,int fa)&#123; size[u]=1; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; dfs1(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125; &#125; int f[15][W]; void add(int p,int u)&#123; int c=a[u].cost,v=a[u].val; for(register int i=0;i+c&lt;W;i++) applyMax(f[p][i+c],f[p][i]+v); &#125; void dfs2(int u,int fa,int p)&#123; add(p,u); if(que[u].size())&#123; for(int i=0,sz=que[u].size();i&lt;sz;i++) ans[que[u][i]]=f[p][money[que[u][i]]]; &#125; if(!son[u]) return; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;v!=son[u])&#123; memcpy(f[p+1],f[p],W*sizeof(int)); dfs2(v,u,p+1); &#125; dfs2(son[u],u,p); &#125;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].cost,&amp;a[i].val); int x; for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;x); T::addEdge(x,i); &#125; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;money[i]); for(int i=1;i&lt;=m;i++)&#123; scanf("%d",&amp;x); que[x].PB(i); &#125;&#125;void printAnswer()&#123; for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]);&#125;int main()&#123; readData(); T::dfs1(1,0); T::dfs2(1,0,0); printAnswer(); return 0;&#125;]]></content>
      <categories>
        <category>2018冬令营模拟测试赛</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
        <tag>DP---背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String]]></title>
    <url>%2F2018%2F11%2F24%2Fxsy2675String%2F</url>
    <content type="text"><![CDATA[Description 给一个字符串集合$S$ 求有多少个字符串，满足其可以被断成两个非空串，且每一个非空串都是$S$中某一个字符串的前缀 $\sum_{str\in S}\mid str\mid \le 10^6$ Solution 这题的特殊之处在于：每一个有多种方式断开的字符串都只能被计算一次 利用最小表示法思想，对于每一个字符串，我们在断开位置最靠右的地方统计它 先算出总方案：我们对$S$中的所有字符串建立一棵Trie树，此时每一个节点都代表着某一个字符串的前缀，这种统计方式以前缀本身为视角，而不是以“到底是哪一个字符串的前缀”为视角，符合题意。记Trie树除根节点外的节点个数为$x$，则总方案数为$x^2$ 下面减去不符题意的情况：我们枚举后半部分字符串$s$，统计前半部分字符串有多少种取值，满足两者接上后，存在比当前分界点更靠右的分界点。换言之，前半部分字符串有多少种取值，满足在它后面接上$s$的某一个前缀$p$得到的字符串、以及$s$除去前缀$p$后得到的字符串，都是某一个$S$中字符串的前缀，也就是都在Trie上有相应存在 考虑枚举合法的前缀$p$（“合法”即删去$p$前缀后，$s$的剩余部分仍然在Trie中出现），如何统计有多少字符串在后面接上$p$后仍然在Trie中有相应存在？统计有多少字符串的后缀为$p$即可，因为希望统计的字符串与添加$p$后的能统计到的字符串一一对应。我们把Trie升级成AC自动机，在fail树上查询$p$对应节点的子树大小，减一即为相应答案（$p$自身显然无意义） 我们发现这样枚举并统计会出现重复。记最短的合法前缀为$p’$，事实上，任意一个应该被减去的不符题意的前缀，在枚举到$p’$时必然会被统计到（长的都可以满足，如果存在短的那么显然也是可以的）。因此，我们只需要在AC自动机上找到$s$对应的最短合法前缀，在此处统计即可 时间复杂度$O(26n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int S=1000010;const int C=26;int n;LL ans;namespace AC&#123; int rt,sz; int ch[S][C]; int fail[S]; int dep[S]; void init()&#123; rt=sz=1; fail[1]=0; &#125; void insert(int n,char *str)&#123; int u=rt; for(int i=0;i&lt;n;i++)&#123; int c=(str[i]-'a'); if(!ch[u][c])&#123; ch[u][c]=++sz; dep[ch[u][c]]=dep[u]+1; &#125; u=ch[u][c]; &#125; &#125; void buildFail()&#123; static queue&lt;int&gt; q; q.push(rt); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int c=0,v;c&lt;C;c++) if((v=ch[u][c]))&#123; q.push(v); if(u==rt) fail[v]=rt; else&#123; int f; for(f=fail[u];f!=rt&amp;&amp;!ch[f][c];f=fail[f]); if(ch[f][c]) fail[v]=ch[f][c]; else fail[v]=rt; &#125; &#125; &#125; &#125; namespace FT&#123; int h[S],tot; struct Edge&#123; int v,next; &#125;e[S]; int sum[S]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; &#125; void dfs(int u)&#123; sum[u]=1; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; dfs(v); sum[u]+=sum[v]; &#125; &#125; void build()&#123; for(int i=2;i&lt;=sz;i++) addEdge(fail[i],i); dfs(rt); &#125; &#125; void dfs(int u)&#123; static int sta[S],top; sta[++top]=u; if(u!=rt&amp;&amp;fail[u]!=rt) ans-=FT::sum[sta[(dep[u]-dep[fail[u]])+1]]-1; for(int c=0;c&lt;C;c++) if(ch[u][c]) dfs(ch[u][c]); sta[top--]=0; &#125;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;n); static char str[S]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",str); AC::insert(strlen(str),str); &#125;&#125;void solve()&#123; ans=1ll*(AC::sz-1)*(AC::sz-1); AC::dfs(AC::rt); printf("%lld\n",ans);&#125;int main()&#123; AC::init(); readData(); AC::buildFail(); AC::FT::build(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>2018冬令营模拟测试赛</category>
      </categories>
      <tags>
        <tag>最小表示法</tag>
        <tag>可做未做</tag>
        <tag>容斥原理</tag>
        <tag>字符串---AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOI2015】荷马史诗]]></title>
    <url>%2F2018%2F11%2F20%2F%E3%80%90NOI2015%E3%80%91%E8%8D%B7%E9%A9%AC%E5%8F%B2%E8%AF%97%2F</url>
    <content type="text"><![CDATA[Description 给定$n$个单词的长度及其出现次数，求构造$k$叉哈夫曼树后的最小代价 $n \le 10^5,\ 2 \le k \le 9$ Solution $k=2$即经典Huffman编码问题 当$k&gt;2$时，我们发现原算法并不总是最优的：按权值优先、深度其次的方法合并子树时，如果当前新建节点接上的子树数量不足$k$个，我们完全可以将底下的某一些子树移接到闲置的儿子处，以减小代价 经过一些观察，我们发现：如果原来的$n$个点构成了完全$k$叉树的所有叶子（即当$n-1 \mod k-1=0$，每次合并减少$k-1$个子树，最后剩下1个子树），合并时完全不会出现这种情况。因为每次合并时，新建的节点总会连接上恰好$k$个子树，再根据算法的贪心，应该被移上来的子树会被相应地处理 因此，我们可以添加若干个出现次数为0的单词，直到满足上述条件为止。此时原生哈夫曼树算法即可适应$k$阶的拓展情况 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;int n,m;struct Data&#123; LL val; int dep; friend bool operator &lt; (const Data &amp;a,const Data &amp;b)&#123; if(a.val!=b.val) return a.val&gt;b.val; return a.dep&gt;b.dep; &#125;&#125;;priority_queue&lt;Data&gt; q;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); Data t; for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;t.val); t.dep=1; q.push(t); &#125; while((n-1)%(m-1)!=0)&#123; n++; q.push((Data)&#123;0,1&#125;); &#125;&#125;void solve()&#123; LL ans=0; Data u,v; while(q.size()&gt;1)&#123; u.val=0; u.dep=0; for(int i=0;i&lt;m&amp;&amp;!q.empty();i++)&#123; v=q.top(); q.pop(); u.val+=v.val; u.dep=max(u.dep,v.dep+1); &#125; q.push(u); ans+=u.val; &#125; printf("%lld\n%d",ans,u.dep-1);&#125;int main()&#123; readData(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>适应</tag>
        <tag>哈夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[归并排序]]></title>
    <url>%2F2018%2F11%2F20%2Fxsy2669%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[Description 给一个长度为$n$的排列$a$，其中$n$为2的整数次幂 现将其进行归并排序。特别地，当分治区间长度为2时，有$\frac 12$的概率排序错误，即对于$x&lt;y$有可能会排序成$y,x$ 请支持$q$次操作： 交换$a$中的某两个数 给出两个数$i,j$，将$a$归并排序得到$a’$后，询问$a’_i=a_j$的概率 $n \le 2^{16},\ q \le 10^5$ Solution 对于某一个长度为2的分治区间，设两个数分别为$x,y(x&lt;y)$，可以发现： 如果排序后结果为$x,y$，则它们在之后的归并排序中没有特别的问题 如果排序后结果为$y,x$，根据归并排序的特性，我们可以发现：在之后的归并过程中，$x$总是会紧紧贴在$y$后面 我们可以对所谓的排序错误做一个等价转化：对于底层的一组数$a_i,a_j(a_i&lt;a_j)$，$a_j$的值稳定不变，而$a_i$的值有$\frac 12$的概率变为$a_j+0.5$。为了简化问题，我们可以把稳定的数也看做不稳定的数，使其两个值都等于原值。 考虑询问：求排序后第$i$个数为$a_j$的情况数，即小于$a_j$的数恰好有$i-1$个的情况数，除以$2^{\frac n2}$即可。 先两个值皆小于$a_j$的数的个数$s_1$，这$s_1$个数稳定地占去了$s_1$个位置，若$s_1&gt;i-1$则无解，否则此时还剩下$i-1-s_1$个位置需要填入 记一个数的两个值为一个数对$(x,y),\ (x&lt;y)$，我们统计满足$x&lt;a_j&lt;y$的数对个数$s_2$。我们可以从$s_2$个数中挑选$i-1-s_1$个数，让它们取较小的值，填入剩余位置，且令剩余的数取较大的值，放在$a_j$之后。这一个过程贡献的情况数为 {s2 \choose i-1-s_1}{2^{sum}} 其中，$sum$为当下除了$a_j$所属的数对（可能是）以及$s_2$个数对以外，有多少数对满足$x!=y$。这些数对的取值对我们的限制没有任何影响。$sum$可以通过$\frac n2-s_2$再通过微调（考虑$a_j$所属数对是不是）得到 如何求$s_1$和$s_2$？我们记录以$x’$为$x$的数对有多少个，再记录以$y’$为$y$的数对有多少个，使用两个树状数组维护这两个信息及其前缀和，分别记为$A$与$B$。$s_1$显然等于$B$中$a_j-1$的前缀和，而$s_2$可以通过容斥得到：$A$中$a_j-1$的前缀和减去$s_2$即可 交换操作没有什么难度，先删去涉及数对，再加入新数对即可 时间复杂度$O(q \log n)$ Summary 通过适应的思想，赋予某些元素新的定义，使得其既能用原算法或模型计算，又能体现题目的要求 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MOD=1e9+7;const int N=66000;int n;int a[N];int fact[N],iact[N],mi2[N];int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void initFact(int n)&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD; mi2[0]=1; for(int i=1;i&lt;=n;i++) mi2[i]=(mi2[i-1]&lt;&lt;1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;struct BIT&#123; int n; int a[N*2]; void setRange(int range)&#123; n=range; &#125; void add(int u,int x)&#123; for(;u&amp;&amp;u&lt;=n;u+=u&amp;-u) a[u]+=x; &#125; int que(int u)&#123; int res=0; for(;u;u-=u&amp;-u) res+=a[u]; return res; &#125;&#125;bitx,bity;void readData()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++)&#123; scanf("%d",&amp;a[i]); a[i]&lt;&lt;=1; &#125;&#125;void addPair(int x,int y,int sgn)&#123; bitx.add(x,sgn); bity.add(y,sgn);&#125;void consider(int u,int v,int sgn)&#123; if(u&gt;v) swap(u,v); addPair(u,v+1,sgn); addPair(v,v,sgn);&#125;void buildBIT()&#123; bitx.setRange(n*2+1); bity.setRange(n*2+1); for(int i=0;i&lt;n;i+=2) consider(a[i],a[i+1],1);&#125;void exchange(int x,int y)&#123; if(x==y) return; consider(a[x],a[x^1],-1); if((x&gt;&gt;1)!=(y&gt;&gt;1)) consider(a[y],a[y^1],-1); swap(a[x],a[y]); consider(a[x],a[x^1],1); if((x&gt;&gt;1)!=(y&gt;&gt;1)) consider(a[y],a[y^1],1);&#125;int calc(int val,int other,int num)&#123; int sumx=bitx.que(val-1)-(other&lt;=val-1); int sumy=bity.que(val-1); sumx-=sumy; if(sumy&gt;num) return 0; return 1ll*C(sumx,num-sumy)*mi2[(n&gt;&gt;1)-(sumx+(val!=other))]%MOD;&#125;int query(int x,int y)&#123; // how many situation satisfy a'[y]=a[x] int res=0; if(a[x]&gt;a[x^1]) // single value res=calc(a[x],a[x],y); else res=(calc(a[x],a[x^1]+1,y)+calc(a[x^1]+1,a[x],y))%MOD; res=1ll*res*fastPow(mi2[n&gt;&gt;1],MOD-2)%MOD; return res&gt;=0?res:res+MOD;&#125;void answerQuery()&#123; int q; int opt,x,y; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d%d",&amp;opt,&amp;x,&amp;y); x--; y--; if(opt==1) exchange(x,y); else printf("%d\n",query(x,y)); &#125;&#125;int main()&#123; initFact(65536); readData(); buildBIT(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>2018冬令营模拟测试赛</category>
      </categories>
      <tags>
        <tag>适应</tag>
        <tag>数据结构---树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF722E】Research Rover]]></title>
    <url>%2F2018%2F11%2F18%2Frover%2F</url>
    <content type="text"><![CDATA[Description 给一个$n\times m$的网格图，你要从$(1,1)$走到$(n,m)$，只能往右走或者往下走 初始时，你有一个权值$s$。有$k$个互不相同的格点为障碍点，你可以走过一个障碍点，但是每走过一个障碍点，你的权值就会变成$\lceil \frac s 2 \rceil$ 问到达$(n,m)$时权值的期望 $n,m\le 10^5,\ 0\le k\le\min(nm,2000),\ 1\le s \le 10^6 $ Solution 显然，到达终点时只有$v= O(\log s)$种权值，每一个最终权值唯一对应了经过的障碍数，我们只需要统计经过0个障碍，经过1个障碍，…，经过$v-1$个障碍和经过不少于$v$个障碍的路径分别有多少条即可 统计经过0个障碍是一个经典问题，可以用容斥解决。记$way(a,b,c,d)={c-a+d-b\choose c-a}$为从$(a,b)$走到$(c,d)$的方案数，$f_{i}$表示从$(1,1)$走到第$i$个障碍，途中不经过其他障碍的方案数，则有转移： f_i=way(1,1,x_i,y_i)-\sum_{j在i左上方}f_j*way(x_j,y_j,x_i,y_i) 现在我们想将状态推广：设$f_{i,j}$表示从$(1,1)$走到第$j$个障碍，途中恰好经过了其他障碍共$i$个的方案数 先回看一下$i=0$时的求法：我们用总路径数，减去那些走到$j$之前已经至少经过了$1$个点的方案，后者用枚举左上方的某个障碍$k$作为每一条不合法路径的第一个点，再用组合数乘上$f_{0,k}$，求和即可得到所有不合法路径数量 考虑模仿它并推广一下：求$f_{i,j}$时，我们用总路径数，减去那些走到$j$之前已经至少经过了$i+1$个障碍的方案数，即 way(1,1,x_j,y_j)-\sum_{k在j左上方}f_{i,k}*way(x_k,y_k,x_j,y_j) 此时我们求出来的东西，意义是从$(1,1)$走到$(x_j,y_j)$，有多少路径在走到$j$之前，经过的其他障碍数不超过$i$。 想要得到经过障碍数恰好为$i$的方案数，我们直接使用差分即可，则： f_{i,j}=way(1,1,x_j,y_j)-\sum_{k在j左上方}f_{i,k}*way(x_k,y_k,x_j,y_j)-f_{i-1,j} 总时间复杂度为$O(k^2\log s)$ 实现上，如果没有$(n,m)$的障碍，我们应该在$(n,m)$处新增一个障碍，以方便答案统计 Summary 希望从经典问题推广时，可以循着经典问题的计算思路，去摸索更高一级的计算思路，而不必自己误打误撞。譬如此题，考虑$i=0$时的计算思路是总方案数减去大于某一个值的方案数，所以我们不必在直接计算小于等于某一个值的方案数这个思路上纠结太久 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MOD=1e9+7;const int N=100010;const int K=2010;const int B=30;int n,m,o;int up,val[B];struct Point&#123; int x,y;&#125;p[K];bool haveT;int fact[N*2],iact[N*2];int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void initFact(int n)&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void readData()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;o,&amp;val[0]); haveT=false; for(int i=1;i&lt;=o;i++)&#123; scanf("%d%d",&amp;p[i].x,&amp;p[i].y); if(p[i].x==n&amp;&amp;p[i].y==m) haveT=true; &#125;&#125;bool cmpXY(const Point &amp;a,const Point &amp;b)&#123; if(a.x!=b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;void init()&#123; up=1; while(val[up-1]&gt;1)&#123; val[up]=(val[up-1]+1)&gt;&gt;1; up++; &#125; if(!haveT) p[++o]=(Point)&#123;n,m&#125;; sort(p+1,p+1+o,cmpXY);&#125;inline int way(int x1,int y1,int x2,int y2)&#123; // (x1,y1) --&gt; (x2,y2) return C((x2-x1)+(y2-y1),x2-x1);&#125;int f[B][K],sum[B][K];void dp()&#123; for(int i=0;i&lt;up;i++)&#123; for(int j=1;j&lt;=o;j++)&#123; f[i][j]=way(1,1,p[j].x,p[j].y); for(int k=1;k&lt;j;k++) if(p[k].y&lt;=p[j].y) (f[i][j]-=1ll*f[i][k]*way(p[k].x,p[k].y,p[j].x,p[j].y)%MOD)%=MOD; (f[i][j]-=(i&gt;0)?sum[i-1][j]:0)%=MOD; sum[i][j]=(((i&gt;0)?sum[i-1][j]:0)+f[i][j])%MOD; &#125; &#125;&#125;void solve()&#123; int ans=0; for(int i=0;i&lt;up-1;i++) (ans+=1ll*val[i]*((i-haveT&gt;=0)?f[i-haveT][o]:0)%MOD)%=MOD; (ans+=(way(1,1,n,m)-((up-2-haveT&gt;=0)?sum[up-2-haveT][o]:0))%MOD)%=MOD; ans=1ll*ans*fastPow(way(1,1,n,m),MOD-2)%MOD; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; initFact(200000); readData(); init(); dp(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>差分</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排列问题]]></title>
    <url>%2F2018%2F11%2F16%2Fxsy2666%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Description 现有$m$个球，每一个球都涂着$n$种颜色中的某一种，第$i$种颜色有$ai$个球。显然，$\sum{a{i}}=m$。对于颜色相同的球，我们认为它们没有差别 现在给出$q$个询问。每一个询问给出一个参数$x$，你需要求出总共有多少种将$m$个球排成一行的方案，使得相邻两个球颜色相同的对数恰好为$x$ $n \le 10^4,\ m \le 2*10^5,\; q \le 10^4,\ 0 \le x &lt; m$ Solution 如果从相邻两个球颜色相同或不相同的对数入手，其实是不好做的，因为每一对球之间可能会相互影响，譬如考虑三个球时，对于这两对球，我们很难在统计时判断它们各自的颜色，钦定的方法也可能产生矛盾 既然不能从断点做，那么我们考虑从一段的角度入手。我们可以将这些球分成若干个非空段，每一段内的颜色相同，而相邻两段的颜色不同。如果能计算出$ans$数组，其中$ans_i$表示有多少种方案能将所有球按上述方式划分成恰好$i$段，我们即可$O(1)$回答所有询问 注意到我们很难在统计时满足最后一个限制（相邻两段颜色不同）。如果能计算出忽略此性质后计算出来的数组$g$，我们就可以使用容斥原理计算每一个$ans_j$对$ans_i$在$g_i$基础上的负贡献： ans_i=g_i-\sum_{j=1}^{i-1}{m-j \choose i-j}ans_j 其中${m-j \choose i-j}$表示：一个恰好有$j$段的合法方案（即相邻段颜色不同），它于忽略掉这个限制意义下分成$i$段的方案总数之中被计算的次数，即在当前分段位置的基础上，还可以再在相邻两球相同的各个位置再挑$i-j$个位置切分，并在$g_i$中被统计 再通过传递展开（待填，否则直接根据上述思路使用分治FFT，复杂度$O(m \log^2 m)$，略卡常），可得 ans_i=\sum_{j=1}^i(-1)^{i-j}{m-j \choose i-j} 拆项后，一遍FFT计算即可，复杂度$O(m \log m)$ 如何计算$g$呢？ 每一种合法的划分方案可以唯一对应一个数组$s_{1…n}$，其中$s_i$表示第$i$种颜色在方案中被划分了多少段，则每一个数组$s$对应着$\frac{(\sum s_i)!}{\prod (s_i!)}$种方案，即把所有段全排列并忽略相同颜色的段的相对顺序后的结果 我们使用DP同步计算这个分式，如何体现状态和值的关系？设$f{i,j}$表示考虑完前$i$种颜色后，已经分的段数为$j$时（即分子$\sum{k=1}^is_k=j$），分母（$\frac 1{\text{xxx}}$）的乘积之和，即用状态体现分子，用值体现分母 转移第$i$种颜色时，枚举此颜色分成$k$段，则有 f_{i,j}=\sum_{k=1}^{a_i}f_{i-1,j-k}{a_i-1\choose k-1}\frac{1}{k!} 其中，$a_i-1\choose k-1$表示将$a_i$个互不相同的球分成$k$个非空段的方案数。使用隔板法先加入$k-1$个板，再通过预先从每一段中选出1个球以保证每一段非负，故从$a_i+(k-1)-k$中选$k-1$ 我们可以从中发现生成函数的形式：偏移后乘上一个系数并贡献。记母函数$Fi(x)[x^j]=f{i,j}$，则每次转移$i$相当于乘上一个转移函数$T_i(x)$： F_i(x)=F_{i-1}(x)*T_i(x)\\ T_i(x)=\sum_{k=1}^{a_i}{a_i-1\choose k-1}\frac 1{k!}x^k 注意到$\sum ai=m$，因此使用分治FFT求出$\prod{i=1}^n Ti(x)$即可得到$F_n(x)$，并得到$f{n,j}$。时间复杂度$O(m \log m \log n)$ 最后，我们把状态表示和DP值结合算出$g$即可：$gi=j!f{n,j}$ 总时间复杂度$O(m \log m \log n + q)​$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;namespace IO&#123; const int L=10000000; char inBuf[L]; int inPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int MOD=998244353,G=3;const int N=10010,M=200010;int n,m;int num[N],pre[N];int fact[M],iact[M];int *f,g[M];int ans[M];int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void initFact(int n)&#123; fact[0]=1; for(int i=1;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;namespace NTT&#123; const int S=530000; int n,invn,bit; int rev[S]; int W[20][S][2]; void build()&#123; int iG=fastPow(G,MOD-2); for(int i=0;i&lt;=19;i++)&#123; int x=fastPow(G,(MOD-1)/(1&lt;&lt;i)); int y=fastPow(iG,(MOD-1)/(1&lt;&lt;i)); W[i][0][0]=W[i][0][1]=1; for(int j=1;j&lt;(1&lt;&lt;i);j++)&#123; W[i][j][0]=1ll*W[i][j-1][0]*x%MOD; W[i][j][1]=1ll*W[i][j-1][1]*y%MOD; &#125; &#125; &#125; void init(int _n)&#123; for(n=1,bit=0;n&lt;_n;n&lt;&lt;=1,bit++); invn=fastPow(n,MOD-2); for(int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); &#125; void ntt(int *a,int f)&#123; for(int i=0;i&lt;n;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); int u,v,w; for(int i=2,il=1;i&lt;=n;i&lt;&lt;=1,il++)&#123; for(int j=0;j&lt;n;j+=i) for(int k=0;k&lt;(i&gt;&gt;1);k++)&#123; w=W[il][k][f]; u=a[j+k]; v=1ll*w*a[j+(i&gt;&gt;1)+k]%MOD; a[j+k]=(u+v)%MOD; a[j+(i&gt;&gt;1)+k]=(u-v)%MOD; &#125; &#125; if(f) for(int i=0;i&lt;n;i++) a[i]=1ll*a[i]*invn%MOD; &#125;&#125;void polyMul(int n,int *a,int m,int *b,int *c,bool dirUse=false)&#123; int newlen=n+m-1; NTT::init(newlen); if(!dirUse)&#123; static int ta[NTT::S],tb[NTT::S]; for(int i=0;i&lt;n;i++) ta[i]=a[i]; for(int i=n;i&lt;NTT::n;i++) ta[i]=0; for(int i=0;i&lt;m;i++) tb[i]=b[i]; for(int i=m;i&lt;NTT::n;i++) tb[i]=0; NTT::ntt(ta,0); NTT::ntt(tb,0); for(int i=0;i&lt;NTT::n;i++) ta[i]=1ll*ta[i]*tb[i]%MOD; NTT::ntt(ta,1); for(int i=0;i&lt;newlen;i++) c[i]=ta[i]; &#125; else&#123; for(int i=n;i&lt;NTT::n;i++) a[i]=0; for(int i=m;i&lt;NTT::n;i++) b[i]=0; NTT::ntt(a,0); NTT::ntt(b,0); for(int i=0;i&lt;NTT::n;i++) a[i]=1ll*a[i]*b[i]%MOD; NTT::ntt(a,1); for(int i=0;i&lt;newlen;i++) c[i]=a[i]; &#125;&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++)&#123; num[i]=getInt(); pre[i]=pre[i-1]+num[i]; &#125; m=pre[n];&#125;inline int getLen(int l,int r)&#123; return pre[r]-pre[l-1]+1;&#125;int mem[8000010];int *pmem=mem;void divide1(int l,int r,int *&amp;a)&#123; a=pmem; pmem+=getLen(l,r); if(l==r)&#123; a[0]=0; for(int k=1;k&lt;=num[l];k++) a[k]=1ll*C(num[l]-1,k-1)*iact[k]%MOD; return; &#125; int mid=(l+r)&gt;&gt;1; int *la,*ra; int len=getLen(l,r),lenl=getLen(l,mid),lenr=getLen(mid+1,r); divide1(l,mid,la); divide1(mid+1,r,ra); polyMul(lenl,la,lenr,ra,a);&#125;void calcAnswer()&#123; divide1(1,n,f); for(int i=1;i&lt;=m;i++) g[i]=1ll*fact[i]*f[i]%MOD; static int ta[NTT::S],tb[NTT::S]; ta[0]=0; for(int i=1;i&lt;=m;i++) ta[i]=1ll*g[i]*fact[m-i]%MOD; for(int i=0;i&lt;=m;i++) tb[i]=((i&amp;1)?-1ll:1ll)*iact[i]; polyMul(m+1,ta,m+1,tb,ta); for(int i=1;i&lt;=m;i++) ans[i]=1ll*iact[m-i]*ta[i]%MOD;&#125;void answerQuery()&#123; int q,k; q=getInt(); for(int i=1;i&lt;=q;i++)&#123; k=m-getInt(); printf("%d\n",ans[k]&gt;=0?ans[k]:ans[k]+MOD); &#125;&#125;int main()&#123; IO::load(); NTT::build(); initFact(200000); readData(); calcAnswer(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>2018冬令营模拟测试赛</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>数论---组合数学</tag>
        <tag>FFT</tag>
        <tag>DP---计数</tag>
        <tag>容斥原理</tag>
        <tag>生成函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树形图求和]]></title>
    <url>%2F2018%2F11%2F14%2F%E6%A0%91%E5%BD%A2%E5%9B%BE%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Description 给定一张$n$个点、$m$条边的有向图，每一条边有一个边权。我们保证这张图不存在自环，但可能有重边 请对于所有以$n$为根的内向树形图，求出它们的权值之和。一个内向树形图的权值定义为所有树边的边权之和 $n \le 300, m \le 100000$ Solution 要知道一般的矩阵树定理只能计算生成树个数，却处理不了权值相关的统计。因此，我们得把求和的过程和生成树个数建立一些联系。 我们可以考虑每一条边$(u,v,w)$的贡献：如果我们能计算出使用这条边的生成树有多少个，我们就能知道$w$在答案中贡献了多少次 强制选边很难，考虑换一种方式：我们用原本的树形图个数，减去不含有这条边的树形图个数即可计算贡献次数。计算不含某一条边的树形图个数，只需要把这条边从原图中删去，再用矩阵树定理计算一次即可 但是这样复杂度太高。考虑删去某一条边$(u,v)$时，基尔霍夫矩阵$K$仅仅是$K{u,v}$处加一，$K{u,u}$处减一，两个更改位置处于同一行。我们将$K$按第$u$行展开得$\det K=\sum{j=1}^nK{i,j}A{i,j}$，如果我们知道$A{u,v}$和$A_{u,u}$两个代数余子式的值，我们就可以$O(1)$地在原方案数的基础上将其迅速调整为删去$(u,v)$后的图的方案数。 换句话说，我们能不能预处理所有代数余子式$A_{i,j}$呢？这个是有经典方法的。在推导矩阵的逆时，曾经引入了伴随矩阵，即 \begin{aligned} K^{-1}&=\frac{K^*}{\mid K\mid}\\ K^*&=|K|K^{-1} \end{aligned} 而转置矩阵$K^*$就是一个$\det K$所有代数余子式的一个表，我们只需要用高斯约当消元计算$K$的逆以及$K$的行列式意义下的值$\mid K\mid$，即预处理所有$A_{i,j}$ 时间复杂度$O(n^3+m)$ BTW，最后计算时我们发现，其实调整的两个值之和就是包含那一条边的生成树个数 Summary 矩阵树定理一般只能处理“生成树个数”问题；但如果要统计权值之和，可以用矩阵树定理辅助计算某一个元素的贡献次数 善用微调思想 正难则反，考虑用总数减去另一部分的值来计算需要的东西，可能更符合模型的能力范围 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int MOD=1e9+7;const int N=310,M=100010;int n,m;int edge[M][3];int a[N][N],b[N][N];int detVal;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v,w; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); edge[i][0]=u; edge[i][1]=v; edge[i][2]=w; a[u][u]++; a[u][v]--; &#125;&#125;void GaussJordan(int n)&#123; for(int i=1;i&lt;=n;i++) b[i][i]=1; detVal=1; for(int i=1;i&lt;=n;i++)&#123; int r; for(r=i;r&lt;=n;r++) if(a[r][i]) break; if(i!=r) for(int k=1;k&lt;=n;k++)&#123; swap(a[i][k],a[r][k]); swap(b[i][k],b[r][k]); &#125; detVal=1ll*detVal*a[i][i]%MOD; int inv=fastPow(a[i][i],MOD-2); for(int k=1;k&lt;=n;k++)&#123; a[i][k]=1ll*a[i][k]*inv%MOD; b[i][k]=1ll*b[i][k]*inv%MOD; &#125; for(int j=1;j&lt;=n;j++) if(j!=i)&#123; int t=a[j][i]; for(int k=1;k&lt;=n;k++)&#123; (a[j][k]-=1ll*a[i][k]*t%MOD)%=MOD; (b[j][k]-=1ll*b[i][k]*t%MOD)%=MOD; &#125; &#125; &#125;&#125;void initCofT(int n)&#123; for(int i=1;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++) swap(b[i][j],b[j][i]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) b[i][j]=1ll*b[i][j]*detVal%MOD;&#125;void solve()&#123; int ans=0; int u,v,w; for(int i=1;i&lt;=m;i++)&#123; u=edge[i][0]; v=edge[i][1]; w=edge[i][2]; int noVal=detVal; (noVal+=b[u][v]%MOD)%=MOD; (noVal-=b[u][u]%MOD)%=MOD; (ans+=1ll*((detVal-noVal)%MOD)*w%MOD)%=MOD; &#125; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); GaussJordan(n-1); initCofT(n-1); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>计数问题</tag>
        <tag>矩阵树定理</tag>
        <tag>数论---线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【清华集训2016】你的生命已如风中残烛]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%20%E7%94%9F%E5%91%BD%2F</url>
    <content type="text"><![CDATA[Description 有$m+1$张牌，最后一张牌固定放在牌堆底部，其余$m$张牌按随机顺序压在上方，共有$m!$种情况 这$m$张牌中，有$n$张牌是特殊牌，每一张牌有一个数字$a_i$，表示你可以消耗掉这张牌并从牌堆顶部连续抽取$a_i$张牌；其余$m-n$张是杂牌，没有任何作用 开始时，你可以抽取牌堆顶部的第一张牌，然后开始你的操作 我们保证$\sum_{i=1}^n a_i=m$，显然此时如果牌的顺序得当，你可以顺利拿走所有$m+1$张牌 问总共有多少种情况使得你可以拿走所有牌 Solution 首先做一些模型的转化。由于这个问题与加油和耗油的过程类似，我们把这$m+1$张牌各记一个权值量化为行车问题：设特殊牌权值为$a_i-1$，杂牌权值为$-1$，则一个局面为合法，当且仅当前$m$个前缀和非负；至于第$m+1$个前缀和，其显然是定值，没有考虑的必要 鬼知道为什么会想到轮换去。考虑这$m+1$个元素的$S_1(m+1,1)=m!$个轮换，对于每一个轮换$L$，我们从任意一个位置先断开这样看，求一遍前缀和$A$；同时我们发现，如果将$L$在前缀和最小的位置中最靠后的那个位置$x$之后断开，以之后的那个位置$x+1$作为牌堆顶，以这个位置作为牌堆底，这样必定是合法的。首先，前缀和最小的位置$x$一定是$-1$；其次，由于$x$为最靠后的前缀和最小的位置，这意味着从$x+1$开始一直到当前这样看的尾部，前缀和都非负；再者，由于所有元素之和为$-1$，因此$x+1$开始到尾部的所有元素之和恰好等于$-1-A_x$，这意味着如果按刚才说的方式划分，从头开始到$x-1$的所有前缀和都将补上$-1-A_x$，全部可以达到非负状态。而$x$是最后一个元素，不需要考虑，前缀和走到这里一定等于$-1$ 所以$m!$个轮换的每一个都唯一对应了一种合法方案 但是其实这样有重复。我们断开时找的是$-1$来断开，而依据题意，最后一张牌应该固定成为最后一个元素，而此时最后一张牌在每一个$-1$的位置时我们却都假定断开的那个$-1$就是最后一个元素，算重了。我们除掉出现次数即牌堆内$-1$的个数$m-n+1$即可 所以答案为 \frac{m!}{n-m+1} Code123456789101112131415161718192021222324#include &lt;cstdio&gt;using namespace std;const int MOD=998244353;int n,m;void readData()&#123; scanf("%d",&amp;n); int x; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;x); m+=x; &#125;&#125;void solve()&#123; int ans=1; for(int i=1;i&lt;=m;i++) if(i!=m-n+1) ans=1ll*ans*i%MOD; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>清华集训</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>数论---组合数学</tag>
        <tag>结论题</tag>
        <tag>数论---第一类斯特林数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【清华集训2016】温暖会指引我们前行]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%B8%85%E5%8D%8E%E9%9B%86%E8%AE%AD2016%20%E6%B8%A9%E6%9A%96%2F</url>
    <content type="text"><![CDATA[Description 给一张无向图，已经有$n$个点，请顺序支持$m$次操作，每次操作都是以下三种中的某一种： 加入一条温度为$t$、长度为$l$的无向边 更改某一条已加入的无向边的长度$l$ 给出$x$和$y$，询问从$x$走到$y$的关于$t$字典序最大的路径的长度是多少（字典序定义有更改，如果$A$是$B$的前缀反而$A$更大） $n\le 10^5,\ m\le 3*10^5$ Solution 一看就感觉很玄乎，图上询问路径，还要找到字典序最大的路径 联系之前总结的经验，图上路径最值问题，想一想最小生成树：考虑任意两点在最大生成树上的路径是否一定是我们要定位的路径，经过简单感受和推理发现其的确是字典序最大的路径 于是我们直接用LCT维护最大生成树，支持查询两点距离即可 没想太多直接看题解去了，后来才发现这道题是T1，如果是场上的话可能可以逼迫自己做出来，毕竟写过相关总结；不过现在做散题时联想经验的意识会相对薄弱，需要纠正态度 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int INF=1e9;const int N=100010,M=300010;int n,m;int record[M][2];int temwho[M];namespace LCT&#123; const int S=N+M; int ch[S][2],fa[S]; int rev[S]; int tem[S],minTem[S]; LL val[S],sum[S]; inline bool isRoot(int u)&#123; return ch[fa[u]][0]!=u&amp;&amp;ch[fa[u]][1]!=u; &#125; inline int who(int u)&#123; return ch[fa[u]][1]==u; &#125; inline void pushup(int u)&#123; minTem[u]=(u&gt;n)?tem[u]:INF; sum[u]=val[u]; if(ch[u][0])&#123; minTem[u]=min(minTem[u],minTem[ch[u][0]]); sum[u]+=sum[ch[u][0]]; &#125; if(ch[u][1])&#123; minTem[u]=min(minTem[u],minTem[ch[u][1]]); sum[u]+=sum[ch[u][1]]; &#125; &#125; inline void reverse(int u)&#123; rev[u]^=1; swap(ch[u][0],ch[u][1]); &#125; inline void pushdown(int u)&#123; if(rev[u])&#123; if(ch[u][0]) reverse(ch[u][0]); if(ch[u][1]) reverse(ch[u][1]); rev[u]=0; &#125; &#125; void pd(int u)&#123; if(!isRoot(u)) pd(fa[u]); pushdown(u); &#125; inline void rotate(int u)&#123; int f=fa[u],g=fa[f],c=who(u); if(!isRoot(f)) ch[g][who(f)]=u; fa[u]=g; ch[f][c]=ch[u][c^1]; if(ch[f][c]) fa[ch[f][c]]=f; ch[u][c^1]=f; fa[f]=u; pushup(f); pushup(u); &#125; inline void splay(int u)&#123; pd(u); for(;!isRoot(u);rotate(u)) if(!isRoot(fa[u])) rotate(who(u)==who(fa[u])?fa[u]:u); &#125; inline void access(int u)&#123; for(int v=0;u;v=u,u=fa[u])&#123; splay(u); ch[u][1]=v; pushup(u); &#125; &#125; inline void makeRoot(int u)&#123; access(u); splay(u); reverse(u); &#125; bool isConnect(int a,int b)&#123; makeRoot(a); access(b); splay(b); return fa[a]!=0; &#125; void link(int a,int b)&#123; makeRoot(a); fa[a]=b; &#125; void cut(int a,int b)&#123; makeRoot(a); access(b); splay(b); ch[b][0]=fa[a]=0; pushup(b); &#125; void addNewEdge(int id,int u,int v,int t,int l)&#123; id+=(n+1); tem[id]=t; temwho[t]=id; val[id]=l; if(!isConnect(u,v))&#123; link(u,id); link(id,v); &#125; else&#123; makeRoot(u); access(v); splay(v); int x=temwho[minTem[v]]; if(t&gt;minTem[v])&#123; cut(record[x-(n+1)][0],x); cut(x,record[x-(n+1)][1]); link(u,id); link(id,v); &#125; &#125; &#125; LL query(int a,int b)&#123; if(a==b) return 0; if(!isConnect(a,b)) return -1; makeRoot(a); access(b); splay(b); return sum[b]; &#125; void modifyEdge(int id,int l)&#123; id+=(n+1); splay(id); val[id]=l; pushup(id); &#125;&#125;void answerQuery()&#123; scanf("%d%d",&amp;n,&amp;m); static char opt[10]; int id,u,v,t,l; for(int i=1;i&lt;=m;i++)&#123; scanf("%s",opt); if(opt[0]=='f')&#123; scanf("%d%d%d%d%d",&amp;id,&amp;u,&amp;v,&amp;t,&amp;l); u++; v++; record[id][0]=u; record[id][1]=v; LCT::addNewEdge(id,u,v,t,l); &#125; else if(opt[0]=='m')&#123; scanf("%d%d",&amp;u,&amp;v); u++; v++; printf("%lld\n",LCT::query(u,v)); &#125; else&#123; scanf("%d%d",&amp;id,&amp;l); LCT::modifyEdge(id,l); &#125; &#125;&#125;int main()&#123; answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>清华集训</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
        <tag>数据结构---动态树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2018】记录]]></title>
    <url>%2F2018%2F11%2F12%2Fnoip2018%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Day -1 在本校考场试了一下机，感觉Vim和命令行的响应速度都异常的快（比我自己的电脑还要快），键盘手感还行，不知道为什么有一点黏 dyh、dc、dcx和dtz，常年同考场的四个D，又在同一个室里 晚上回家快速过了很多远古时期在xsy上做的题，希望能找到一些灵感 Day 0 晚上才回到学校，反复地补充、阅读自己写的考试注意事项，希望不要犯低级错误 很早就回去睡觉了，留宿签到时生活老师很惊讶地问了一句：“信息的怎么回来这么早呀？” =_= Day 1 看题： T1看起来是很显然的模拟 T2貌似很神仙？ T3好像是二分答案，判定没有想清楚 先写T1。我想了20min都没有想到有什么较好的实现方法，没办法，只能硬着头皮写链表+线段树暴力模拟，T1直接打到了100多行；中途越打越虚：为什么T1我会打这么长…… 还好细节不多，一遍过大样例，又写了一个暴力拍，一直放着，也没出什么错 去看T2 。观察了一下样例一，猜想答案就是输入的子集。打开了第二个大样例发现范围不大，于是按结论手算了前三个样例，发现答案就是把输入中能用其他数表示的数删去后剩余的元素个数。一个显然的贪心就是先排序，然后从小到大考虑每一个元素，如果它不能被保留元素表示就加进保留元素，否则忽略。 一开始想到线性基什么鬼去了（装备购买），后来发现好像不是同一个模型。观察了一下，输入元素的权值范围不是很大，应该可以开一个bool数组$f$表示当前每一个值能否被表示。插入时暴力更新即可。 但我一开始想的更新是这样的：如果我要插入$x$，那么我应该将$f$偏移$x$位或上去、偏移$2x$位或上去，枚举每一种可能的偏移量或上去，用bitset加速转移。这个复杂度跑20组数据是显然过不了的，但是部分分很水，可以拿到80，再想了一下也没有别的思路，就先跳过了 考虑T3二分完以后干什么。之前lhx提到：如果题目要求构造一定数量的方案，你可以在二分后判定此时最多能构造多少方案，所以判定应该就是最多能修建多少条赛道。此时我受到了我搬的某场比赛的T2的启发，大概应该是每一个子树内部匹配完全，再留多一个尾巴给父亲，回溯到父亲时，父亲可以对每一个子树留上来的路径两两对接 这个贪心策略是要考虑清楚的。我搞出一个猜想：首先，长度已经超过二分值的路径自成一条赛道；其次，在其余路径尽可能多地匹配的情况下，留下的路径要尽可能长。考虑用置换法证明这个贪心：是否存在内部少匹配一点，以留出更长的路径给父亲，使得全局匹配数更多的情况呢？不可能。内部少匹配一点，全局匹配数至少减一，留给父亲匹配数也最多加一，还不如直接在树内进行匹配。对于那些长度已经超过二分值得路径也显然：尽早地自成赛道，留下更多的边给其他赛道使用。 接下来是怎么合并的问题了，这点YY了半天，想过双指针，但是做不了；想过枚举留哪一个人，做不了；最后不知道怎么想的，想了一个拍完序后从前往后扫，每遇到一个元素，就从之前的未匹配的元素中找到最小的能匹配的元素，如果找得到就匹配。具体我实现用了一个multiset 写完发现过不了大样例，心中一凉。好不容易YY了一个垃圾暴力，一拍发现居然n=2也出错，调了一下发现幸好不是贪心的问题，而是返回路径时即使内部匹配完全，还可以返回树根。改了一下，居然过了！非常激动，感觉280稳了 然后失误来了，我使用小数据对拍后，居然没有用一组极限数据测试一下，不知道是因为过度兴奋冲昏了头脑，还是因为感觉5w跑两个log应该不虚，事实上卡常的问题非常严重，因为我调用了太多stl 最后15min检查所有程序，看到T2时，我突然灵光一现：如果我只枚举$x,2x,4x,8x$，好像也是等价的啊！我就立马改了转移的那个循环，也没细细计算复杂度，感觉会快很多。随便和原来的程序拍了一拍过了，感觉T2应该能A（虽然我没有算复杂度） 考场出来愉快交流： Day1全是原题 T1是个三行题啊我写了140行。此题和NOIP2013提高组D2T1完全重题，各类段子手开始就之前的禁赛事件发表有关这题的段子 T2原来直接从小到大偏移$x$转移就可以了，我总是想着整体赋值上去，然而如果从小到大逐个转移，就可以覆盖所有的情况。然而事实上我的做法复杂度比主流算法快了将近4倍=_= 一直很兴奋自己做出了T3，周围人问我会不会卡常我也没太在意。此时我才想起来我居然没有跑T3的极限数据，非常紧张。下午在洛谷上自测，居然T了3个菊花树的点。本地不开O2，5w的菊花树足足跑了2.5秒，开了O2只要0.4 。仔细测了一下，有两个3w的点本地大约1.1s，洛谷太慢了没话说，可说不定CCF的新评测机能跑过去呢？ 真的没想到STL会卡常到这种地步，不过场上我也没想到更好的实现方法……这次吃了亏（没AK），不能放任不管，所以以后场上的每一道题还是跑一下大数据比较保险 下午愉快地浪，本来以为普及组考试我们机房也会断网，迅速下载了一堆的东西，结果并没有断网……那天晚上入了COD4，晕的厉害…… Day 2 考前预测出题人会用Day2亡羊补牢 T1看起来是个简单深搜？ T2好神啊，不会 T3又来一棵树 回来看T1，发现这道题并不是随便深搜就能搞定的。我杠了大概5min的一般图才去仔细观察数据范围：5000的树或者环套树 树很好打，迅速拿到60分 但这个环套树我就开始纠结了，想了很多非常复杂的线性做法，写得比D1T1还要长和恶心，越写越迷茫，最后写出来还过不了大样例，事实上还是错的。此时时间已经过去1.5h，心态开始炸裂，居然在T1上耗了这么久时间 无奈跳题，看了5min的T2，只想到了按斜线推进，但并没有摸清楚规则和方案，只看出了n=2时的一点小规律，欣喜地想要在n=3上试试，结果是错的。草草看了一眼部分分，觉得都不会（我在想啥），跳了 T3先打了$O(n^2)$的暴力树形DP，开始做后面的部分分：一条链的感觉很可做，我场上想了一个线段树询问区间DP信息然后合并的方法，写得有点长，细节也非常烦人。最后用树的程序对拍过了，感觉还是挺OK的，68分应该有了 返回来看A。感觉放一会不会做的题过一段时间再来看的确会产生一些灵感，我终于想到了要好好利用5000的数据范围这一点：环套树上的DFS只会忽略某一条环边，我直接断开每一条环边，都用树的方法跑一次，取字典序最小即可。很快就写完了$O(n^2)$的算法，受D1T3的经验，我跑了一下极限数据，效果非常不好，因为我每次都在DFS内部排序边……预处理后仍然不佳，因为我用vector存边表…….最后我还是对每一个点的出边排序后反着存进链表里，速度还挺快，拍了一下，没什么大问题。我在最后30min时总算做完了T1 检查完T1和T3的程序后，我只能寄希望于T2了。原来以为$n,m\le 3$都不会做的我发现直接打表就行了（雾。但是$n=2\ m=3$的我不会。再细看了一眼，有$n=2$的部分分。套用之前看出的一点小规律，我发现$n=2$时两条路径不会互相穿过对方，可以推出，每一个斜行从左下往右上看必须是$00$或$10$或$11$（若为$01$可以轻松构造出矛盾的两条路径），左上角和右下角随便动都可以，所以答案就是$4*3^{m-1}$。我非常高兴地发现这个档居然有40分，加上小部分分总共有50。万幸自己能在最后一刻挽回这么多水分 结束前3min我才发现T3的B1不是直接部分DP就好了么…….为什么不写呢……8分丢了 发现大家好像都没有阿克。今天的题果然难度直线上升，几位集训队爷好像都没有AK，某道题还疑似是原本要出到清华集训里面的…… 今天重做了一下T3，倍增的状态设计非常关键。虽然说这题放在T3，但平心而论并不难，总感觉如果自己没有因为T1而乱了阵脚的话，我应该可以做出T3。不过如今看来都是事后诸葛亮罢了 218海星吧，至少把该拿的都拿了 END 预估(100+100+95)+(100+50+68)=513，希望自己不要犯低级错误或者爆掉什么东西了 UPD：已经爆破，D2T2第二档部分分看成了$n=2$，那么$n=1$的数据只有$m=1,2,3$有分，最好情况没20吧，看他比重，服了自己了，也可能是最后几分钟太急了吧…… NOIP2018对于自己来说挺重要的，林导说了，联赛考好了，什么机会都有 记得去年联赛前，林导对高二学长们说了一些放松发挥之类的话，但难掩其孤注一掷的风险；如今，NOIP2018好像恍恍惚惚就过去了，却没有太多的忧虑之心。为了这一次联赛，我们经历了许许多多的训练，或许是这些经验给我们自己打了镇心的一剂，能让自己在比赛中主观发挥较好，而现在，就只能耐心等待成绩公布了 成绩(11.20) D2T3居然拿满了50？也就是说$n \le 2 $的数据完全没有$n=1$的点 神奇了 最终成绩比考场预估分低5分（D1T3），和民间数据评测基本一样 总之今年发挥得还算不错吧]]></content>
      <categories>
        <category>总结</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[栅栏]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%A0%85%E6%A0%8F%2F</url>
    <content type="text"><![CDATA[Description 略 Solution 要判定两个格子是否连通，形象地说，我们只需要判断两个格子相对于全局的拓扑关系是否一样，即两个格子所属的矩形构成的集合是否完全相同 我们可以为每一个矩形设定一个随机的权值。每加入一个矩形，我们就将这个矩形范围内的所有格点异或上这个矩形的权值，删除时再异或掉。此时，每一个格点的权值就是所属矩形的集合的体现，如果两个格点的权值相同，那么它们就是连通的 我们使用二维树状数组支持矩形异或、单点查询即可。矩形异或等价于四个单点打标记，而单点查询等价于询问$(1,1)…(x,y)$的标记异或和 Summary 如果判定性问题能转化有关“两者的性质集合是否完全相等”的询问，尝试使用随机化加上异或的方式，处理集合相等判定问题 赋值标记不可前缀和相减，也难以满足覆盖和撤销两种操作，但异或标记是一个完美的替代方案 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;unordered_map&gt;using namespace std;typedef unsigned long long ULL;namespace IO&#123; const int L=50000000; char inBuf[L]; int inPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; char c=getChar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const ULL B[4]=&#123;1,2005ull,4020025ull,8060150125ull&#125;;const int N=2010;const int Q=100010;int n,m,q;struct Rect&#123; int x1,y1,x2,y2;&#125;rect[Q];int idCnt;unordered_map&lt;ULL,int&gt; idmap;ULL val[Q];ULL getRectHash(int x1,int y1,int x2,int y2)&#123; return B[3]*x1+B[2]*y1+B[1]*x2+y2;&#125;ULL getRandValue()&#123; ULL res=0; for(int i=0;i&lt;64;i++) res+=(rand()%2)*(1ull&lt;&lt;i); return res;&#125;namespace BIT&#123; ULL a[N][N]; void add(int x,int y,ULL k)&#123; for(int i=x;i&lt;=n;i+=i&amp;-i) for(int j=y;j&lt;=m;j+=j&amp;-j) a[i][j]^=k; &#125; ULL que(int x,int y)&#123; ULL res=0; for(int i=x;i;i-=i&amp;-i) for(int j=y;j;j-=j&amp;-j) res^=a[i][j]; return res; &#125; void addXor(Rect &amp;r,ULL k)&#123; int x1=r.x1,y1=r.y1,x2=r.x2,y2=r.y2; add(x1,y1,k); add(x1,y2+1,k); add(x2+1,y1,k); add(x2+1,y2+1,k); &#125;&#125;bool query(int x1,int y1,int x2,int y2)&#123; return BIT::que(x1,y1)==BIT::que(x2,y2);&#125;int main()&#123; IO::load(); srand(time(0)); int opt,x1,y1,x2,y2; n=getInt(); m=getInt(); q=getInt(); for(int i=1;i&lt;=q;i++)&#123; opt=getInt(); x1=getInt(); y1=getInt(); x2=getInt(); y2=getInt(); if(opt==3) puts(query(x1,y1,x2,y2)?"Yes":"No"); else&#123; ULL h=getRectHash(x1,y1,x2,y2); int id=idmap[h]; if(!id)&#123; // add idCnt++; idmap[h]=idCnt; rect[idCnt]=(Rect)&#123;x1,y1,x2,y2&#125;; val[idCnt]=getRandValue(); BIT::addXor(rect[idCnt],val[idCnt]); &#125; else&#123; // del idmap[h]=0; BIT::addXor(rect[id],val[id]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>好题</tag>
        <tag>随机化</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抢夺]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%8A%A2%E5%A4%BA%2F</url>
    <content type="text"><![CDATA[Description 给定一个网络，源点为$1$，汇点为$n$，每一条边都有一个流量限制，流量流过每一条边的时间都为1 现在源点有$K$的流量要流向汇点，求所有流量全部流到汇点的最短用时 $n \le 1000,\ m \le 5000$ Solution 虽然这题使用的结论好像假了，但本题在如何具体化模型的方面还是很有启发性的，因为我从开场到改题之前都对这道题的模型没有半点想象能力，即使我知道这题是网络流 假设我们找到了一条增广路$path$，其费用（即长度）为$dis$、流量为$flow$。若这条增广路在最优解中，那么这条增广路肯定是从一开始时就每时每刻从源点$S$发出$flow$的流量，沿着$path$向汇点前进。 我们对原图跑最小费用最大流，每找到一条增广路$path$，我们就相应地将途径的边流过$flow$的流量，不断重复寻找增广路，直到其不存在为止。同时，我们记录下每一条增广路的$dis$和$path$。它们的意义是什么呢？仔细思考一下就可以发现，每一条增广路都是一条可供源点流量选择的旅行路径。若源点每一时刻都按照每一条增广路分别发送对应的流量，在经过足够长的时间后（每一条增广路的第一波流量都到达汇点后），运输效率将会达到顶峰 这其实模拟了原问题中最优秀的安排策略。我们不再思考流量会不会在中途停留的问题，也不再考虑每一时刻每一个位置究竟是不是囤积了流量；我们只需要找出若干条路径，使得如果这几条路径同时运作，它们之间将不会产生任何阻碍和冲突，且运输效率最大 考虑给定一个时刻$t$，如何判定此时$K$点流量都已经流到终点？我们尝试列出汇点接受流量总和关于$t$的表达式，并用不等号与目标连接： \sum_{p\in P}[t\ge dis_p]flow_p(t-dis_p+1)\ge K 最不好处理的就是条件部分，为此，我们可以分别对每一段条件相同的$t$进行计算。我们将增广路按照$dis$排序（其实最小费用最大流跑出来增广路长度就是递增的），当$t$取相邻两条增广路的长度之间时（$t \in [disi,dis{i+1})$），$i+1$及之后的增广路都对式子没有贡献（从原问题上理解，就是这些增广路的第一波流量还没到达汇点），因此考虑的$p$是一个前缀。我们发现式子左边是一个关于$t$的一次函数，我们直接解出$t$的最小值，并判定其是否在当前范围内即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cmath&gt;using namespace std;const int INF=1e9;const int N=1010,M=5010;int n,m,o;struct Road&#123; int dis,flow;&#125;r[N*N];int rcnt;namespace F&#123; int flowS,flowT; int h[N],tot; struct Edge&#123; int v,f,c,next; &#125;e[M*2]; void reset()&#123; tot=1; for(int i=1;i&lt;=flowT;i++) h[i]=0; &#125; void setST(int s,int t)&#123; flowS=s; flowT=t; &#125; void addEdge(int u,int v,int f,int c)&#123; e[++tot]=(Edge)&#123;v,f,c,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,-c,h[v]&#125;; h[v]=tot; &#125; queue&lt;int&gt; q; bool inq[N]; int dis[N]; int from[N][2]; // &#123;node,edge&#125; bool spfa()&#123; for(int i=1;i&lt;=flowT;i++)&#123; inq[i]=false; dis[i]=INF; &#125; while(!q.empty()) q.pop(); q.push(flowS); dis[flowS]=0; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f)&#123; v=e[i].v; if(dis[u]+e[i].c&lt;dis[v])&#123; from[v][0]=u; from[v][1]=i; dis[v]=dis[u]+e[i].c; // if(!inq[v])&#123; // inq[v]=true; q.push(v); // &#125; &#125; &#125; &#125; return dis[flowT]!=INF; &#125; void makeFlow()&#123; int flow=INF; for(int u=flowT;u!=flowS;u=from[u][0]) flow=min(flow,e[from[u][1]].f); r[++rcnt]=(Road)&#123;dis[flowT],flow&#125;; for(int u=flowT;u!=flowS;u=from[u][0])&#123; int id=from[u][1]; e[id].f-=flow; e[id^1].f+=flow; &#125; &#125; void EK()&#123; while(spfa()) makeFlow(); &#125;&#125;bool readData()&#123; if(scanf("%d%d%d",&amp;n,&amp;m,&amp;o)==-1) return false; F::setST(n+1,n+2); int u,v,c; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); u++; v++; F::addEdge(u,v,c,1); &#125; F::addEdge(F::flowS,1,o,0); F::addEdge(n,F::flowT,o,0); return true;&#125;void reset()&#123; rcnt=0; F::reset();&#125;void solve()&#123; int sum=0; for(int i=1;i&lt;=rcnt;i++) sum+=r[i].flow; if(!sum)&#123; puts("No solution"); return; &#125; r[rcnt+1].dis=INF; int k=0,b=0,low; for(int i=1;i&lt;=rcnt;i++)&#123; k+=r[i].flow; b+=(-r[i].dis+1)*r[i].flow; low=(int)ceil(1.0*(o-b)/k); if(r[i].dis&lt;=low&amp;&amp;low&lt;r[i+1].dis)&#123; printf("%d\n",low); return; &#125; &#125;&#125;int main()&#123; while(true)&#123; reset(); if(!readData()) break; if(!o)&#123; puts("0"); continue; &#125; F::EK(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4668】冷战]]></title>
    <url>%2F2018%2F11%2F02%2Fbzoj4668%E5%86%B7%E6%88%98%2F</url>
    <content type="text"><![CDATA[Description 有$n$个点，请在线支持下列两种操作，操作共有$q$个 添加一条无向边$(u,v)$ 询问$u$和$v$最早在加入第几条边时连通 $n,q\le 5*10^5$ Solution 一上场想都没想直接9min码了LCT，拿到范围为10w的80分，剩余数据过于卡常 然后我就什么也没想出来了……我一直在思考如何不使用LCT维护树上连通性，然而这做不了 之后想到了几天前刚学的Kruskal重构树，还是无果 可我就是没想到按秩合并的普通并查集啊！Kruskal虽然能把边权体现在点上，但其连边方向固定，不能用启发式保证深度；而使用按秩合并的并查集时，边权体现在边上，且可以使用启发式保证树的深度 按秩合并的并查集树高仅为$\log$，因此，对于单次询问，我们只需要在并查集构成的树上暴力跳边求最大值即可 Summary 对于连通性问题，考虑能否利用按秩合并的并查集树高为$\log$的这一性质，暴力扫描树上路径并回答询问 并查集构成的树结构虽然和原树不太一样，但是有关连通性的触发问题，答案还是能在并查集的树上路径中体现出来的 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;namespace IO&#123; const int L=50000000; char inBuf[L],outBuf[L]; int inPos,outPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; char c=getChar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeChar(char c)&#123; outBuf[outPos++]=c; &#125; void writeInt(int x,char endc='\n')&#123; static int sta[20],top; if(!x) writeChar('0'); else&#123; for(top=0;x;x/=10) sta[++top]=x%10; for(;top;top--) writeChar('0'+sta[top]); &#125; writeChar(endc); &#125; void flush()&#123; fwrite(outBuf,1,outPos,stdout); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=500010;int bel[N],h[N];int faEdge[N];int find(int u)&#123; return bel[u]==u?u:find(bel[u]);&#125;void merge(int u,int v,int id)&#123; int fu=find(u),fv=find(v); if(fu==fv) return; if(h[fu]&gt;h[fv]) swap(fu,fv); bel[fu]=fv; if(h[fu]==h[fv]) h[fv]++; faEdge[fu]=id;&#125;int query(int u,int v)&#123; static int a[N][2],b[N][2],acnt,bcnt; acnt=bcnt=0; for(;bel[u]!=u;u=bel[u])&#123; acnt++; a[acnt][0]=u; a[acnt][1]=faEdge[u]; &#125; for(;bel[v]!=v;v=bel[v])&#123; bcnt++; b[bcnt][0]=v; b[bcnt][1]=faEdge[v]; &#125; for(int i=0;;i++) if(a[acnt-i][0]!=b[bcnt-i][0])&#123; int res=0; for(int j=acnt-i;j&gt;=1;j--) res=max(res,a[j][1]); for(int j=bcnt-i;j&gt;=1;j--) res=max(res,b[j][1]); return res; &#125;&#125;int main()&#123; IO::load(); int n,m,edgeCnt=0; int opt,u,v; int ans=0; n=getInt(); m=getInt(); for(int i=1;i&lt;=n;i++) bel[i]=i, h[i]=1; for(int i=1;i&lt;=m;i++)&#123; opt=getInt(); u=getInt(); v=getInt(); u^=ans; v^=ans; if(opt==0) merge(u,v,++edgeCnt); else&#123; if(find(u)!=find(v)) ans=0; else ans=query(u,v); writeInt(ans); &#125; &#125; IO::flush(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>并查集</tag>
        <tag>可做未做</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF98E】Graph]]></title>
    <url>%2F2018%2F11%2F01%2Fcf98E_graph%2F</url>
    <content type="text"><![CDATA[Description 有一个无向图，它没有重边和自环 现在有一些询问，形如“$u,v$之间是否存在一条长度为奇数的简单路径？” 这里简单路径定义为不经过重复的点的路径 $n \le 10^5,\;m\le 10^5$ Solution 不会做，废了 图论要么往缩点方向想，要么往生成树方向想。对于本题，前者显然并不适用——我们要走的是简单路径，且缩点后的图并不能帮助我们确定路径的长度 我们往生成树方向考虑 每个连通块显然可以分开处理 对于每一个连通块，我们先搜出一棵生成树并黑白染色。如果询问的两个点在同一个连通块内，且颜色不同，那么答案直接是Yes。问题是，如果颜色不同，如何判定是否存在长度为奇数的简单路径？ 有结论如下：如果$u$的颜色与$v$相同，它们之间存在一条长度为奇数的简单路径，当且仅当在搜索树上$u$到$v$的路径经过的边，至少有一条属于某一个奇环 如果一个点双连通分量内部有一个奇环，那么这个点双内部的所有边，都可以视作“属于某一个奇环的一条边”。我们用Tarjan计算每一个点双是否满足要求，在树上差分维护路径边权和即可 Summary 难以计算和具体化的题，考虑与判定相关的元素是否能引出一些结论 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010,M=100010;int n,m;namespace T&#123; int pre[N][18],dep[N]; int bel[N]; int sum[N]; int getLCA(int a,int b)&#123; if(dep[a]&lt;dep[b]) swap(a,b); for(int i=17;i&gt;=0;i--) if(dep[pre[a][i]]&gt;=dep[b]) a=pre[a][i]; if(a==b) return a; for(int i=17;i&gt;=0;i--) if(pre[a][i]!=pre[b][i]) a=pre[a][i], b=pre[b][i]; return pre[a][0]; &#125; int getSum(int a,int b)&#123; return sum[a]+sum[b]-2*sum[getLCA(a,b)]; &#125; bool query(int a,int b)&#123; if(bel[a]!=bel[b]) return false; if((dep[a]&amp;1)^(dep[b]&amp;1)) return true; return getSum(a,b)!=0; &#125;&#125;namespace G&#123; int h[N],tot; struct Edge&#123; int v,next; &#125;e[M*2]; void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot; &#125; int dfn[N],low[N],dfnTimer; int sta[N],top; bool inSta[N]; int bcnt,cut[N],bel[M*2]; bool isCut[N]; int col[N]; bool good[N],pointMark[N]; void TarjanDfs(int u,int fa)&#123; dfn[u]=low[u]=++dfnTimer; sta[++top]=u; inSta[u]=true; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; if(!dfn[v])&#123; col[v]=col[u]^1; TarjanDfs(v,u); low[u]=min(low[u],low[v]); if(dfn[u]&lt;=low[v])&#123; bcnt++; good[bcnt]=false; int x,sz=0; do&#123; sz++; x=sta[top--]; inSta[x]=false; bel[x]=bcnt; good[bcnt]|=pointMark[x]; &#125;while(x!=v); if(sz==1)&#123; bcnt--; bel[x]=0; &#125; else&#123; cut[bcnt]=u; isCut[u]=true; &#125; &#125; &#125; else if(inSta[v])&#123; low[u]=min(low[u],dfn[v]); if((col[u]^1)!=col[v]) pointMark[dfn[u]&gt;dfn[v]?u:v]=true; &#125; &#125; &#125; void Tarjan()&#123; for(int u=1;u&lt;=n;u++) if(!dfn[u]) TarjanDfs(u,0); &#125; bool tVis[N]; int getBi(int u,int v)&#123; if(bel[u]==bel[v]) return bel[u]; if(isCut[u]) swap(u,v); if(isCut[v]) return cut[bel[u]]==v?bel[u]:0; return false; &#125; void buildDfs(int u,int fa,int rt)&#123; tVis[u]=true; T::dep[u]=T::dep[fa]+1; T::bel[u]=rt; T::pre[u][0]=fa; for(int i=1;i&lt;=17;i++) T::pre[u][i]=T::pre[T::pre[u][i-1]][i-1]; for(int i=h[u],v;i;i=e[i].next) if(!tVis[v=e[i].v])&#123; T::sum[v]=T::sum[u]+good[getBi(u,v)]; buildDfs(v,u,rt); &#125; &#125; void buildTree()&#123; for(int u=1;u&lt;=n;u++) if(!tVis[u]) buildDfs(u,0,u); &#125;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); G::tot=1; int u,v; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); G::addEdge(u,v); &#125;&#125;void answerQuery()&#123; int q,a,b; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d",&amp;a,&amp;b); puts(T::query(a,b)?"Yes":"No"); &#125;&#125;int main()&#123; readData(); G::Tarjan(); G::buildTree(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>结论题</tag>
        <tag>图论---点双连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2013】火柴排队]]></title>
    <url>%2F2018%2F11%2F01%2Fnoip2013%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F%2F</url>
    <content type="text"><![CDATA[Description 略 Solution 显然是按照大小顺序对位匹配 然后是怎么移动的问题 脑子一热的我直接fou掉了“只在一边交换相邻两个，和原来的操作是等价的”，于是我就直接用了一个鬼畜的模拟：考虑两个序列最左边的元素，如果互相匹配则OK，将它们从左边删除；否则，选匹配点离左边较近的那一个人，删掉它和它的匹配点。具体实现用线段树维护下标，但是细节什么的实在是太烦人了，要是在考场上那得耗掉不少时间，可能就凉了 实际上，以某一边固定不动为模板、用最优方案操作另一边的方法的确是最优解的一种。因此，参考冒泡排序交换次数的恰好是逆序对个数这个结论，我们只需要求两个序列的相对逆序对即可 Summary 涉及双边操作和多边操作时，看看只考虑单边操作是否能得到最优解 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int INF=1e9;const int MOD=99999997;const int N=100010;int n;int a[N],b[N];void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;b[i]);&#125;int mat[2][N];bool cmpA(const int &amp;x,const int &amp;y)&#123; return a[x]&lt;a[y];&#125;bool cmpB(const int &amp;x,const int &amp;y)&#123; return b[x]&lt;b[y];&#125;void match()&#123; static int ida[N],idb[N]; for(int i=1;i&lt;=n;i++) ida[i]=idb[i]=i; sort(ida+1,ida+1+n,cmpA); sort(idb+1,idb+1+n,cmpB); for(int i=1;i&lt;=n;i++)&#123; mat[0][ida[i]]=idb[i]; mat[1][idb[i]]=ida[i]; &#125;&#125;namespace SEG&#123; const int S=N*2; int rt[2],sz; int ch[S*2][2]; int tag[S*2]; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; inline void makeTag(int u,int x)&#123; tag[u]+=x; &#125; void segAdd(int u,int l,int r,int ml,int mr,int x)&#123; if(ml&gt;mr) return; if(ml&lt;=l&amp;&amp;r&lt;=mr)&#123; makeTag(u,x); return; &#125; int mid=(l+r)&gt;&gt;1; if(mr&lt;=mid) segAdd(ch[u][0],l,mid,ml,mr,x); else if(mid&lt;ml) segAdd(ch[u][1],mid+1,r,ml,mr,x); else&#123; segAdd(ch[u][0],l,mid,ml,mid,x); segAdd(ch[u][1],mid+1,r,mid+1,mr,x); &#125; &#125; int queryPoint(int u,int l,int r,int p,int tagSum=0)&#123; tagSum+=tag[u]; if(l==r) return l+tagSum; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) return queryPoint(ch[u][0],l,mid,p,tagSum); else return queryPoint(ch[u][1],mid+1,r,p,tagSum); &#125;&#125;bool del[2][N];void solve()&#123; SEG::build(SEG::rt[0],1,n); SEG::build(SEG::rt[1],1,n); int i=1,j=1,pi,pj; int ans=0; while(i&lt;=n||j&lt;=n)&#123; while(i&lt;=n&amp;&amp;del[0][i]) i++; while(j&lt;=n&amp;&amp;del[1][j]) j++; pi=pj=INF; if(i&lt;=n&amp;&amp;mat[0][i]) pi=SEG::queryPoint(SEG::rt[1],1,n,mat[0][i]); if(j&lt;=n&amp;&amp;mat[1][j]) pj=SEG::queryPoint(SEG::rt[0],1,n,mat[1][j]); if(pi==INF||pj==INF)&#123; SEG::segAdd(SEG::rt[0],1,n,i+1,n,-1); SEG::segAdd(SEG::rt[1],1,n,j+1,n,-1); i++; j++; continue; &#125; if(pi&lt;=pj)&#123; (ans+=pi-1)%=MOD; SEG::segAdd(SEG::rt[0],1,n,i+1,n,-1); SEG::segAdd(SEG::rt[1],1,n,mat[0][i]+1,n,-1); del[1][mat[0][i]]=true; i++; &#125; else&#123; (ans+=pj-1)%=MOD; SEG::segAdd(SEG::rt[1],1,n,j+1,n,-1); SEG::segAdd(SEG::rt[0],1,n,mat[1][j]+1,n,-1); del[0][mat[1][j]]=true; j++; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; readData(); match(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>数据结构---线段树</tag>
        <tag>模拟</tag>
        <tag>逆序对</tag>
        <tag>方案特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3732】Network]]></title>
    <url>%2F2018%2F10%2F30%2Fbzoj3732%2F</url>
    <content type="text"><![CDATA[Description 给一个无向连通图，每条边有边权 你需要回答一些询问：每个询问会给出两个点$a$和$b$，请求出$a$到$b$的所有路径中经过的边的最大值的最小值 Solution 好像整体二分也能暴力搞过去…… 正解直接上最小生成树，然后直接查询$a$和$b$的树上路径最大值即可 正在学Kruskal重构树的做法 Summary 图上路径最值问题，或者和边的极值有关的问题，考虑最小生成树 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;const int N=15010,M=30010;int n,m,q;struct Edge&#123; int u,v,w;&#125;e[M];void readData()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",&amp;e[i].u,&amp;e[i].v,&amp;e[i].w);&#125;namespace T&#123; int h[N],tot; struct Edge&#123; int v,w,next; &#125;e[N*2]; void addEdge(int u,int v,int w)&#123; e[++tot]=(Edge)&#123;v,w,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,w,h[v]&#125;; h[v]=tot; &#125; int dep[N],pre[N][16],maxe[N][16]; void dfs(int u,int fa,int faEdge)&#123; pre[u][0]=fa; dep[u]=dep[fa]+1; maxe[u][0]=faEdge; for(int i=1;i&lt;=15;i++)&#123; pre[u][i]=pre[pre[u][i-1]][i-1]; maxe[u][i]=max(maxe[u][i-1],maxe[pre[u][i-1]][i-1]); &#125; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) dfs(v,u,e[i].w); &#125; inline int query(int a,int b)&#123; if(dep[a]&lt;dep[b]) swap(a,b); int res=0; for(int i=15;i&gt;=0;i--) if(dep[pre[a][i]]&gt;=dep[b])&#123; res=max(res,maxe[a][i]); a=pre[a][i]; &#125; if(a==b) return res; for(int i=15;i&gt;=0;i--) if(pre[a][i]!=pre[b][i])&#123; res=max(res,max(maxe[a][i],maxe[b][i])); a=pre[a][i]; b=pre[b][i]; &#125; res=max(res,max(maxe[a][0],maxe[b][0])); return res; &#125;&#125;int bel[N];int findBel(int x)&#123; return (bel[x]==x)?x:(bel[x]=findBel(bel[x]));&#125;bool cmpWeight(const Edge &amp;a,const Edge &amp;b)&#123; return a.w&lt;b.w;&#125;void MST()&#123; sort(e+1,e+1+m,cmpWeight); for(int u=1;u&lt;=n;u++) bel[u]=u; for(int i=1,cur=0;i&lt;=m&amp;&amp;cur&lt;n-1;i++)&#123; int fu=findBel(e[i].u),fv=findBel(e[i].v); if(fu==fv) continue; cur++; bel[fu]=fv; T::addEdge(e[i].u,e[i].v,e[i].w); &#125;&#125;void answerQuery()&#123; int a,b; for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",T::query(a,b)); &#125;&#125;int main()&#123; readData(); MST(); T::dfs(1,0,0); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>倍增</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3832】Rally]]></title>
    <url>%2F2018%2F10%2F29%2Fbzoj3832%2F</url>
    <content type="text"><![CDATA[Description 给一个边长皆为1的DAG。求删去某一个点后最长路的最小值 $n \le 5*10^5,\ m\le10^6$ Solution 直接删有点难想。运用前缀后缀的思想，我们考虑能否像那样考虑删除每一个点以后的答案。 首先必须简化模型：我们建一个超级源$S$向每一个点连一条长度为0的边，建一个超级汇$T$让所有点向它连一条长度为0的边。此时，我们只需要考虑$S$到$T$的最长路即可。 如何统计呢？考虑$S$到$T$的某一个割集——根据定义，每一条路径都经过割集内的一条边，因此我们可以尝试用这些边来统计 通过拓扑序，我们可以DP出从$S$到达每一个点$u$的最长路$f_u$、每个点$u$到$T$的最长路$g_u$。则对于任意一个割集$C$，全局的答案可以这样表示： ans=\max\{f_u+g_v+e_w\mid e(u,v)\in C\} 其中$e_w$表示$e$这条边的长度 现在考虑上删点的操作：这种统计方式在删去某一个点$x$后仍然成立并适用的前提是： 所有$u$的$f_u$必须是最新状态或者不受影响 所有$v$的$f_v$必须是最新状态或者不受影响 所有$e$与$x$必须无关 我们提出一种神秘的算法：我们按照拓扑序来枚举割集$S$。具体来说： 一开始，割中处于$S$的部分只有$S$，其余点（包括$T$）全在割中处于$T$的部分。我们将所有$(S,x)$加入$C$中 按拓扑序顺序考虑每一个$x$（$x\neq S,T$）： 将$x$的入边（即$(y,x)$）从$C$中移除 可以发现，此时的$C$恰好对应着删去$x$后原图的一个合法割，我们直接统计答案 将$x$的出边（即$(x,y)$）加入$C$ 我们使用一个multiset维护$C$的权值即可。总时间复杂度为$O(m \log m)$ Summary 临时改变单点的问题，要善用前缀后缀思想，或者前缀后缀思想的变种 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;set&gt;using namespace std;const int INF=1e9;const int N=500010,M=1000010;int n,m;namespace G&#123; int h1[N],h2[N]; int tot; struct Edge&#123; int v,w,next; &#125;e[(N*2+M)*2]; int in[N]; void addEdge(int u,int v,int w)&#123; e[++tot]=(Edge)&#123;v,w,h1[u]&#125;; h1[u]=tot; e[++tot]=(Edge)&#123;u,w,h2[v]&#125;; h2[v]=tot; in[v]++; &#125; int lis[N]; void Topsort()&#123; static queue&lt;int&gt; q; int cnt=0; q.push(n+1); while(!q.empty())&#123; int u=q.front(); q.pop(); lis[++cnt]=u; for(int i=h1[u],v;i;i=e[i].next)&#123; v=e[i].v; in[v]--; if(!in[v]) q.push(v); &#125; &#125; &#125; int f[N],g[N]; void dp()&#123; f[n+1]=0; for(int t=2;t&lt;=n+2;t++)&#123; int u=lis[t]; f[u]=-INF; for(int i=h2[u],v;i;i=e[i].next)&#123; v=e[i].v; f[u]=max(f[u],f[v]+e[i].w); &#125; &#125; g[n+2]=0; for(int t=n+1;t&gt;=1;t--)&#123; int u=lis[t]; g[u]=-INF; for(int i=h1[u],v;i;i=e[i].next)&#123; v=e[i].v; g[u]=max(g[u],g[v]+e[i].w); &#125; &#125; &#125;&#125;using G::h1;using G::h2;using G::e;using G::f;using G::g;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); G::addEdge(u,v,1); &#125; for(int u=1;u&lt;=n;u++)&#123; G::addEdge(n+1,u,0); G::addEdge(u,n+2,0); &#125;&#125;multiset&lt;int&gt; s;inline int calc(int u,int v)&#123; return f[u]+g[v]+(u!=n+1&amp;&amp;u!=n+2&amp;&amp;v!=n+1&amp;&amp;v!=n+2);&#125;void solve()&#123; for(int i=h1[n+1],v;i;i=e[i].next)&#123; v=e[i].v; s.insert(calc(n+1,v)); &#125; int bestVal=INF,bestWho=-1; set&lt;int&gt;::iterator it; for(int t=2;t&lt;=n+1;t++)&#123; int u=G::lis[t]; for(int i=h2[u],v;i;i=e[i].next)&#123; v=e[i].v; s.erase(s.find(calc(v,u))); &#125; it=s.end(); it--; int cur=(*it); if(cur&lt;bestVal)&#123; bestVal=cur; bestWho=u; &#125; for(int i=h1[u],v;i;i=e[i].next)&#123; v=e[i].v; s.insert(calc(u,v)); &#125; &#125; printf("%d %d\n",bestWho,bestVal);&#125;int main()&#123; readData(); G::Topsort(); G::dp(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>好题</tag>
        <tag>图论---拓扑序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC066F】Contest with Drinks Hard]]></title>
    <url>%2F2018%2F10%2F27%2Farc066f%2F</url>
    <content type="text"><![CDATA[Description 现在有一排$N$个物品，选第$i$个物品会有$a_i$的代价，每一个选满的区间会有1的贡献 给出$M$个询问$x,y$，求若将$a_x$替换为$y$，最大收益为多少？每次询问后，$a_x$会恢复原值 $N \le 3*10^5$ Solution 若抽象出一个长度为$N$的01数组$b$表示每一个物品选或不选，则答案为 (\sum_{i=1}^n\sum_{j=i}^n\prod_{k=i}^jb_k)-(\sum_{i=1}^na_ib_i) 我们肯定先要搞清楚不带修改的DP怎么实现 考虑这样一个状态：$f_i$表示考虑完前$i$个物品后，最大收益是多少，且$i$要么是某一段选满的区间的最后一个元素，要么是不选的元素，则有转移 sum_n=\sum_{i=1}^na_i\\ H(n)=\frac{n(n+1)}2\\ f_0=0\\ f_i=\max\{f_j+H(i-j)-(sum_i-sum_j)\mid 0 \le j < i\} 由于这个转移式涉及到了取$\max$的操作，我们可以尝试使用斜率优化来加速转移：设$k&lt;j&lt;i$且对于$i$而言$j$比$k$优，则可以列出下列式子： \begin{aligned} f_j+H(i-j)-(sum_i-sum_j) &> f_k+H(i-k)-(sum_i-sum_k)\\ \frac{(f_j+sum_j+\frac{j(j-1)}2)-(f_k+sum_k+\frac{k(k-1)}2)}{j-k} &> i \end{aligned} 现在，我们可以将每一个转移的选择抽象为平面上的一个点，并维护它们的上凸壳。注意到$i$是递增的，这意味着随着$i$的推进，在寻找最优解时贴上凸包的直线的斜率会越来越大，决策点反而有可能向左走 我们一样使用一个栈维护上凸包。插入一个新点的操作与原来的做法相同。不同的是在查询时，我们不断从栈顶弹出元素（由于询问斜率不断递增，显然它们在之后也不可能成为最优解），直到栈顶和次栈顶的连线的斜率超过$i$为止。此时，栈顶就是最优转移点 由此，我们可以在$O(n)$的时间计算出$f_i$ 如何应付单点修改$a_x=y$的询问呢？ 分类讨论两种情况：第$x$个元素不选，或者第$x$个元素必选 第一个部分相当于对$[1,x)$和$(x,n]$两个部分做一次上述DP，并将两个区间的最优解相加。实现上很简单，运用前缀后缀的思想，我们运用上述DP正着计算一次，反着计算一次，存入两个不同数组$fl,fr$，需要时直接调用前缀后和缀的答案即可 关键是第二个部分如何计算。 考虑计算一个$must_i$表示第$i$个元素必选时全局的最优解。若我们得到了这个数组，在询问$a_x=y$时，由于$a_x$在原来的$must_x$的贡献为$-a_x$，要得到新的结果，我们只需要简单地将那个贡献$-a_x$消除，再加上新的贡献$-y$即可。可以证明，当我们钦定的元素的值改变时，其他地方的决策也不会变；否则如果改动后存在更优的方案，那么未修改之前$must_x$也应该有更优的方案，矛盾 最暴力的计算思路就是：枚举一段区间$[l,r]$必选，此时全局的最优答案为： H(r-l+1)-(sum_{r}-sum_{l-1})+fl_{l-1}+fr_{r+1} 我们可以用这个答案去更新$mustl,must{l+1},…,must_r$ 考虑用分治解决这个更新：在当前分治区间$[sl,s_r]$，我们只关注那些跨过中线$s_m$的$[l,r]$（$l \in [s_l,s_m]$且$r \in (s_m,s_r]$），其余的递归处理。我们将$fl{sl-1}…fl{s_m-1}$加到凸包中，作为供选择的$l-1$，然后对于$r=s_m+1\dots s_r$，我们让它们挑选一个$l-1$，并构造一段$[l,r]$的全选区间，使得以下式子最大，记为$t_r$ t_r=\max\{fl_{l-1}+H(r-(l-1))-(sum_r-sum_{l-1})+fr_{r+1}\} 这个计算过程和实现方式与之前的DP其实是一样的，只不过我们钦定了一些初值，使得这个形式可以用于强制选择的转移 注意到$tr$可以更新$must{s_m+1…s_r}$，因此我们先对$t$做一个后缀$\max$，再对位更新到$must$上 为什么$must_{s_l…s_m}$不能更新呢？因为在这个DP中，对于每一个$t_i$，我们只能保证这个值体现的最优的$[l,r]$的$r$一定在$i$或其右边，却无法得知相应的$l$具体在什么地方。由此，在每一次分治时，左半边是无法确定范围并得到更新的。但这个问题具有良好的对称性，我们只要将将整个序列翻转以后反过来再做一次分治，即可更新现在没更新到的左半边（注意我们要保证两次分治的分治中点也要对称，因此对于区间长度为奇数的情况，中点要偏移一位） Summary 对于规模较大的DP，设置二维状态，记录每一步的过程（如在当前段进行了多少），用数据结构省略第一维并加速转移固然是一种方法，但是如果在这个思路上碰到了一些很难或无法维护的东西而导致无法快速转移，不要继续死磕。尝试省掉第二维，考虑整段转移，其式子看似玄乎，但有可能可以使用斜率优化加速。 注意一维DP状态设置的小技巧：$fi$不一定要表示$i$一定是某一段的结尾，还应该可以是结尾再闲置一小段。这可以通过转移时以段结尾转移，同时空置当前位置继承$f{i-1}$的答案来实现 强制选某一段、得到贡献，更新段内，遇到类似的玄乎的暴力更新，尝试套到分治上实现 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;cstdio&gt;#include &lt;utility&gt;#define MP make_pair#define FR first#define SE secondusing namespace std;typedef long long LL;typedef pair&lt;LL,LL&gt; PLL;namespace IO&#123; const int S=10000000; char buf[S]; int pos; void load()&#123; fread(buf,1,S,stdin); pos=0; &#125; char getChar()&#123; return buf[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const LL LINF=1ll&lt;&lt;60;const int N=300010;int n;int a[N];LL sum[N];inline LL max(LL x,LL y)&#123; return x&gt;y?x:y;&#125;inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;void reverse()&#123; for(int i=1;i&lt;=(n&gt;&gt;1);i++) swap(a[i],a[n-i+1]);&#125;void calcPrefix()&#123; sum[0]=0; for(int i=1;i&lt;=n;i++) sum[i]=sum[i-1]+a[i];&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) a[i]=getInt(); calcPrefix();&#125;LL f[N];namespace HULL&#123; PLL sta[N]; int top; void reset()&#123; top=0; &#125; PLL generate(LL x)&#123; return MP(x,f[x]+sum[x]+(x*(x-1)&gt;&gt;1)); &#125; inline bool legal(PLL &amp;a,PLL &amp;b,PLL &amp;c)&#123; return (b.SE-a.SE)*(c.FR-b.FR)&gt;(c.SE-b.SE)*(b.FR-a.FR); &#125; inline bool slopeLess(PLL &amp;a,PLL &amp;b,LL k)&#123; return (b.SE-a.SE)&lt;=k*(b.FR-a.FR); &#125; void push(int x)&#123; PLL cur=generate(x); while(top&gt;1&amp;&amp;!legal(sta[top-1],sta[top],cur)) top--; sta[++top]=cur; &#125; int query(int i)&#123; while(top&gt;1&amp;&amp;slopeLess(sta[top-1],sta[top],i)) top--; return sta[top].FR; &#125;&#125;void dp()&#123; HULL::reset(); f[0]=0; HULL::push(0); for(int i=1;i&lt;=n;i++)&#123; int j=HULL::query(i); f[i]=max(f[j]-(sum[i]-sum[j])+(1ll*(i-j)*(i-j+1)&gt;&gt;1),f[i-1]); HULL::push(i); &#125;&#125;LL fl[N],fr[N],must[N];void dpLeftRight()&#123; dp(); for(int i=1;i&lt;=n;i++) fl[i]=f[i]; reverse(); calcPrefix(); dp(); for(int i=1;i&lt;=n;i++) fr[i]=f[n-i+1]; reverse(); calcPrefix();&#125;void swapLR()&#123; for(int i=1;i&lt;=n;i++) swap(fl[i],fr[n-i+1]);&#125;LL g[N];void divide(int l,int r,int offset)&#123; if(l==r)&#123; g[l]=max(g[l],fl[l-1]+fr[r+1]+1-a[l]); return; &#125; int mid=(l+r+offset)&gt;&gt;1; HULL::reset(); for(int i=l-1;i&lt;mid;i++)&#123; f[i]=fl[i]; HULL::push(i); &#125; static LL t[N]; for(int i=mid+1;i&lt;=r;i++)&#123; int j=HULL::query(i); t[i]=f[j]-(sum[i]-sum[j])+1ll*(i-j)*(i-j+1)/2+fr[i+1]; &#125; for(int i=r-1;i&gt;mid;i--) t[i]=max(t[i],t[i+1]); for(int i=mid+1;i&lt;=r;i++) g[i]=max(g[i],t[i]); divide(l,mid,offset); divide(mid+1,r,offset);&#125;void calcMust()&#123; for(int i=1;i&lt;=n;i++) must[i]=-LINF; for(int i=1;i&lt;=n;i++) g[i]=-LINF; divide(1,n,0); for(int i=1;i&lt;=n;i++) must[i]=max(must[i],g[i]); reverse(); swapLR(); calcPrefix(); for(int i=1;i&lt;=n;i++) g[i]=-LINF; divide(1,n,-1); for(int i=1;i&lt;=n;i++) must[i]=max(must[i],g[n-i+1]); reverse(); swapLR();&#125;void answerQuery()&#123; int m,x,y; m=getInt(); for(int i=1;i&lt;=m;i++)&#123; x=getInt(); y=getInt(); printf("%lld\n",max(fl[x-1]+fr[x+1],must[x]-(y-a[x]))); &#125;&#125;int main()&#123; IO::load(); readData(); dpLeftRight(); calcMust(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>分治</tag>
        <tag>DP---斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC001D】Snuke 回文生日礼物]]></title>
    <url>%2F2018%2F10%2F24%2Fagc001d%2F</url>
    <content type="text"><![CDATA[Description 给一个长度为$M$的数组$A$，满足元素之和为$N$ 你可以将$A$任意排列。请你判断下面这种情况能否出现： 有一某个长度为$N$的字符串$S$，其首$A_1$项、接下来$A_2$项、接下来$A_3$项…各自构成回文串 是否存在另一个元素和为$N$、任意长度的数组$B$（元素全为正整数），强迫$S$首$B_1$项、接下来$B_2$项、接下来$B_3$项…各自构成回文串后，$S$必定是一个全部字符都相同的字符串 如果存在，输出$B$；否则输出”Impossible” $N \le 10^5 \ M\le 100$ Solution $A$的要求等价于某一段字符串要对称，即对称的字符相等。确定完$A$的排列顺序后，我们可以在$S$的上方画出$A$的限制——两个相等的字符连一条边。可以发现，这些边构成了一些简单的上彩虹（不会一个彩虹内嵌套两个彩虹）。如果我们再对$B$构造出某一种画下彩虹的方案，使得所有$N$个点都处于一个连通块内，那么这个方案就是合法的 那么我们应该先考虑如何将$A$重排，然后考虑$B$的行为策略 首先必须发现一个性质：如果$A$中的元素全是偶数，即每个彩虹的正中心都不是一个单点，此时$B$总能使得全部点连通。具体做法是：对于$A$最左边的彩虹$A1$，用一个宽度为$A_1-2$的下彩虹靠左覆盖它的一部分，再用一个宽度为1的彩虹覆盖接下来的一个元素（即$S{A1-1}$）。此时$A_1$这个彩虹的内部已经连通，并且在最右边的位置伸出了一个代表当前彩虹所有元素的接口。接下来，我们按顺序输出$A_2…A{m-1}$作为$B$的接下来的彩虹宽度，错位连接$A1,A_2,…,A{m-1}$，每画一次下彩虹，总会留下一个代表了之前所有彩虹包含的元素的接口。最后，只需要考虑一下最后的情况，用一个偶数长度的下彩虹或者一个奇数长度的下彩虹加上一个单点就可以闭合。可以发现这样做总能将所有元素连接成一个连通块 其次，我们通过画彩虹来连通每一个元素的行为模式与一笔画问题十分相似。观察$A$中的每一个彩虹，如果其长度为奇数，那么其正中心会留下一个“端口”，这个端口不能继续延伸，只能接入。因此，如果$A$中奇数数量超过了2，我们就无法用一条只有两个端点的曲线一笔画，此时无解 现在剩余的情况只有奇数彩虹数目为1或2的情况了。我们提出一个简化的思想：将奇数彩虹提到$A$的最前和最后，再来构造B 可以发现，只要采取类似的操作使得第一个人只留下一个接口（若是偶数用前面的做法，若奇数显然直接用一个$A1-1$的下彩虹即可），然后顺序输出$A_2\dots A{m-1}$，最后特判如何闭合即可（偶数同前，奇数直接$A_m$） Summary 特殊的、决定全局的东西，构造和考虑时可以放到一个特殊的位置，简化考虑过程 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define LHX_BAOLING &#123;puts("Impossible"); return 0;&#125;using namespace std;const int N=100010,M=110;int n,m;int a[M];int p1,p2;int b[N],bcnt;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;a[i]);&#125;bool judge()&#123; p1=p2=-1; for(int i=1;i&lt;=m;i++) if(a[i]&amp;1)&#123; if(p1==-1) p1=i; else if(p2==-1) p2=i; else return false; &#125; return true;&#125;void construct()&#123; if(p1!=-1)&#123; swap(a[1],a[p1]); p1=1; &#125; if(p2!=-1)&#123; swap(a[p2],a[m]); p2=m; &#125; for(int i=1;i&lt;=m;i++) printf("%d ",a[i]); puts(""); if(m==1)&#123; if(a[1]&amp;1)&#123; if(a[1]-1) b[++bcnt]=a[1]-1; b[++bcnt]=1; &#125; else&#123; if(a[1]-2) b[++bcnt]=a[1]-2; b[++bcnt]=2; &#125; &#125; else&#123; if(a[1]&amp;1)&#123; if(a[1]-1) b[++bcnt]=a[1]-1; &#125; else&#123; if(a[1]-2) b[++bcnt]=a[1]-2; b[++bcnt]=1; &#125; for(int i=2;i&lt;m;i++) b[++bcnt]=a[i]; &#125; int sum=0; for(int i=1;i&lt;=bcnt;i++) sum+=b[i]; if(n-sum)&#123; int x=n-sum; if(x&amp;1)&#123; if(x-1) b[++bcnt]=x-1; b[++bcnt]=1; &#125; else b[++bcnt]=x; &#125; printf("%d\n",bcnt); for(int i=1;i&lt;=bcnt;i++) printf("%d ",b[i]); puts("");&#125;int main()&#123; readData(); if(!judge()) LHX_BAOLING; construct(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>结论题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC096E】Every thing on it]]></title>
    <url>%2F2018%2F10%2F22%2Farc096e%20Every%20thing%20on%20it%2F</url>
    <content type="text"><![CDATA[Description 给定$n$个元素，一共有$2^n$个生成子集 求有多少种子集族，满足每一个元素都至少被包含在两个集合之中 Solution 肯定是使用容斥 总方案数为$2^{2^n}$。设满足$1\dots i$号元素要么不出现，要么只出现在一个集合的子集族数量为$f_i$，则有 \text{ans}=2^{2^n}-\sum_{i=1}^n(-1)^i{n \choose i}f_i 如何求$f_i$呢？它很难用一个式子表示出来，但题目允许我们用$O(n)$的时间计算每一个$f_i$，因此考虑将$f_i$拆分每一种情况，再对每一种情况求和 考虑$fi$表示的每一个情况，我们要找到唯一对应的特征：有多少个子集包含了$1\dots i$？设$g{i,j}$表示在$f_i$意义下，有多少子集族满足恰好$j$个集合包含$1\dots i$中的元素 $g_{i,j}$的计算思路可以这么解释： 将不超过$i$个元素（特别地，可以为0个元素），分配到$j$个非空集合，有多少种方法？设为$w_{i,j}$ 这$j$个集合各自的后$n-i$中元素可以任意选择 除了这$j$个必选的集合，其余可以被选择的集合的前$1\dots i$项都必须为0。记这些集合的数量为$k$，则我们有$2^k$种选法 综上，有： f_i=\sum_{j=0}^ig_{i,j}\\ g_{i,j}=w_{i,j} * (2^{n-i})^j * 2^{2^{n-i}} 实际计算时，要把每一个$g_{i,j}$共有的一项$2^{2^{n-i}}$提出，减小常数 $w{i,j}$怎么求？这个意义等价于将$i+1$个元素划分成$j+1$个集合，然后将$i+1$所在的集合当做“不出现在原问题中的集合的元素”组成的集合，删去。也就是$w{i,j}=S2_{i+1,j+1}$ 如果预处理做的完善，时间复杂度为$O(n^2)$。我这里直接做快速幂了，使用上面的提项优化后，速度还算过得去 Summary 求解东西复杂，在时间复杂度允许的情况下，拆分成每一个量化情况，然后对方案数求和。每一个量化情况可能与原问题的直观思维毫无关系，关键是要对每一种情况找到唯一对应的一个特征，统计的时候就枚举特征、计算每个特征的方案数 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;using namespace std;const int N=3010;int n;int MOD;int fact[N],iact[N];int s[N][N];int fastPow(int x,int y,int MOD=::MOD)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;MOD);&#125;void initMath(int n)&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fastPow(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return (0&lt;=m&amp;&amp;m&lt;=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void initStirling(int n)&#123; // prefix of each line for(int i=0;i&lt;=n;i++) s[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) s[i][j]=(1ll*s[i-1][j]*(j+1)%MOD+s[i-1][j-1])%MOD;&#125;void calc()&#123; int ans=fastPow(2,fastPow(2,n,MOD-1)); int f; for(int i=1;i&lt;=n;i++)&#123; f=0; for(int j=0;j&lt;=i;j++) (f+=1ll*s[i][j]*fastPow(fastPow(2,n-i),j)%MOD)%=MOD; f=1ll*f*fastPow(2,fastPow(2,n-i,MOD-1))%MOD; (ans+=((i&amp;1)?-1ll:1ll)*C(n,i)*f%MOD)%=MOD; &#125; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); initMath(n); initStirling(n); calc(); return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>计数问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4071】八邻旁之桥]]></title>
    <url>%2F2018%2F10%2F22%2Fbzoj4071%2F</url>
    <content type="text"><![CDATA[Description 一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 A 和区域 B。 每一块区域沿着河岸都建了恰好 1000000001 栋的建筑，每条岸边的建筑都从 0 编号到 1000000000。相邻的每对建筑相隔 1 个单位距离，河的宽度也是 1 个单位长度。区域 A 中的 i 号建筑物恰好与区域 B 中的 i 号建筑物隔河相对。 城市中有 N 个居民。第 i 个居民的房子在区域 Pi 的 Si 号建筑上，同时他的办公室坐落在 Qi 区域的 Ti 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 K 座横跨河流的大桥。 由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。当政府建造最多 K 座桥之后，设 Di 表示第 i 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 D1+D2+⋯+DN 最小。 $N \le 100000$，$K \le 2$ Solution 场上的思路： 去掉在同一侧跑的人，得出答案中必定存在的一部分值 $K=1$：随便搞一下，枚举桥位置（一定靠在某一个关键点上），统计 $K=2$：枚举左边的桥，统计右边的桥的每种选择的代价的最小值 结果就是第二部分根本没有办法维护，每一次左边的桥右移，都会带来$O(n)$规模的改变。场上也觉得已经行不通了，但奈何完全想不到别的思路。如果能早点弃掉，或许还能做一下B $K=1$ 我们还是得从$K=1$的情况入手。原来的搞法其实非常不美观且难实现，而我却没有在$K=1$时细想。 忽略掉在同一侧跑的人后，记一个人的两个关键点位置为$a$和$b$（$a \le b$），具体是从哪侧到哪侧完全不重要，我们已经可以把每个人看做一个线段了（场上想到这步时仍然在用两边的画法理解）。 如果能确定这座桥的具体坐标$x$，则总代价为 \sum_{i}\mid a_i-x\mid +\mid b_i-x\mid 如果我们要让总代价尽可能小，这不就是使所有的$a$和所有的$b$到$x$的距离之和最小吗？这是一个经典的问题，取中位数即可 于是我们只要把$a$和$b$放在一起排一个序，取中位数作为桥的位置，计算贡献即可 $K=2$ 有了$K=1$时一个靠谱的模型，我们只要枚举每一个人选哪一座桥，就可以将当前局面划分成两个$K=1$的问题。直接枚举显然不优也做不了，因此我们要枚举那些可能成为最优的局面。 考虑一个人，局面中有两座桥，他倾向于选谁？ 在两座桥的某一侧：选靠近它的那一座 跨过了某一座桥：选这座桥 跨过了两座桥：任选一个 在两座桥的正中间：这个是重点，记两个桥的坐标分别为$x$和$y$，则我们要拿$\mid x-a\mid+\mid x-b\mid$和$\mid y-a \mid + \mid y-b \mid$比较，谁小选谁；可每一个人都是两个值，不好量化。我们可以取$a$与$b$的平均值$m=a+b$，则其实要拿的是$2\mid m-x\mid $与$2\mid m-y \mid $比较。 此时我们发现，如果套用最后一点的比较方式，每次都选择与$m_i$更近的桥，这个决策同样适用于前三类情况。于是，我们就用一个变量的选择策略，统一并量化了每一个人的决策。 我们干脆把每一个人按$m_i$排序。则确定了某一个分界点$p$后，$m_i \le p$的都会选择某一座桥，$m_i &gt; p$的都会选择另一座桥。 对于每一部分，我们使用数据结构维护中位数并计算答案即可。这里的实现方式很多，我使用了一棵前缀权值线段树和后缀权值线段树模拟$p$的枚举 Summary 如果确认当前方法已经有无法省略的复杂度，要尽可能地强迫自己换个思考角度 分类讨论的题目，尝试量化决策。如果情况太多，看看大家是不是有共同的某一种倾向，并量化那个倾向 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N=100010;const LL LINF=1ll&lt;&lt;60;int m;int n;LL ansBas;int d[N*2],dcnt;struct Require&#123; int a,b;&#125;p[N];inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;inline LL abs(LL x)&#123; return x&gt;=0?x:-x;&#125;void readData()&#123; scanf("%d%d",&amp;m,&amp;n); int tn=0; char c[2][2]; int x,y; for(int i=1;i&lt;=n;i++)&#123; scanf("%s%d%s%d",c[0],&amp;x,c[1],&amp;y); if(x&gt;y) swap(x,y); if(c[0][0]==c[1][0]) ansBas+=y-x; else p[++tn]=(Require)&#123;x,y&#125;; &#125; n=tn;&#125;void Diz()&#123; dcnt=0; for(int i=1;i&lt;=n;i++)&#123; d[++dcnt]=p[i].a; d[++dcnt]=p[i].b; &#125; sort(d+1,d+1+dcnt); dcnt=unique(d+1,d+1+dcnt)-d-1; for(int i=1;i&lt;=n;i++)&#123; p[i].a=lower_bound(d+1,d+1+dcnt,p[i].a)-d; p[i].b=lower_bound(d+1,d+1+dcnt,p[i].b)-d; &#125;&#125;void solve1()&#123; static int lis[N*2],cnt=0; for(int i=1;i&lt;=n;i++) lis[++cnt]=p[i].a,lis[++cnt]=p[i].b; sort(lis+1,lis+1+cnt); int mid=(cnt+1)&gt;&gt;1; LL ans=ansBas+n; for(int i=1;i&lt;=cnt;i++) ans+=abs(d[lis[i]]-d[lis[mid]]); printf("%lld\n",ans);&#125;int queryBackSize;struct Seg&#123; int rt,sz; int ch[N*4][2]; int size[N*4]; LL sum[N*4]; inline void pushup(int u)&#123; size[u]=size[ch[u][0]]+size[ch[u][1]]; sum[u]=sum[ch[u][0]]+sum[ch[u][1]]; &#125; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; void modify(int u,int l,int r,int p,int opt)&#123; if(l==r)&#123; size[u]+=opt; sum[u]+=opt*d[l]; return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) modify(ch[u][0],l,mid,p,opt); else modify(ch[u][1],mid+1,r,p,opt); pushup(u); &#125; int findKthPos(int u,int l,int r,int k)&#123; if(l==r) return l; int mid=(l+r)&gt;&gt;1; if(k&lt;=size[ch[u][0]]) return findKthPos(ch[u][0],l,mid,k); else&#123; queryBackSize+=size[ch[u][0]]; return findKthPos(ch[u][1],mid+1,r,k-size[ch[u][0]]); &#125; &#125; LL querySum(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[u]; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid) return querySum(ch[u][0],l,mid,ql,qr); else if(mid&lt;ql) return querySum(ch[u][1],mid+1,r,ql,qr); else return querySum(ch[u][0],l,mid,ql,mid)+querySum(ch[u][1],mid+1,r,mid+1,qr); &#125;&#125;s1,s2;bool cmp(const Require &amp;x,const Require &amp;y)&#123; return (d[x.a]+d[x.b])&lt;(d[y.a]+d[y.b]);&#125;void change(Seg &amp;s,int id,int opt)&#123; s.modify(s.rt,1,dcnt,p[id].a,opt); s.modify(s.rt,1,dcnt,p[id].b,opt);&#125;LL calc(int cut)&#123; LL res=0; int pos,len; if(cut)&#123; len=cut*2; queryBackSize=0; pos=s1.findKthPos(s1.rt,1,dcnt,(len+1)&gt;&gt;1); res+=s1.querySum(s1.rt,1,dcnt,pos,dcnt)-1ll*d[pos]*(len-queryBackSize); if(pos&gt;1) res+=1ll*d[pos]*queryBackSize-s1.querySum(s1.rt,1,dcnt,1,pos-1); &#125; len=(n-cut)*2; queryBackSize=0; pos=s2.findKthPos(s2.rt,1,dcnt,(len+1)&gt;&gt;1); res+=s2.querySum(s2.rt,1,dcnt,pos,dcnt)-1ll*d[pos]*(len-queryBackSize); if(pos&gt;1) res+=1ll*d[pos]*queryBackSize-s2.querySum(s2.rt,1,dcnt,1,pos-1); return res;&#125;void solve2()&#123; s1.build(s1.rt,1,dcnt); s2.build(s2.rt,1,dcnt); sort(p+1,p+1+n,cmp); for(int i=1;i&lt;=n;i++) change(s2,i,1); LL ans=LINF; for(int i=1;i&lt;=n;i++)&#123; change(s1,i,1); change(s2,i,-1); ans=min(ans,calc(i)); &#125; printf("%lld\n",ansBas+n+ans);&#125;int main()&#123; readData(); if(!n)&#123; printf("%lld\n",ansBas); return 0; &#125; Diz(); if(m==1) solve1(); else solve2(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>结论题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC019D】Shift and Flip]]></title>
    <url>%2F2018%2F10%2F22%2Fagc019d%20Shift%20and%20Flip%2F</url>
    <content type="text"><![CDATA[Description 有两个长度相等的01串$B$和$A$，你可以花费1的代价做下面的某一个操作： 将$B$循环左移一位或循环右移一位 若$A$的某一位是1，你可以把$B$此时对应的那位翻转 求最少花费多少代价，才能把$B$变得和$A$完全一样？（无解输出-1） Solution 我们把每个串看做一个01环 总要有个出发点，我们不如枚举$B$最后哪一位$B_x$对齐了$A_0$，这样，$B$的哪些位需要翻转就可以唯一确定，并直接计算翻转操作的次数了。我们只需要考虑：如何旋转$B$才能使得每一个需要翻转的位有机会翻转 我们可以对$A$上的每一个位置$i$处理出它与逆时针第一个1的距离$l_i$以及它与顺时针第一个1的距离$r_i$。看回$B$中需要翻转的位，它们肯定会要求在旋转的时候让它们与这两个选择的一种有重合的机会。 考虑逆时针旋转归零的过程，顺时针同理。如果某个需要翻转的位置逆时针第一个1与其距离不超过$x$，显然它们会在旋转的过程中自然地得到一个机会翻转，因此我们不需要额外考虑它。除去这些自然满足的需求位置，剩余位置要么要求归零后多转$l_i-x$再归零，要么要求开始旋转前先反向多转$r_i$再转回来。 问题转化为我们有$k$个二元组$(a_i,b_i)$，我们要从每一个二元组选一个数，请最小化这个值：选择的$a$的最大值加上选择的$b$的最大值 这个数没有什么很好的特性，我们直接暴力计算，钦定$a$不超过多少，然后计算$b$的最小值：按$a_i$从小到大排序，枚举$1\dots i$选$a$、$i+1\dots k$选$b$的答案，更新即可。实现上，排序+后缀max就可以实现 这样，顺时针归零的代价就是：需要翻转的位数+$x$+$2(maxa+maxb)$，单次计算复杂度为$O(n \log n)$。我们用同样的思路可以计算出反向旋转的代价 最后，取每种情况的最小值即可 Summary 如果一种操作是另一种操作的前提，后者可能有固定的最少执行次数，只需要考虑前一种操作要如何走才能满足每一个固定操作的前提即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N=2010;const int INF=1e9;int n;int a[N],b[N];int originSum,targetSum;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void readData()&#123; static char str[N]; scanf("%s",str); n=strlen(str); for(int i=0;i&lt;n;i++)&#123; b[i]=(str[i]=='1'); originSum+=b[i]; &#125; scanf("%s",str); for(int i=0;i&lt;n;i++)&#123; a[i]=(str[i]=='1'); targetSum+=a[i]; &#125;&#125;int l[N],r[N];void init()&#123; for(int i=0;i&lt;n;i++) l[i]=INF,r[i]=INF; for(int t=0,i=0,d=INF;t&lt;=3*n;t++,i=(i+1)%n)&#123; if(a[i]) d=0; else d++; l[i]=min(l[i],d); &#125; for(int t=0,i=n-1,d=INF;t&lt;=3*n;t++,i=(i-1+n)%n)&#123; if(a[i]) d=0; else d++; r[i]=min(r[i],d); &#125;&#125;struct Data&#123; int l,r;&#125;s[N];int scnt;bool cmpL(const Data &amp;a,const Data &amp;b)&#123; return a.l&lt;b.l;&#125;int calc(int x)&#123; int cnt=0; int res=INF; static int back[N]; scnt=0; for(int i=0;i&lt;n;i++) if(b[i]!=a[(i-x+n)%n])&#123; cnt++; if(l[i]&gt;x) s[++scnt]=(Data)&#123;l[i]-x,r[i]&#125;; &#125; sort(s+1,s+1+scnt,cmpL); back[scnt+1]=0; for(int i=scnt;i&gt;=1;i--) back[i]=max(back[i+1],s[i].r); for(int i=0;i&lt;=scnt;i++) res=min(res,x+(s[i].l*2)+(back[i+1]*2)); scnt=0; for(int i=0;i&lt;n;i++) if(b[i]!=a[(i-x+n)%n])&#123; if(r[i]&gt;(n-x)) s[++scnt]=(Data)&#123;l[i],r[i]-(n-x)&#125;; &#125; sort(s+1,s+1+scnt,cmpL); back[scnt+1]=0; for(int i=scnt;i&gt;=1;i--) back[i]=max(back[i+1],s[i].r); for(int i=0;i&lt;=scnt;i++) res=min(res,(n-x)+(s[i].l*2)+(back[i+1]*2)); return res+cnt;&#125;void solve()&#123; int ans=INF; for(int i=0;i&lt;n;i++) ans=min(ans,calc(i)); printf("%d\n",ans);&#125;int main()&#123; readData(); if(!targetSum)&#123; puts(!originSum?"0":"-1"); return 0; &#125; init(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>可做未做</tag>
        <tag>方案特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC019F】Yes or No]]></title>
    <url>%2F2018%2F10%2F21%2Fagc019f_Yes%20or%20no%2F</url>
    <content type="text"><![CDATA[Description 有$n+m$个命题，其中$n$个为真，$m$个为假 它们会以随机顺序给出。每次你可以猜测当前命题的真假，然后系统会告诉你真正答案。如果猜对了，你会得到1分 求在使用最优策略下你的期望得分 $n,m \le 5*10^5$ Solution 策略显然是比较真命题和假命题剩余数量的多少后，猜剩余多的那类命题；若剩余数量相同，则随便猜一个 考虑将局面抽象为一个$(n,m)$的点，表示现在还剩下$n$个真和$m$个假。那么给出命题的顺序相当于从$(n,m)$出发，只向下或向左走到$(0,0)$的一条路径。对于每一条路径，我们都有唯一对应的决策，也就有唯一对应的得分。由于路径数量可以确定，即${n+m \choose n}$，我们只需要统计每一种的路径的得分之和即可算出期望得分 原来“谁剩下多选谁”的策略在网格图上体现为什么呢？ 当前点在$y=x$的下方时，我们总猜下一步路径会往左 当前点在$y=x$的上方时，我们总猜下一步路径会往下 当前点在$y=x$上时，我们随机猜一个方向走 先不考虑3.涉及的边——从$y=x$上走出的边，一条路径的权值，就是$y=x$下方的横边数量加上$y=x$上方的竖边数量，因为每一条边代表着一次正确猜测，得1分；对于3.涉及的边，在策略的角度上我们从直线上某一个点$(i,i)$出发，随机向下或者向右，有$\frac 12$的概率得一分，那么从每条边的贡献的角度上看，这些边的得分就是$\frac 12$ 我们发现，不论路径多么复杂，只要先去除3.涉及的边，剩余边的得分都一定是$\max(n,m)$。我们将路径看做有两只脚贴在$y=x$上的若干小路径，每一条小路径向左走和向下走的次数都是完全一样的（因为延长两个接口和后每条小路径都是一个等腰三角形，即向下和向左次数一样）。除了最开始的一段路径可能与$y=x$只有一个接口，但这就是贡献开始不同的地方：这一段路径的贡献，命题数量多的命题对应的横边或竖边得分会多。综上就可以得到$\max(n,m)$的结论。虽然我们不应该把3.涉及的边讨论在这里，但是我们发现它们不论怎样都在这种情况中无贡献，所以没有关系 因此最终期望会有一个基础值$\max(n,m)$，剩余的部分就是$\frac{\sum_{path}3.贡献}{n+m \choose n}$。这个$\sum$等价于直接统计每一个$(i,i)$被经过的次数$t={2i\choose i}{(n-i)+(m-i)\choose (n-i)}$，乘上$\frac 12$后求和。我们可以很轻松的做到$O(n)$的复杂度 Summary 阶段性问题，不妨将模型抽象到二维平面上解决 如果方案形式比较复杂不容易看出规律，尝试将每一个方案看成若干个有规律的小方案，再去探讨性质 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;using namespace std;const int N=1000010;const int MOD=998244353,INV2=(MOD+1)&gt;&gt;1;int n,m;int fact[N],iact[N];inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;int fastPow(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void init(int up)&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=up;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[up]=fastPow(fact[up],MOD-2); for(int i=up-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return m&lt;=n?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m);&#125;void solve()&#123; if(n&lt;m) swap(n,m); int ans=0; for(int i=1;i&lt;=m;i++) (ans+=1ll*C(2*i,i)*C((n-i)+(m-i),n-i)%MOD)%=MOD; ans=1ll*ans*INV2%MOD; ans=1ll*ans*fastPow(C(n+m,n),MOD-2)%MOD; (ans+=n)%=MOD; printf("%d\n",ans&gt;=0?ans:ans+MOD);&#125;int main()&#123; readData(); init(n+m); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>转化</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC097F】Monochrome Cat]]></title>
    <url>%2F2018%2F10%2F20%2Farc097f_MonochromeCat%2F</url>
    <content type="text"><![CDATA[Description 有一棵$n$个节点的树，每个节点初始时要么是白色，要么是黑色 现在你可以任意挑一个点站上去，任意做下列两种操作的一种，直到所有点变为黑色为止： 将当前所在点反色 走到与当前点$u$相邻的某个点$v$，然后令$v$反色 问最少执行多少次操作才能达成目标？ $n \le 10^5$ Solution 首先，排除冗余部分：如果这棵无根树的某一个子树内没有任何白点，我们完全可以忽略其不计，因为没有必要走进去，也没有必要从里面走出来 我们将冗余子树删去后，必定得到一棵叶子全白的树，原问题等价于在这棵树上进行操作 由于此时树上的每一个点都是必要的，因此在行走的过程中，每个点至少会被遍历一次，这让我们联想到了路径覆盖树的形式。猜想是否总存在一种从某个叶子出发、在某个叶子结束的路径，满足操作步数最优。具体来说，我们从树上的一个叶子出发，按最优的顺序（先走完子树内叶子再出去）逐个走向每一个叶子，每走一步都相当于执行一次1.操作；在这个基础上，对于每一个点，考虑其被执行1.操作的次数以及初始颜色后，我们可以唯一决定是否要对其额外进行一次2.操作 最优解一定会有起终都在叶子的路径的情况吗？是的。如果最优解的路径两端不在叶子上，我们可以重复将端点下移，直到其到达叶子节点为止。拿终点举例（起点同理），可以发现，这样转化后，总操作次数不会改变： （虽然说不转化好像也能做，不过这样看问题会比较舒服） 观察这个形式得出：除了选定的起始叶子和终止叶子的路径上的边只单向经过一次，其余边都往返经过两次。考虑先计算出从某一个点出发再走回这个点的答案（显然这个点选谁，答案都一样），并在确定起点和终点时，调整到当前的答案 前者的答案中，为了遍历整棵树，我们恰好做$2(n-1)$次1.操作。记一个点的奇偶性为其度数的奇偶性，则2.操作的操作次数即奇黑的点数+偶白的点数。记这个总值为$S$ 如果确定一条出发点和终止点为两个不同叶子节点的路径，其边长为$len$，则答案等于$S$减去$len$次1.操作（不需要返回），减去路径上奇黑的点数和偶白的点数后（撤销），再加上路径上偶黑的点数和不算终点的奇白的点数，因为这条路径上的每个点（除了终点）相对于原来都少做了一次1.操作，因此原来要额外做2.的现在不用做，原来不用做2.的现在要额外做。由于终点的“进入次数”并没有变化，所以它和$S$中的状态是一样的 $S$确定，我们最大化减去的值即可。因此现在我们只需要统计过叶路径的最大值。一条过叶路径的权值定义为（记$cnt$为点数，即$len+1$；奇白-1是因为终点一定是奇白） (cnt-1)+(奇黑+偶白)-(偶黑+(奇白-1))\\ =cnt+(奇黑+偶白)-(偶黑+奇白) 发现这个权值是可以加法合并的。使用树上DP记录每一个$u$到叶子节点路径权值最大值，在每一个点考虑合并两个子树引出的路径即可。最后，从$S$中减去全局的最大值。 时间复杂度$O(n)$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;const int N=100010;const int INF=1e9;int n,originN;int deg[N];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];int col[N]; // 0:black 1:whiteint whiteSum,firstWhite;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); originN=n; int u,v; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125; static char str[N]; scanf("%s",str+1); for(int i=1;i&lt;=n;i++)&#123; col[i]=(str[i]=='W'); whiteSum+=col[i]; if(col[i]&amp;&amp;!firstWhite) firstWhite=i; &#125;&#125;bool del[N];bool haveWhite[N];int originNeed;int maxMinus;int f[N];void deleteUseless(int u,int fa)&#123; haveWhite[u]=(col[u]==1); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; deleteUseless(v,u); if(!haveWhite[v])&#123; n--; del[v]=true; &#125; else&#123; haveWhite[u]|=haveWhite[v]; deg[u]++; deg[v]++; &#125; &#125;&#125;int getRoot()&#123; for(int u=1;u&lt;=originN;u++) if(!del[u]&amp;&amp;deg[u]&gt;1) return u; return -1; // unexpected&#125;void dfs(int u,int fa)&#123; int type=(col[u]&amp;1)^(deg[u]&amp;1); originNeed+=(type==1); f[u]=-INF; bool haveSon=false; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;!del[v])&#123; haveSon=true; dfs(v,u); if(f[u]!=-INF) maxMinus=max(maxMinus,f[u]+f[v]); f[u]=max(f[u],f[v]+1+(type==1)-(type==0)); &#125; if(!haveSon) // leaf f[u]=1+(type==1)-(type==0);&#125;void check()&#123; if(whiteSum&lt;=1)&#123; printf("%d\n",whiteSum); exit(0); &#125; if(n==2)&#123; puts("2"); exit(0); &#125;&#125;int main()&#123; readData(); check(); deleteUseless(firstWhite,0); check(); originNeed=(n-1)*2; // for each edge twice maxMinus=-INF; int rt=getRoot(); dfs(rt,0); printf("%d\n",originNeed-maxMinus); return 0;&#125;]]></content>
      <tags>
        <tag>DP---树形DP</tag>
        <tag>方案特征</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC097E】Sorted and sorted]]></title>
    <url>%2F2018%2F10%2F20%2Farc097e_SortedandSorted%2F</url>
    <content type="text"><![CDATA[Description 有$n$个白球，标号$1\dots n$。同理有$n$个黑球 现在这$2n$个球被排成了一行 每次你可以交换相邻的两个球。问至少要操作多少次，才可以使得局面中相同颜色的球标号递增 $n \le 2000$ Solution 一开始总是在想探究具体操作有什么规律 实际上，应该从全局上看。考虑一个排列，若只使用交换相邻元素的方式排序，则最少交换次数等于排列的逆序对个数。这个结论可以推广：对于一些元素，它们组成了一个排列，若给出目标排列，则达到目标的最少交换次数等于这样的有序对$(a,b)$的对数：$a$与$b$在初始时的先后顺序与终止时的先后顺序不同 因此，如果我们确定了终止时的局面，最小步数是确定的。考虑到终止局面必定是两个递增的序列嵌套在一起，因此我们使用DP填写终止局面，并求相对于初始局面的逆序对最小值 设$f_{i,j}$表示终止局面的前$i+j$位，已经填写了白球的$1\dots i$，黑球的$1 \dots j$，前$i+j$位相对于原序列的逆序对个数最少是多少 转移显然，枚举下一位是$白{i+1}$还是$黑{j+1}$，然后直接查询这个新元素在原序列位置的左边有多少还未填的元素，就等于新填入元素带来的逆序对个数 Summary 题目要求我们使用某一些操作执行最少次数来达成目标，一种思路是探究操作的规律和方向，一种思路是如果确定终止局面后计算步数的形式是某一种模型，我们直接DP填终止局面求步数最小值即可 问题形式如果是两个经典模型的叠加，考虑原模型的性质在叠加模型中是否也适用 两个排列通过交换相邻元素，最少步数等于终止排列相对于原排列的逆序对个数 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;using namespace std;const int N=2010;const int INF=1e9;int n;int p[2][N];int preSum[2][N][N*2];inline void updateMin(int &amp;x,int y)&#123; x=(y&lt;x)?y:x;&#125;void readData()&#123; scanf("%d",&amp;n); static char str[5]; int x; for(int i=1;i&lt;=n*2;i++)&#123; scanf("%s%d",str,&amp;x); p[str[0]=='W'][x]=i; &#125;&#125;void initPrefix()&#123; for(int k=0;k&lt;2;k++)&#123; for(int j=n;j&gt;=1;j--)&#123; for(int i=1;i&lt;=n*2;i++)&#123; preSum[k][j][i]=preSum[k][j+1][i]; if(i&gt;=p[k][j]) preSum[k][j][i]++; &#125; &#125; &#125;&#125;int f[N][N];void dp()&#123; for(int a=0;a&lt;=n;a++) for(int b=0;b&lt;=n;b++) f[a][b]=INF; f[0][0]=0; for(int i=0;i&lt;2*n;i++)&#123; for(int a=0,b;a&lt;=i;a++)&#123; b=i-a; if(a&lt;=n&amp;&amp;b&lt;=n)&#123; if(a&lt;n) // fill a+1 updateMin(f[a+1][b],f[a][b]+preSum[0][a+2][p[0][a+1]-1]+preSum[1][b+1][p[0][a+1]-1]); if(b&lt;n) // fill b+1 updateMin(f[a][b+1],f[a][b]+preSum[0][a+1][p[1][b+1]-1]+preSum[1][b+2][p[1][b+1]-1]); &#125; &#125; &#125; printf("%d\n",f[n][n]);&#125;int main()&#123; readData(); initPrefix(); dp(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC017E】Jigsaw]]></title>
    <url>%2F2018%2F10%2F18%2Fagc017e_Jigsaw%2F</url>
    <content type="text"><![CDATA[Description 题意略 Solution 显然每一块拼图的右边能接左边是什么形状的拼图、左边能被右边是什么形状的拼图接都是固定的。题目要求我们找到一个合法拼接方式，我们很容易就可以想到转化成图论问题 我们把拼图看成一条有向边$(u,v)$，把边连接的两个点$u,v$看做这个拼图的两个特征。具体来说： 如果左边凌空，凌空高度为$h$，则$u=-h$；否则记左边的高度为$h$，则$u=h$ 如果右边凌空，凌空高度为$h$，则$v=h$；否则记右边的高度为$h$，则$u=-h$ 确定完$u,v$后，我们连接一条有向边$(u,v)$ 可以发现，合法方案是由若干段组成，每一段的两个端点分别满足左边不凌空和右边不凌空。转化到图上后，每个合法方案相当于若干条以$s(s&gt;0)$为起点、以$t(t&lt;0)$为终点的路径，满足每条边属于且仅属于一条路径 直接构造很难，我们的算法也很难写出构造的形式，因此，我们要换个思路。既然题目只要求我们判定合法解的存在性，我们就不要花太多思想在构造合法解上，应该用图论性质判定：这张图是否支持拆分为若干条合法路径？ 反向考虑，如果整张图有解，那么它一定是由若干条合法路径叠加而成的。这样的图有什么性质呢？对于一条路径而言，它会给中途的每个点的出入度都+1，给起点的出度+1，给终点的入度-1。起点和终点会造成出入度的差距，因此： 对于编号为正的点，其入度不得超过出度，否则它一定是某一些路径的终点，然而这是不合法的 对于编号为负的点，其出度不得超过入度，否则它一定是某一些路径的起点，然而这是不合法的 一个点不能又作为某一些路径的起点又作为某一些路径的终点。在不作为这两种特殊点的情况下，它只能作为某一些路径的中间点 可是这样还没完，满足这两个条件的图不一定有解，因为图中可能出现一些环。它们虽然满足条件，可是根本走不出一条路径。为此，我们要额外规定一个条件： 对于一个非单点弱联通块，其必须包含至少一个点，满足出入度不相等 由于所有点满足出入度相等的图一定是闭合环组成的森林，因此只要保证这个性质，所有环都会有一些小尾巴，这使得外界的路径可以接入环内部，并总能恰好用完环上的所有边 Summary 图论路径构造题，可以通过出入度的性质保证来判断 判定解存在性问题，有时候直接去考虑解的性质而不是考虑如何构造合法解，会更优效率 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define NIE &#123;puts("NO"); exit(0);&#125;using namespace std;const int N=410;int n,m;int outDeg[N],inDeg[N];bool link[N][N];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*N*2];inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;// printf("%d %d\n",u,v);&#125;void getPair(int &amp;u,int &amp;v,int lw,int lh,int rw,int rh)&#123; u=(!lh)?lw:-lh; v=(!rh)?-rw:rh;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int lw,rw,lh,rh,u,v; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d%d",&amp;lw,&amp;rw,&amp;lh,&amp;rh); getPair(u,v,lw,lh,rw,rh); u+=m; v+=m; outDeg[u]++; inDeg[v]++; if(u&gt;v) swap(u,v); link[u][v]=true; &#125;&#125;bool checkDegree()&#123; for(int i=0;i&lt;=2*m;i++) if(i&lt;m)&#123; if(inDeg[i]&lt;outDeg[i]) return false; &#125; else if(i&gt;m)&#123; if(inDeg[i]&gt;outDeg[i]) return false; &#125; return true;&#125;void buildGraph()&#123; for(int i=0;i&lt;2*m;i++) for(int j=i+1;j&lt;=2*m;j++) if(link[i][j]) addEdge(i,j);&#125;bool have;bool vis[N];void checkDfs(int u)&#123; vis[u]=true; if(inDeg[u]!=outDeg[u]) have=true; for(int i=h[u],v;i;i=e[i].next) if(!vis[v=e[i].v]) checkDfs(v);&#125;bool checkDif()&#123; for(int i=0;i&lt;=2*m;i++) if(i!=m&amp;&amp;!vis[i]&amp;&amp;(inDeg[i]||outDeg[i]))&#123; have=false; checkDfs(i); if(!have) return false; &#125; return true;&#125;int main()&#123; readData(); if(!checkDegree()) NIE; buildGraph(); if(!checkDif()) NIE; puts("YES"); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4448】情报传递]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%83%85%E6%8A%A5%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[Description 给一棵树。每个点有点权，初始全为0 每一时刻可以做两种操作中的某一种： 激活某一个点。被激活的点在之后的每一时刻开始时都会+1 在当前时刻的末尾，询问树上一条路径上有多少点，以及有多少点的点权超过了输入的$c$ $n,q \le 2*10^5$ Solution正解 查询的东西与点权有关，立刻要想到建权值线段树 查询的形式是一条路径，可以拆分为两条到根路径。如何维护到根路径上的权值线段树呢？直接用继承父亲的主席树实现即可 复杂度仅一个$\log$ 乱搞 如果在第$t$时刻有一个参数为$c$的询问，这等价于在$t-c$时刻询问这个时刻之前（不包含当前时刻）加入了多少点 离线排个序后，使用树剖，支持路径查询点权和、单点+1两种操作即可 复杂度两个$\log$，实测还挺快…… Summary 树上路径相关的问题，除了树剖，离线且不带修改时，还可以使用继承父亲形式的主席树。这样一条路径可以拆分为两条到根路径，直接前缀和一减就能得到路径的权值信息，这种做法说不定会比树剖优秀一个$\log$，还能支持更灵活的权值相关的查询 Code 场上写的乱搞 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;namespace IO&#123; const int L=30000000; char inBuf[L]; int inPos; void load()&#123; fread(inBuf,1,L,stdin); inPos=0; &#125; char getChar()&#123; return inBuf[inPos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int N=200010;int n,m;int root;int h[N],tot;struct Edge&#123; int v,next;&#125;e[N];int pre[N],dep[N],size[N],son[N];int locCnt,loc[N],who[N],top[N];struct Query&#123; int opt; // 1:query 2:start int t; int x,y;&#125;q[N];int qcnt;bool hasStart[N];bool isQuery[N];int ans[N][2];void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot;&#125;void readData()&#123; n=getInt(); for(int u=1,fa;u&lt;=n;u++)&#123; fa=getInt(); if(fa) addEdge(fa,u); else root=u; &#125;&#125;void dissectionDfs1(int u,int fa)&#123; pre[u]=fa; dep[u]=dep[fa]+1; size[u]=1; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; dissectionDfs1(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dissectionDfs2(int u,int _top)&#123; top[u]=_top; locCnt++; loc[u]=locCnt; who[locCnt]=u; if(!son[u]) return; dissectionDfs2(son[u],top[u]); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=son[u]) dissectionDfs2(v,v);&#125;void Dissection()&#123; dissectionDfs1(root,0); dissectionDfs2(root,root);&#125;namespace SEG&#123; const int S=N*2; int rt,sz; int ch[S][2]; int sum[S]; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; void modify(int u,int l,int r,int p)&#123; sum[u]++; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid) modify(ch[u][0],l,mid,p); else modify(ch[u][1],mid+1,r,p); &#125; int query(int u,int l,int r,int ql,int qr)&#123; if(ql&lt;=l&amp;&amp;r&lt;=qr) return sum[u]; int mid=(l+r)&gt;&gt;1; if(qr&lt;=mid) return query(ch[u][0],l,mid,ql,qr); else if(mid&lt;ql) return query(ch[u][1],mid+1,r,ql,qr); else return query(ch[u][0],l,mid,ql,mid)+ query(ch[u][1],mid+1,r,mid+1,qr); &#125;&#125;void buildSeg()&#123; SEG::build(SEG::rt,1,n);&#125;bool cmpByTime(const Query &amp;a,const Query &amp;b)&#123; if(a.t!=b.t) return a.t&lt;b.t; return a.opt&gt;b.opt;&#125;void addPoint(int u)&#123; SEG::modify(SEG::rt,1,n,loc[u]);&#125;int getLCA(int a,int b)&#123; for(;top[a]!=top[b];dep[top[a]]&gt;dep[top[b]]?a=pre[top[a]]:b=pre[top[b]]); return dep[a]&lt;dep[b]?a:b;&#125;int getPointCnt(int a,int b,int lca)&#123; return dep[a]+dep[b]-2*dep[lca]+1;&#125;void query(int id,int a,int b)&#123; int lca=getLCA(a,b); ans[id][0]=getPointCnt(a,b,lca); int res=0; for(;dep[top[a]]&gt;=dep[lca];a=pre[top[a]]) res+=SEG::query(SEG::rt,1,n,loc[top[a]],loc[a]); if(dep[a]&gt;=dep[lca]) res+=SEG::query(SEG::rt,1,n,loc[lca],loc[a]); // (lca,b] for(;dep[top[b]]&gt;dep[lca];b=pre[top[b]]) res+=SEG::query(SEG::rt,1,n,loc[top[b]],loc[b]); if(dep[b]&gt;dep[lca]) res+=SEG::query(SEG::rt,1,n,loc[lca]+1,loc[b]); ans[id][1]=res;&#125;void answerQuery()&#123; int opt,x,y,c; m=getInt(); for(int i=1;i&lt;=m;i++)&#123; opt=getInt(); if(opt==1)&#123; x=getInt(); y=getInt(); c=getInt(); q[++qcnt]=(Query)&#123;i,i-c,x,y&#125;; isQuery[i]=true; &#125; else&#123; x=getInt(); if(!hasStart[x])&#123; q[++qcnt]=(Query)&#123;0,i,x,0&#125;; hasStart[x]=true; &#125; &#125; &#125; sort(q+1,q+1+qcnt,cmpByTime); for(int i=1;i&lt;=m;i++) if(q[i].opt) query(q[i].opt,q[i].x,q[i].y); else addPoint(q[i].x); for(int i=1;i&lt;=m;i++) if(isQuery[i]) printf("%d %d\n",ans[i][0],ans[i][1]);&#125;int main()&#123; IO::load(); readData(); Dissection(); buildSeg(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数据结构---主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC066E】Addition and Subtraction Hard]]></title>
    <url>%2F2018%2F10%2F18%2Farc066e_Addition%20and%20Subtraction%20Hard%2F</url>
    <content type="text"><![CDATA[Description 给一个只有整数、加减号的表达式，现在可以添加任意多对括号，请输出表达式结果的最大值 整数个数$n \le 10^5$ Solution做法1：DP 先考虑最外层括号的行为模式 左括号前面的运算符决定了括号内部运算符是否反转，因此显然左括号打在一个加号后面没有任何用处 考虑相应的右括号打在哪里：如果将原表达式按减号断开并分段，我们的表达式就会变成 S_1-S_2-S_3-...-S_k 其中，$S_i$的内部是若干个加号连接的数 左括号打在某一个$S_i$之前，则右括号的位置一定是某一个$S_j(j&gt;i)$的最开始的元素的后面，因为将右括号继续右移一定会将原本是正贡献的数变负，造成不会更优的局面 于是我们的第一层括号的形式就是 -(S_i-S_{i+1}-...-S_{j}[1,1])+S_j[2,\mid S_j\mid]-... 由于这个括号整体计算完后是负贡献，显然我们应该要使括号内部的结果尽可能小。一个很显然的策略就是把中间的每个$S$都用括号括起来。不难发现，这就是在确定完最外层括号后，内部的最优策略： -(S_i-(S_{i+1})-...-(S_{j}[1,1]))+S_j[2,\mid S_j\mid]-... 因此全局中，括号我们只需要考虑最多两层即可 一个数对最终答案的贡献相对于原来的翻转次数，等于它所在的括号层数 由于层数很小，我们可以直接使用线性DP：设$f_{i,j}$表示对于$1\dots i$的数字，当左边有$j$个未关闭的左括号时，当前表达式的最大值是多少。设当前第$i$个数带上其前边的符号后为$x$，则有转移： f_{i,j}=f_{i-1,j}+x*(-1)^j 如果当前数是负数，我们在考虑完当前数之后，在当前数前边尝试加一个左括号（加不加对当前数的决策没有影响），则 f_{i,2}=\max\{f_{i,1},f_{i,2}\}\\ f_{i,1}=\max\{f_{i,0},f_{i,1}\}\\ 还可以考虑关闭一个括号： f_{i,0}=\max\{f_{i,0},f_{i,1}\}\\ f_{i,1}=\max\{f_{i,1},f_{i,2}\} 注意转移顺序；第一维可省略 做法2：贪心 确定一个外层括号后，从左到右第一段$S$会变成对全局的负贡献，对于之后的减号隔开的元素，我们总可以通过适当操作，将他们变成对全局的正贡献 这个过程等价于以第一段的变化为代价，将后边每一段的开头元素（也就是前面是减号）对全局的贡献由负变正 我们枚举每个段作为起始段，由于花一次代价就可以无限制地优化后方，我们不妨将整个后面括起来即可，这样可以使更多的负贡献变为正贡献。 Summary 除了时间不够，场上卡着的主要原因是尝试整一段转移，即枚举最外层大括号、计算内层最优值来跳着转移 事实上，遇到此类题目，大转移实现较困难，但如果观察到大转移的本质等价于逐一枚举每个元素，用当前大转移自身的条件确定内部元素贡献，条件允许情况下，我们可以尝试在状态中记录大转移提供的条件（形如”有多少个打开的左括号“这样的信息），逐个元素转移即可，这样实现的难度会大大降低 简化操作：有时候看起来可以干的事情很多，但实际上真正有用的步骤可能是某些形式十分简单的方案，所有复杂的方案都不会比其更优 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;using namespace std;typedef long long LL;const LL LINF=1ll&lt;&lt;60;int n;int getInt()&#123; int x=0,f=1; char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;LL f[3];inline LL max(LL x,LL y)&#123; return x&gt;y?x:y;&#125;int main()&#123; int x; scanf("%d",&amp;n); f[1]=f[2]=-LINF; for(int i=1;i&lt;=n;i++)&#123; x=getInt(); f[0]+=x; f[1]-=x; f[2]+=x; if(x&lt;0)&#123; f[2]=max(f[2],f[1]); f[1]=max(f[1],f[0]); &#125; f[0]=max(f[0],f[1]); f[1]=max(f[1],f[2]); &#125; printf("%lld\n",f[0]); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>思考题</tag>
        <tag>可做未做</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC101F】Robots and Exits]]></title>
    <url>%2F2018%2F10%2F16%2Farc101f_RobotExit%2F</url>
    <content type="text"><![CDATA[Description 数轴上的整点有若干个启动的机器人，还有若干个出口，它们互不重叠 每次你可以命令所有启动的机器人向左走或者向右走，当一个机器人走到出口时会停机，不再接受指令。 当所有机器人停止时，游戏结束 问结束后，机器人的停机位置有多少种局面 Solution 除去只有一种出口可能的机器人——它们对局面无贡献。我们只考虑那些左右都存在出口的机器人，显然它们只能从左边最近的出口和右边最近的出口两种选择 对于操作序列，记向左-1，向右+1。考虑一个机器人，其决策状态只和历史最小值和历史最大值有关，且它的最终出口是谁只和历史最小值的绝对值和历史最大值谁先不小于它与左出口的距离和它与右出口的距离 对于一个与左出口距离为$a$，与右出口距离为$b$的机器人，我们在一个二维平面上用一个点$(a,b)$表示。如果将历史最小值和历史最大值刻画出来，我们相当于从原点$(0,0)$引出一条折线，每次它可以向上或向右走一个单位，若其先到达某一个点$(a,b)$的$y=b$这条直线，则相当于令该点对应的机器人的结果为右出口；相应的，如果先碰到$x=a$，则令该点对应的机器人的结果为左出口。且我们发现，折线不可能同时满足两种情况 我们已经成功地转化了问题。现在，我们只需要统计：对于一条只能向上或向右走的折线，它的下方的点有多少种情况，就能统计局面个数，因为折线下方的点的局面唯一对应了全局的一个局面 运用最小表示法的思想，对于同一种局面，我们仅在折线紧贴在下方的点的情况时才将该局面计入答案，即一条折线令该点$(a,b)$从右出口走出（在直线下方），当且仅当该直线经过了关键点$(a-1,b)$ 设$f_i$表示：折线的末端在$i$的关键点，且下一步即将向右走时，方案数有多少。加上后面的限制是为了防止在同一个$x$坐标上多次决策造成重复统计。转移显然是直接统计$i$的关键点的左下方的关键点的$f$的和 由于关键点相当于在原图上整体向左移动了一格，我们完全可以在原来的点上跑DP，这样还可以省去一些特判 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;const int INF=1e9;const int MOD=1e9+7;int n,m;int a[N],b[N];struct Point&#123; int x,y; friend bool operator == (const Point &amp;a,const Point &amp;b)&#123; return a.x==b.x&amp;&amp;a.y==b.y; &#125;&#125;p[N];int d[N],dcnt;int f[N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;b[i]);&#125;void initDis()&#123; int cnt=1; p[1]=(Point)&#123;0,0&#125;; for(int i=1,j;i&lt;=n;i++)&#123; j=upper_bound(b+1,b+1+m,a[i])-b; if(1&lt;j&amp;&amp;j&lt;=m) p[++cnt]=(Point)&#123;a[i]-b[j-1],b[j]-a[i]&#125;; &#125; p[++cnt]=(Point)&#123;INF,INF&#125;; n=cnt;&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++) d[++dcnt]=p[i].y; sort(d+1,d+1+dcnt); dcnt=unique(d+1,d+1+dcnt)-d-1; for(int i=1;i&lt;=n;i++) p[i].y=lower_bound(d+1,d+1+dcnt,p[i].y)-d;&#125;namespace BIT&#123; int n; int a[N]; void setup(int _n)&#123; n=_n; &#125; void add(int u,int x)&#123; for(;u&amp;&amp;u&lt;=n;u+=u&amp;-u) (a[u]+=x)%=MOD; &#125; int que(int u)&#123; int res=0; for(;u;u-=u&amp;-u) (res+=a[u])%=MOD; return res; &#125;&#125;bool cmpByX(const Point &amp;a,const Point &amp;b)&#123; if(a.x!=b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;void solve()&#123; sort(p+1,p+1+n,cmpByX); n=unique(p+1,p+1+n)-p-1; BIT::setup(dcnt); BIT::add(p[1].y,1); for(int i=2,j;i&lt;=n;i=j)&#123; for(j=i;j&lt;=n&amp;&amp;p[j].x==p[i].x;j++); for(int k=i;k&lt;j;k++) f[k]=BIT::que(p[k].y-1); for(int k=i;k&lt;j;k++) BIT::add(p[k].y,f[k]); &#125; printf("%d\n",f[n]);&#125;int main()&#123; readData(); initDis(); Diz(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>转化</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4940】这是我自己的发明]]></title>
    <url>%2F2018%2F10%2F16%2F%5BBZOJ4940%5D%E8%BF%99%E6%98%AF%E6%88%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8F%91%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Description 给一棵$n$个节点的有根树，初始时根为1号节点。此外，每个节点还有一个颜色$a$ 要求你支持共$m$次下列两种操作： 换根 给出$u,v$，对于$u$的子树$Su$和$v$的子树$S_v$，统计$\sum{a\in Su}\sum{b\in S_v}[a_u==b_v]$ $n \le 10^5,\ m \le 5*10^5$ Solution 如果尝试在模拟的思路上优化，应该尽早停止，因为这样几乎是一个不可做形式：统计的过程形如两个向量的点积，无法快速搞定 首先，由于询问是子树的形式，很容易想到先将dfn序列拉出来，这样每个子树就是dfn序列上的一个区间 以下过程先不考虑换根操作 区间、离线、直接统计不可做，考虑到最后一个特征，我们想一下莫队 我们拿着两个区间在序列上移动，用两个数组分别记录每一个区间内每一种颜色的元素数量。某一个区间新加入一个元素时，在该区间的数组的相应位置上+1，并令当前总答案加上另一个区间的数组的该颜色的值；删除一个元素的做法同理。这样的依据，其实就是统计式的展开 现在，我们已经可以实现$O(1)$加减元素；想要回答某个询问，只需要把两个区间分别移到对应的两个子树区间即可。然而，我们带着两个区间在上面跑却不是莫队的形式，没有复杂度保证 假设我们要计算$A(l1,r1,l2,r2)=[l1,r1]\otimes[l2,r2]$。运用差分思想，我们可以将询问拆分成 \begin{aligned} A(l_1,r_1,l_2,r_2)&=A(1,r_1,1,r_2)-A(1,r_1,1,l_2-1)-A(1,l_1-1,1,r_2)+A(1,l_1-1,1,l_2-1)\\ &=B(r_1,r_2)-B(r_1,l_2-1)-B(l_1-1,r_2)+B(l_1-1,r_1-1) \end{aligned} 我们发现，$B(x,y)$的参数只有两个，代表着求$[1,x]\otimes [1,y]$的答案。虽然这玩意不是一个区间，但是有了上述$O(1)$加减元素的保证，我们也能套用莫队直接计算 这样我们就可以较快地离线回答每一个询问了 现在，加上换根操作，问题有什么变化？大致思想是完全一致的，只不过考虑上换根操作后，一个子树的区间在dfn序列上可能是全集挖掉一段，意味着回答某一个询问时，某一个人的参与运算的元素不一定只有一个区间，可能还有两个。我们只需要分类讨论，将一个询问运用差分思想拆分成多个询问即可，探究后可以发现，最坏情况下一个询问会被拆成9个区间，也就是总询问至多有450w个 事实告诉我们莫队还是可以跑出来的 。。。。。。 Summary 离线、类区间、直接统计不可做$\rightarrow$上莫队 询问太复杂，使用差分可以用效率换来简单 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;namespace IO&#123; const int LEN=10000000; char inBuf[LEN],outBuf[LEN]; int inPos,outPos; void load()&#123; fread(inBuf,1,LEN,stdin); inPos=0; &#125; void flush()&#123; fwrite(outBuf,1,outPos,stdout); &#125; char getChar()&#123; return inBuf[inPos++]; &#125; void writeChar(char c)&#123; outBuf[outPos++]=c; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeInt(ll x,char endc='\n')&#123; static int sta[20],top; if(!x) writeChar('0'); else&#123; for(top=0;x;x/=10) sta[++top]=x%10; for(;top;top--) writeChar('0'+sta[top]); &#125; writeChar(endc); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=100010,M=500010;const int B=300;int n,m;int col[N];int dcnt,d[N];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];int pre[N][17],dep[N];int dfnTimer,dfn[N][2],dfnList[N];int inputQueryCnt;struct Query&#123; int x,y; int id,co; // belong/coe&#125;q[M*10];int qcnt;ll ans[M];void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; n=getInt(); m=getInt(); for(int i=1;i&lt;=n;i++) col[i]=getInt(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=getInt(); v=getInt(); addEdge(u,v); &#125;&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++) d[i]=col[i]; sort(d+1,d+1+n); dcnt=unique(d+1,d+1+n)-d-1; for(int i=1;i&lt;=n;i++) col[i]=lower_bound(d+1,d+1+dcnt,col[i])-d;&#125;void preDfs(int u,int fa)&#123; pre[u][0]=fa; for(int i=1;i&lt;=16;i++) pre[u][i]=pre[pre[u][i-1]][i-1]; dep[u]=dep[fa]+1; dfn[u][0]=++dfnTimer; dfnList[dfnTimer]=u; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) preDfs(v,u); dfn[u][1]=dfnTimer;&#125;int curRoot;int getWhichSon(int anc,int u)&#123; for(int i=16;i&gt;=0;i--) if(dep[pre[u][i]]&gt;dep[anc]) u=pre[u][i]; return u;&#125;void generate(int id,int co,int l1,int r1,int l2,int r2)&#123; if(l1&gt;r1||l2&gt;r2) return; q[++qcnt]=(Query)&#123;r1,r2,id,co&#125;; if(l1-1) q[++qcnt]=(Query)&#123;l1-1,r2,id,-co&#125;; if(l2-1) q[++qcnt]=(Query)&#123;r1,l2-1,id,-co&#125;; if(l1-1&amp;&amp;l2-1) q[++qcnt]=(Query)&#123;l1-1,l2-1,id,co&#125;;&#125;int getType(int u)&#123; // isRoot:0 inSubtree:1 out:2 if(u==curRoot) return 0; else if(dfn[u][0]&lt;dfn[curRoot][0]&amp;&amp;dfn[curRoot][0]&lt;=dfn[u][1]) return 1; return 2;&#125;void takeApart(int id,int a,int b)&#123; int ta=getType(a),tb=getType(b); if(ta&gt;tb)&#123; swap(a,b); swap(ta,tb); &#125; int la,lb; if(ta==1) la=getWhichSon(a,curRoot); if(tb==1) lb=getWhichSon(b,curRoot); if(ta==0)&#123; if(tb==0) generate(id,1,1,n,1,n); else if(tb==1)&#123; generate(id,1,1,n,1,dfn[lb][0]-1); generate(id,1,1,n,dfn[lb][1]+1,n); &#125; else generate(id,1,1,n,dfn[b][0],dfn[b][1]); &#125; else if(ta==1)&#123; if(tb==1)&#123; generate(id,1,1,dfn[la][0]-1,1,dfn[lb][0]-1); generate(id,1,dfn[la][1]+1,n,1,dfn[lb][0]-1); generate(id,1,1,dfn[la][0]-1,dfn[lb][1]+1,n); generate(id,1,dfn[la][1]+1,n,dfn[lb][1]+1,n); &#125; else&#123; generate(id,1,1,n,dfn[b][0],dfn[b][1]); generate(id,-1,dfn[la][0],dfn[la][1],dfn[b][0],dfn[b][1]); &#125; &#125; else generate(id,1,dfn[a][0],dfn[a][1],dfn[b][0],dfn[b][1]);&#125;void initQuery()&#123; int opt,x,y; curRoot=1; for(int i=1;i&lt;=m;i++)&#123; opt=getInt(); if(opt==1) curRoot=getInt(); else&#123; inputQueryCnt++; x=getInt(); y=getInt(); takeApart(inputQueryCnt,x,y); &#125; &#125;&#125;ll curSum=0;bool cmpMo(const Query &amp;a,const Query &amp;b)&#123; if(a.x/B!=b.x/B) return a.x/B&lt;b.x/B; return a.y&lt;b.y;&#125;void add(int p,int x,int *a,int *b)&#123; int c=col[dfnList[p]]; a[c]+=x; curSum+=1ll*x*b[c];&#125;void MoQueue()&#123; sort(q+1,q+1+qcnt,cmpMo); int l=0,r=0; static int ta[N],tb[N]; for(int i=1;i&lt;=qcnt;i++)&#123; while(l&lt;q[i].x) add(++l,1,ta,tb); while(l&gt;q[i].x) add(l--,-1,ta,tb); while(r&lt;q[i].y) add(++r,1,tb,ta); while(r&gt;q[i].y) add(r--,-1,tb,ta); ans[q[i].id]+=1ll*q[i].co*curSum; &#125;&#125;void print()&#123; for(int i=1;i&lt;=inputQueryCnt;i++) writeInt(ans[i]);&#125;int main()&#123; IO::load(); readData(); Diz(); preDfs(1,0); initQuery(); MoQueue(); print(); IO::flush(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>可做未做</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC076E】Connect]]></title>
    <url>%2F2018%2F10%2F16%2Farc076e_Connect%2F</url>
    <content type="text"><![CDATA[Description 在$(R+1)\times (C+1)$的网格上，一共有$N$种颜色。网格的格子有的有颜色，有的没有颜色。 对于每种颜色，都存在恰好两个格子涂着该色 现在要将每一对相同颜色的格子用一条极细的曲线连接，要求连接每一对格子的曲线不得相交 求是否存在方案？ $1 \le R,C \le 10^8$，$1 \le N \le 10^5$， $0 \le x \le R,\ 0\le y \le C$ Solution 看场上翻译的题面丝毫没有理解连的线是“任意弯曲、无限细的曲线段”，而认为这些线都要走格子。再者，我看完题后居然没有看样例，要是看了样例或许就能理解回来…… 考虑到连的线是一条理想的曲线，如果我们将每种颜色的曲线逐一加入，我们会发现：对于至少有一端不在边界上的曲线，要想调整之前的方案使得它能成功被加入，我们只需要把先前的方案不断扭曲、压缩，直到撇开一条可见的空路，使得我们能直接连线即可；对于两端都在边界上的曲线，它也能通过上述方式，调整先前加入的、不是两端都在边界上的曲线，但是，对于后者，我们没有调整的余地，因为它们连接着边界，无论怎样扭曲这些曲线，都改变不了拓扑序。 于是显然，局面存在合法解，当且仅当所有两端都在边界的曲线能够不相交地存在。这很像上色的括号序列，我们只需要在边界上顺时针走一圈，判定带颜色的括号序列是否合法即可 Summary 不管题有多毒瘤，请坚持看完样例，或许你觉得题毒瘤是因为你看错概念了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define PB push_backusing namespace std;const int N=100010;int r,c,n;struct Point&#123; int x,y,id;&#125;;vector&lt;Point&gt; e[4];int getType(int x,int y)&#123; if(!x) return 0; else if(y==c) return 1; else if(x==r) return 2; return 3;&#125;void readData()&#123; scanf("%d%d%d",&amp;r,&amp;c,&amp;n); int x1,y1,x2,y2; for(int i=1;i&lt;=n;i++)&#123; scanf("%d%d%d%d",&amp;x1,&amp;y1,&amp;x2,&amp;y2); if(((x1==0||x1==r)||(y1==0||y1==c))&amp;&amp;((x2==0||x2==r)||(y2==0||y2==c)))&#123; e[getType(x1,y1)].PB((Point)&#123;x1,y1,i&#125;); e[getType(x2,y2)].PB((Point)&#123;x2,y2,i&#125;); &#125; &#125;&#125;int sta[N],top;bool cmpXBig(const Point &amp;a,const Point &amp;b)&#123; return a.x&lt;b.x;&#125;bool cmpXSmall(const Point &amp;a,const Point &amp;b)&#123; return a.x&gt;b.x;&#125;bool cmpYBig(const Point &amp;a,const Point &amp;b)&#123; return a.y&lt;b.y;&#125;bool cmpYSmall(const Point &amp;a,const Point &amp;b)&#123; return a.y&gt;b.y;&#125;bool solve()&#123; sort(e[0].begin(),e[0].end(),cmpYBig); sort(e[1].begin(),e[1].end(),cmpXBig); sort(e[2].begin(),e[2].end(),cmpYSmall); sort(e[3].begin(),e[3].end(),cmpXSmall); static int sta[N],top=0,cnt[N]; for(int k=0;k&lt;4;k++)&#123; for(int i=0,sz=e[k].size();i&lt;sz;i++)&#123; int c=e[k][i].id; if(cnt[c]==0)&#123; sta[++top]=c; cnt[c]=1; &#125; else&#123; if(sta[top]!=c) return false; top--; &#125; &#125; &#125; return true;&#125;int main()&#123; readData(); puts(solve()?"YES":"NO"); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>可做未做</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC004C】AND Grid]]></title>
    <url>%2F2018%2F10%2F16%2Fagc004c_AndGrid%2F</url>
    <content type="text"><![CDATA[Description 给一个$n\times m$的网格，每个格子都是#或者一个点$.$ 请你构造出另外两张$n\times m$的网格，满足： 原网格上有#的位置，另外两张的相应位置都必须要有 原网格上没有#的位置，另外两张的相应位置不能都有 两张新网格的#构成恰好一个连通块 我们保证原网格的边界没有# 请输出一个合法方案 $3 \le n,m \le 500$ Solution 注意到题目保证的性质——原网格的最外围一圈都是空的。既然这么特别地提出来了，肯定要利用这个性质带来的机会 原来想的是：一张图填满最外边一圈，然后每个#在填完自己后，向最近的边界一直拉；另一张图就填满剩下的部位。这样的做法的保证是第一张图的填法不可以切割整张图，然而实际上这种情况的确会发生。 难道又要什么费用流？这个“安排走线”的做法太过玄学，考虑一种人为规定的、有规律的填法 既然要求所有#构成一个连通块，我们像第一个思路一样，尝试先把所有#连到一个中枢一样的存在。中枢放在地图中间肯定很难想，我们不妨题目给出的性质，将最左一列作为第一张图的中枢，最右一列作为第二张图的中枢 剩下的问题就是，怎么在不重复使用某一个格的情况下，将每个#在两张图中都连到最左一列和最右一列。最直接的想法就是对于每一个#，在一张图向左一直连，在另一张图向右一直连，但这样会冲突。一种巧妙的做法是，第一张图将奇数行填满，第二张图将偶数行填满（除了最左和最右两列）。可以发现，在这种涂色方案下，每个#要么通过同一行到达中枢，要么通过上边或者下边与它贴着的一行到达中枢，即每张图的每个元素都是连通的，因此这是一种合法方案 Summary 对于构造题，决策太多、感觉要考虑的东西很多、想法太杂，不妨往某些有规律的、形式简单的方案上想 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;using namespace std;const int N=510;int n,m;char a[N][N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%s",a[i]+1);&#125;void print()&#123; for(int i=1;i&lt;=n;i++,puts(""))&#123; putchar('#'); for(int j=2;j&lt;m;j++) if(a[i][j]=='#') putchar('#'); else putchar((i&amp;1)?'#':'.'); putchar('.'); &#125; puts(""); for(int i=1;i&lt;=n;i++,puts(""))&#123; putchar('.'); for(int j=2;j&lt;m;j++) if(a[i][j]=='#') putchar('#'); else putchar(!(i&amp;1)?'#':'.'); putchar('#'); &#125;&#125;int main()&#123; readData(); print(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>可做未做</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[表达式求值]]></title>
    <url>%2F2018%2F10%2F15%2F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%2F</url>
    <content type="text"><![CDATA[模型描述 给定一个由一下元素构成的表达式： 数字或变量 具有规定优先级的若干种运算符 括号 规定： 优先计算括号内部的内容 其次，优先计算优先级更高的运算符 现在，请求解整个表达式的值。 后缀表达式 上述提到的表达式属于中序表达式，其简洁美观，利于阅读和计算，却不利于计算机的模拟，可想而知计算一个中序表达式的模拟过程有多繁琐 但是如果我们能够将该中序表达式转化为等价的后缀表达式，其计算过程在实现难度上将大大降低。转化之后，各种运算符与括号之间的优先级都暗暗体现在后缀表达式中，计算起来极为方便，只需要一个栈进行线性模拟即可 现在，考虑将一个中序表达式转化为等价的后缀表达式 转化 整体过程可以如下描述，其中使用了一个栈$S$用以记录运算符与左括号： 从左到右枚举中序表达式的每一个元素： 若该元素是一个数字或变量，我们直接将其添加到当前后缀表达式的末尾 若该元素是一个括号： 如果是左括号：我们将其压入$S$中 如果是右括号：我们不断将$S$栈顶的运算符弹出，并将其添加到后缀表达式的末尾，直到弹出一个左括号为止。特别地，我们不将左括号添加进后缀表达式中 若该元素是一个运算符： 若栈$S$为空，或当前运算符的优先级高于$S$栈顶运算符，或栈顶为左括号，则直接将该运算符压入$S$中 否则，将栈顶运算符弹出，并将其添加到后缀表达式的末尾。重复此步骤直到3.1满足为止，并执行3.1 至此，我们在$O(n)$的时间内，将一个中序表达式转化为了一个与其等价的后缀表达式。接下来的后缀表达式求解过程十分简单，在此不再详述]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>表达式求值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隔热板]]></title>
    <url>%2F2018%2F10%2F15%2F%E9%9A%94%E7%83%AD%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[Description $1 \le n \le 40000$ Solution 看到题直接往二分答案上想 我们二分答案$r$，则每一条直线与原点的距离不得小于$r$。这等价于以原点为圆心作一个半径为$r$的圆，并保证所有直线与圆不相切 现在我们要判定是否存在一种方案，使得作$m$条直线后，外侧覆盖所有的点 我们观察到一个很显然的贪心：$m$条直线都最好贴在圆上，因为这样期望最优。因此，每一条直线都可以用圆上的某一个切点表示 现在的目标是使得直线外侧覆盖到所有的点。若直接考虑怎么选直线并覆盖到所有点非常困难，没有任何模型可以构建；我们转而考虑每一个点如何才能被覆盖：过这个点作圆的两条切线，观察得到的两个切点，我们发现：这个点能被覆盖，当且仅当有至少一条直线的切点在这两个切点之间 问题转化为：给一个圆，圆上有$n$个线段。你有$m$次机会，每次机会可以在圆上点一个点，并删去（满足）包含它的所有区间。问是否能删去所有区间？ 我们转而考虑最少能用多少步删去所有区间。假设我们固定了开始区间，依照一个经典贪心策略，我们选择该区间的右端点，并将覆盖的区间全部删去，然后找到右边第一个未被删去的区间，重复上述过程。若加上枚举开始区间，直接做的复杂度将为$O(n^2)$；但我们注意到，对于某一个区间，对其进行删右端点的操作后，所谓的下一个区间是固定的。这启示我们用倍增加速判定的过程，即倍增求解最少使用多少步才能删去所有区间。这样单次判定的复杂度就降为了$O(n \log n)$ 实现细节较多： 环上区间问题：对$n$个初始区间排好序后，我们将所有区间复制一份后整体偏移$2\pi$作为另一份存在。这样在倍增的时候就比较好操作 如何找到右边下一个区间：对所有区间按右端点为第一关键字、左端点为第二关键字排序，我们采用双指针直接扫描维护即可。可以证明，第二个指针指向的第一个未被第一个指针指向区间覆盖的区间，一定是必要的、最近的下一个区间 区间涉及到边界突变问题：如果我们需要对区间判定某些性质（如2.），意外的$\pm 2\pi$可能会导致莫名其妙的BUG。因此必须对症下药：如2.，若右端点是合法、有序且无歧义，则左端点也必定是合法有序无歧义的，且满足2.的性质使得判定正确，因此我们应该按右端点整理，以右端点为标杆整理到$[0,2\pi)$内即可 若区间互相包含：若一个大区间包含小区间，我们可以把大区间删去，这样可以减少问题规模并快上好几倍。一个非常隐蔽的问题是：切忌在1.复制区间后，判定包含并删除，这样可能会使得整个序列$a$不满足$ai=a{n+i}$（在区间意义上），从而导致在跳倍增的时候判定终点出现牛头不对马嘴的情况 正确做法应该是在对初始区间排序后，直接删除不必要区间，再复制。这样就能保证前后是一一对应的 Summary 题目要求我们选择某一些方案以满足要求时，如果直接考虑如何选方案才能满足所有要求很难，不妨反过来考虑：对于每一个要求，出现具有什么特征的方案时，自己才能被满足；并通过综合每个要求提供的特征，来构建全局选择方案的模型 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N=40010;const int INF=1e9;const double DINF=1e40;const double PI=acos(-1.0);int n,m;struct Point&#123; int x,y;&#125;;struct Segment&#123; double l,r; void adjust()&#123; while(r&gt;=2*PI) l-=2*PI, r-=2*PI; while(r&lt;0) l+=2*PI, r+=2*PI; &#125; friend bool operator == (const Segment &amp;a,const Segment &amp;b)&#123; return a.l==b.l&amp;&amp;a.r==b.r; &#125; friend bool operator &lt; (const Segment &amp;a,const Segment &amp;b)&#123; return a.r!=b.r?(a.r&lt;b.r):(a.l&lt;b.l); &#125;&#125;;Point p[N*2];Segment s[N*2];int len,cnt;int trans[N*2][18];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i].x,&amp;p[i].y);&#125;double getMinDis()&#123; double res=DINF; for(int i=1;i&lt;=n;i++) res=min(res,sqrt(p[i].x*p[i].x+p[i].y*p[i].y)); return res;&#125;void initSegment(double r)&#123; double dis,alpha,beta; for(int i=1;i&lt;=n;i++)&#123; dis=sqrt(p[i].x*p[i].x+p[i].y*p[i].y); alpha=acos(p[i].x/dis); if(p[i].y&lt;0) alpha=2*PI-alpha; beta=acos(r/dis); s[i]=(Segment)&#123;alpha-beta,alpha+beta&#125;; s[i].adjust(); &#125; sort(s+1,s+1+n); for(int i=1;i&lt;n;i++) if(s[i].l&gt;=s[i+1].l) s[i+1]=s[i]; cnt=unique(s+1,s+1+n)-s-1; len=cnt*2; for(int i=1;i&lt;=cnt;i++)&#123; s[cnt+i]=s[i]; s[cnt+i].l+=2*PI; s[cnt+i].r+=2*PI; &#125; for(int i=0;i&lt;=17;i++) trans[len+1][i]=len+1; for(int i=1,j=1;i&lt;=len;i++)&#123; while(j&lt;=len&amp;&amp;s[j].l&lt;=s[i].r) j++; trans[i][0]=j; &#125; for(int j=1;j&lt;=17;j++) for(int i=1;i&lt;=len;i++) trans[i][j]=trans[trans[i][j-1]][j-1];&#125;int calcStep(double r)&#123; initSegment(r); int res=INF; for(int start=1;start&lt;=cnt;start++)&#123; int u=start,use=1,rest=cnt; for(int i=17;i&gt;=0;i--) if(trans[u][i]&lt;start+cnt&amp;&amp;trans[u][i]-u&lt;rest)&#123; use+=(1&lt;&lt;i); rest-=trans[u][i]-u; u=trans[u][i]; &#125; res=min(res,use); &#125; return res;&#125;void solve()&#123; double l=0,r=getMinDis(),mid; double stopEPS=1e-4; while(l+stopEPS&lt;r)&#123; mid=(l+r)*0.5; if(calcStep(mid)&lt;=m) l=mid; else r=mid; &#125; printf("%.2lf\n",mid);&#125;int main()&#123; readData(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>转化</tag>
        <tag>可做未做</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC100D】Equal Cut]]></title>
    <url>%2F2018%2F10%2F11%2Farc100d_Equal%20Cut%2F</url>
    <content type="text"><![CDATA[Description 给定一个长度为$n$的序列$a_i$，你要将这个序列划分为4段非空的连续子序列 定义一段子序列的权值为其所有元素之和，请最小化这四段子序列的极差 $n \le 2 * 10^5,\ a_i\le 10^9$ Solution 尝试使用二分答案并钦定最小值以限制最大值的套路，但失败。因为我们无法在确认划分方案之前就定下最小值，所以这样根本没有出路 由于段数很少，我们考虑直接枚举三个切点的位置。直接枚举时间复杂度为$O(n^3)$，我们需要更快的枚举方式。更快的方式一般是先确定某一个位置，再在这个位置确定的前提下，快速求解其他位置的最优方案。自然，先确定最左切点或最右切点的做法并不能很好地简化问题；因此，我们考虑枚举中间的切点 设中间切点的位置为$p$，其应该满足$p \in (1,n)$。此时左切点的选择范围是$[1,p)$，右切点的选择范围是$(p,n)$ 考虑如何最小化每一段的和的极差：假设我们确定了左切点的位置，那么我们可以得到两个段序列的和；确定右边后同理。我们可以证明：只要左切点选择的位置使得其产生的两个序列极差最小，且右切点选择的位置使得其产生序列的极差也最小，那么此时全局的4个序列的极差也是最小的 简单证明如下：由于某一边的两个值的和一定，因此如果一个值增大，那么另一个值必定减小；如果我们想让某一边的两个值极差最小，那么它们都会趋向于向和的一半靠拢。如果我们令左右两组数都往各自的中心靠拢以获得各自的最小极差，我们会发现，此时全局的最大值和最小值也会慢慢靠拢，且两组都靠拢时，全局的极差最小。可以发现，其余情况都没有上述情况优 因此我们只需要枚举中间的切点，在其左右各自二分出取最小极差时最大值和最小值，拿两个最大值的最大值减去两个最小值的最小值更新答案即可 时间复杂度$O(n \log n)$ Summary 如果题目的决策步数是一个定值且较小，我们应该从直接枚举的方面入手 如果直接枚举行不通，考虑钦定一个比较关键的步骤的决策，然后用某种方法快速计算出此时做完其他决策后的最优解，并更新答案 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=200010;const ll LINF=1ll&lt;&lt;60;int n;ll s[N];template&lt;class T&gt; void updmin(T &amp;x,T y)&#123; x=(y&lt;x)?y:x;&#125;template&lt;class T&gt; T max(T x,T y)&#123; return x&gt;y?x:y;&#125;template&lt;class T&gt; T min(T x,T y)&#123; return x&lt;y?x:y;&#125;template&lt;class T&gt; T abs(T x)&#123; return x&gt;=0?x:-x;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%lld",&amp;s[i]); s[i]+=s[i-1]; &#125;&#125;void find(int pl,int pr,ll &amp;mn,ll &amp;mx)&#123; int l=pl,r=pr-1,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if((s[mid]-s[pl-1])&gt;=(s[pr]-s[mid])) r=mid-1; else l=mid+1; &#125; ll best=LINF,x,y; x=s[l]-s[pl-1]; y=s[pr]-s[l]; if(abs(x-y)&lt;best)&#123; best=abs(x-y); mn=min(x,y); mx=max(x,y); &#125; if(l&gt;pl)&#123; l--; x=s[l]-s[pl-1]; y=s[pr]-s[l]; if(abs(x-y)&lt;best)&#123; best=abs(x-y); mn=min(x,y); mx=max(x,y); &#125; &#125;&#125;void solve()&#123; ll ans=LINF; ll lmn,lmx,rmn,rmx,cur; for(int p=2;p&lt;n;p++)&#123; find(1,p,lmn,lmx); find(p+1,n,rmn,rmx); cur=max(lmx,rmx)-min(lmn,rmn); updmin(ans,cur); &#125; printf("%lld\n",ans);&#125;int main()&#123; readData(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>思考题</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC101E】Ribbons on Tree]]></title>
    <url>%2F2018%2F10%2F10%2Farc101e_Ribbons%20on%20Tree%2F</url>
    <content type="text"><![CDATA[Description 给定一棵有$n$个节点的树，满足$n$为偶数。初始时，每条边都为白色 现在请你将这些点两两配对成$\frac n2$个无序点对。每个点对之间的的路径都会被染成黑色 求有多少种配对方案，使得树上没有白边？ $n \le 5000$ Solution 直接DP的话，设$f_{u,i}$表示$u$子树内配对完成，有$i$个点向外请求配对。这个的复杂度大概是$O(n^3)$的，因为合并两个子树的地方的复杂度降不下来，必须要枚举完成 于是我们想到了容斥的做法：我们可以枚举一些边，钦定它们不能被染黑，然后统计此时的配对方案数。最后，按枚举的边数的奇偶性确定容斥系数即可 具体地说，记总边集为$E$，我们相当于求： ans=\sum_{T\subseteq E}(-1)^{\mid T \mid}F(T) 其中$F(T)$表示钦定$T$中的边不可以染黑时，全局的配对方案数 考虑单独计算$F(T)$的过程：我们可以视为从原树中将这些边删去，对于剩余的$\mid T \mid +1$个连通块，记其大小分别为$s1,s_2,…,s{\mid T\mid +1}$，则易得： F(T)=\sum_{i=1}^{\mid T\mid +1}g(s_i)\\ g(n)=\begin{cases} (n-1)(n-3)...1 &2\mid n\\ 0 &\text{else} \end{cases} 考虑使用树形DP同步计算出所有的$T$的$F(T)$之和 考虑到中间进行计算的时候很有可能使用两个数相乘得到方案的方式转移，因此我们不能将正负两种情况的数记录在一个值里边，必须分开DP，因此状态中要体现当前已删边条数的奇偶性 同时，DP时我们要考虑是否要划分出一个新的连通块。这意味着我们要记录这个连通块的大小。方便起见，我们记录当前树根$u$所在的连通块大小即可 至此我们得出状态：$f{u,i,0/1}$表示以$u$为根的子树中，$u$所在连通块大小为$i$时，当$u$子树中的所有边组成$E$时，对于0：$\mid T \mid$为偶数；1：$\mid T \mid$为奇数，$\sum{T \subseteq E}F(T)$为多少 考虑DP中合并当前根$u$和新子树$v$的过程，我们枚举$i$和$j$，合并$f{u,i}$与$f{v,j}$： 保留边$(u,v)$：$f{u,i,a} * f{v,j,b}\rightarrow f’_{u,i+j,a\;\text{xor}\;b}$ 删去边$(u,v)$：$f{u,i,a} * f{v,j,b} * g(j) \rightarrow f’_{u,i,a\;\text{xor}\;b\;\text{xor}\;1}$ 注意，我们只在断掉一个连通块的最上面一条边时，才将$g$乘入方案数中（如2.所示）。因为在合并一个连通块的过程中，我们还无法确定其$g$值，除非我们将其闭合 最后，统计$\sumif{1,i,0}g(i)$和$\sum{i} f{1,i,1}g(i)$，就可以得到容斥式子中的正贡献之和，以及负贡献之和的绝对值，直接做减法即可。由于上一段提到的原因，$f_1$贡献进$\sum$时要乘上$g$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=5010;const int MOD=1e9+7;int n;int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];int g[N];int size[N];int f[N][N][2];void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); int u,v; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125;&#125;void init()&#123; g[0]=1; for(int i=2;i&lt;=n;i+=2) g[i]=1ll*g[i-2]*(i-1)%MOD;&#125;void dp_dfs(int u,int fa)&#123; size[u]=1; f[u][1][0]=1; static ll c[N][2]; for(int I=h[u],v;I;I=e[I].next) if((v=e[I].v)!=fa)&#123; dp_dfs(v,u); for(int i=1;i&lt;=size[u]+size[v];i++) c[i][0]=c[i][1]=0; for(int i=1;i&lt;=size[u];i++) for(int j=1;j&lt;=size[v];j++) for(int a=0;a&lt;2;a++) for(int b=0;b&lt;2;b++)&#123; static int t; t=1ll*f[u][i][a]*f[v][j][b]%MOD; c[i+j][a^b]+=t; if(!(j&amp;1)) c[i][a^b^1]+=1ll*t*g[j]%MOD; &#125; size[u]+=size[v]; for(int i=1;i&lt;=size[u];i++)&#123; f[u][i][0]=c[i][0]%MOD; f[u][i][1]=c[i][1]%MOD; &#125; &#125;&#125;int solve()&#123; int sum[2]=&#123;0,0&#125;; for(int i=0;i&lt;=n;i+=2) for(int j=0;j&lt;2;j++) (sum[j]+=1ll*f[1][i][j]*g[i]%MOD)%=MOD; int res=(sum[0]-sum[1])%MOD; return res&lt;0?res+MOD:res;&#125;int main()&#123; readData(); init(); dp_dfs(1,0); printf("%d\n",solve()); return 0;&#125;]]></content>
      <tags>
        <tag>DP---树形DP</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC101D】Median of Medians]]></title>
    <url>%2F2018%2F10%2F10%2Farc101d_Median%20of%20Medians%2F</url>
    <content type="text"><![CDATA[Description 给定一个长度为$n$的序列$a_i$ 将所有连续子序列（共$\frac{n*(n+1)}{2}$个）的中位数组成一个新的序列，求这个序列的中位数 $n \le 10^5,\ a_i\le 10^6$ Solution 如果直接考虑答案中位数是怎么得到的，思路会特别绕，要考虑太多东西 考虑转化中位数的定义：对于一个长度为$n$的序列$a$，其中位数$m$应该满足下列条件： 在序列中，不小于$m$的元素个数不少于$\lceil\frac{n}2\rceil$ $m$要尽可能大 显然，我们已经可以看出这个可二分的形式。考虑二分最终的答案$ans$，判定时，我们相当于在一个长度为$\frac{n*(n+1)}{2}$的序列中，求有多少个元素$\ge ans$；换句话说，我们要求解有多少原序列的连续子序列满足其中位数大于等于$ans$ 考虑转化形如“一个序列的中位数$\ge x$”的条件：记这个序列不小于$x$的元素个数为$a$，其余元素个数为$b$，则对应回来，二者应该满足$a \ge b$ 于是这个问题就变成了一个经典的问题：以区间内黑白点的个数谁多谁少来定义区间的权值。我们令整个序列中$\ge ans$的权值为$1$，其余的权值为$-1$，求解前缀和后，我们可以利用树状数组快速计算区间和大于等于0的区间个数 综上，我们可以在$O(n \log n \log10^6)$的时间内用二分答案解决这个中位数的问题 Summary 如果题目围绕一个传统定义的或者新定义的概念展开，尝试将这个定义转化为多个等价的、更适宜算法解决的约束条件 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;using namespace std;const int N=100010;typedef long long ll;int n;ll subsum;int a[N],maxa;int b[N];inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void readData()&#123; scanf("%d",&amp;n); subsum=1ll*n*(n+1)/2; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); maxa=max(maxa,a[i]); &#125;&#125;namespace BIT&#123; int n; int a[N*2]; void setup(int _n)&#123; n=_n; for(int i=1;i&lt;=n;i++) a[i]=0; &#125; void add(int u,int x=1)&#123; for(;u&amp;&amp;u&lt;=n;u+=u&amp;-u) a[u]+=x; &#125; int que(int u)&#123; int res=0; for(;u;u-=u&amp;-u) res+=a[u]; return res; &#125;&#125;ll calc(int x)&#123; b[0]=0; for(int i=1;i&lt;=n;i++)&#123; b[i]=(a[i]&gt;=x)?1:-1; b[i]+=b[i-1]; &#125; BIT::setup(2*n+1); BIT::add(n+1); ll res=0; for(int i=1;i&lt;=n;i++)&#123; res+=BIT::que(b[i]+(n+1)); BIT::add(b[i]+(n+1)); &#125; return res;&#125;bool judge(int x)&#123; return calc(x)&gt;=((subsum+1)&gt;&gt;1);&#125;int solve()&#123; int l=1,r=maxa,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(judge(mid)) l=mid+1; else r=mid-1; &#125; return r;&#125;int main()&#123; readData(); printf("%d\n",solve()); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>转化</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[选举]]></title>
    <url>%2F2018%2F10%2F10%2F%E9%80%89%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[Description 有一个长度为$n$的序列，权值为-1或1或0 给定$l$和$r$，你将要将序列划分成任意多段长度在$[l,r]$中的区间，使得所有区间的权值之和最大 定义一个区间的权值为：记该区间元素之和为$s$，若$s&gt;0$则为1，若$s&lt;0$则为-1，否则为0 $1 \le n \le 10^6$ Solution 听说一个log可以过而且不卡常。场上我一看100w特别虚，硬是把自己逼出了$O(n)$的做法…… 求出原序列的前缀和$s$后，就可以快速回答任意一段区间$(l,r]$的权值$v(l,r)$ 考虑朴素DP：设$f_i$表示划分序列的前$i$位，以$i$为最后一个区间的结尾时，各区间权值之和最大值是多少 f_i=\max\{f_{i-j}+v(i-j,i)\mid j\in[l,r]\} 至此已经可以给出$O(n \log n)$的算法：我们使用一个以$s$为下标、以$f$值为权值的线段树，记录$j \in[i-r,i-l]$这些位置的$s_j$和$f_j$。对于$s_js_i$的$f$，它们在贡献时减一。因此维护区间最大值就可以加速取$\max$的过程。由于考虑范围是一个滑动窗口，因此我们可以很方便地维护这棵线段树 考虑如何进一步优化 我们称$[i-r,i-l]$为“考虑范围”。如果忽略$v$的存在，那么这题就是一个基本的滑动窗口，用单调队列维护区间最大值。我们使用一个最基本的单调队列维护考虑范围中的$f$最大值 考虑到$v$的取值范围为$[-1,1]$，此时我们观察$fi$的最终取值，记考虑范围中的$f$最大值为$f{max}$，则$f_i$一定由下面两类位置的某一个最大值得来： $f=f_{max}$的位置 $f=f_{max}-1$的位置 这些位置转移时还要考虑上$v$的影响。贪心地想，两类位置肯定都尽可能地想加一，去获得最大值。由于加一的条件是$s_j&lt;s_i$，且$v$满足$s$越小价值越高，我们对于两类位置分别维护的$s$的最小值，就可以知道每一类的位置考虑上$v$后最大的能去多少。转移时，取两类位置的最优者即可 于是我们相当于要对每一个$x$，维护那些满足$f_i=x$的位置$i$的$s_i$，并支持查询区间最小值。这个查询也是一个滑动窗口的形式，我们开$2n+1$个单调队列（$[-n,n]$），直接跟随主单调队列滑动并维护即可，每次滑动，弹出的元素都只有一个，总空间复杂度和时间复杂度都是$O(n)$（我写了个链表模拟队列） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;cstdio&gt;#include &lt;utility&gt;#define mp make_pair#define FR first#define SE secondusing namespace std;typedef pair&lt;int,int&gt; pii;namespace IO&#123; const int S=10000000; char buf[S]; int pos; void load()&#123; fread(buf,1,S,stdin); pos=0; &#125; char getChar()&#123; return buf[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int N=1000010;const int INF=1e9;int n,l,r;int s[N];int f[N];inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void readData()&#123; n=getInt(); l=getInt(); r=getInt(); for(int i=1;i&lt;=n;i++)&#123; s[i]=getInt(); s[i]+=s[i-1]; &#125;&#125;struct Node&#123; pii d; int pre,nex;&#125;d[N*2];int use=0;struct Queue&#123; bool flag; int size; int h,t; void setup(bool ismax)&#123; flag=ismax; size=0; h=0; &#125; void pop_back()&#123; size--; int pn=d[t].pre; if(pn)&#123; d[pn].nex=0; t=pn; &#125; else h=t=0; &#125; void pop_front()&#123; size--; int nn=d[h].nex; if(nn)&#123; d[nn].pre=0; h=nn; &#125; else h=t=0; &#125; void push_back(pii s)&#123; d[++use]=(Node)&#123;s,0,0&#125;; if(size)&#123; d[t].nex=use; d[use].pre=t; &#125; else h=use; t=use; size++; &#125; inline bool cmp(int vl,int vr)&#123; return flag?(vl&gt;vr):(vl&lt;vr); &#125; void push(int p,int v)&#123; while(size&amp;&amp;!cmp(d[t].d.SE,v)) pop_back(); push_back(mp(p,v)); &#125; void pop(int curhead)&#123; while(size&amp;&amp;d[h].d.FR&lt;curhead) pop_front(); &#125; int getHead()&#123; if(size) return d[h].d.SE; else return flag?-INF:INF; &#125;&#125;q,b[N*2]; // b (+n)void init()&#123; q.setup(true); for(int i=0;i&lt;=2*n;i++) b[i].setup(false);&#125;inline int calc(int curs,int tars)&#123; if(curs&gt;tars) return 1; else if(curs&lt;tars) return -1; return 0;&#125;void insert(int p)&#123; if(f[p]!=-INF)&#123; q.push(p,f[p]); b[n+f[p]].push(p,s[p]); &#125;&#125;void pop(int cur)&#123; int left=max(0,cur-r); q.pop(left); if(f[left-1]!=-INF)&#123; b[n+f[left-1]].pop(left); &#125;&#125;void dp()&#123; for(int i=0;i&lt;=n;i++) f[i]=-INF; f[0]=0; for(int i=l;i&lt;=n;i++)&#123; insert(i-l); pop(i); int maxf=q.getHead(); if(maxf==-INF) continue; f[i]=maxf+calc(s[i],b[n+maxf].getHead()); int secf_s=b[n+(maxf-1)].getHead(); if(secf_s!=INF) f[i]=max(f[i],(maxf-1)+calc(s[i],secf_s)); &#125; if(f[n]==-INF) puts("Impossible"); else printf("%d\n",f[n]);&#125;int main()&#123; IO::load(); readData(); init(); dp(); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点对游戏]]></title>
    <url>%2F2018%2F10%2F09%2F%E7%82%B9%E5%AF%B9%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description 有一棵$n$个点的树，边的长度皆为1 现在，有三个人轮流从未被选择的点中等概率地选择一个点占为己有，直到全部点都被选过为止 给定$m$个互不相同的幸运数 定义一个人的收益为：自己拥有的点中，有多少无序点对满足二者距离为幸运数 求每个人的期望收益 $n \le 10000, \ m \le 10$ Solution 首先观察到，每一个人最终拥有的点数是固定的，记为$a_0,a_1,a_2$ 再考虑到题目提到的”等概率“，很容易猜想到：每一个人其实都是独立随机地从$n$个点中选择$a$个点 总方案数显然是$n \choose a$，考虑计算每种方案的收益之和$\sum$，即可算出期望 自顶向下不好考虑，正难则反，每一个贡献都发生在一个合法点对上。考虑某一个满足$u$与$v$的距离为幸运数的合法点对，它在$\sum$中贡献的次数恰好是${n-2 \choose a-2}$ 因此，若求得原树上合法点对数量为$plan$，则可以直接计算期望： \begin{aligned} ans&=\frac{plan{n-2 \choose a-2}}{n \choose a}\\ &=plan*n(n-1)a(a-1) \end{aligned} 由于$m$较小，我们直接使用点分治计算每一个幸运数对应的合法点对数量，求和即为$plan$ Summary 如果过程完全随机，不妨舍弃模拟原过程的思路，而单独考虑每一个对象本身，因为此时每一个对象得到的结果可能可以看作一个独立的主观的随机过程 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define mp make_pair#define FR first#define SE secondusing namespace std;namespace IO&#123; const int S=10000000; char buf[S]; int pos; void load()&#123; fread(buf,1,S,stdin); pos=0; &#125; char getChar()&#123; return buf[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=50010,M=15;const int INF=1e9;int n,m;int lucky[M];ll sum[M];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];int fact[N],iact[N];void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; n=getInt(); m=getInt(); for(int i=1;i&lt;=m;i++) lucky[i]=getInt(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=getInt(); v=getInt(); addEdge(u,v); &#125;&#125;namespace P&#123; bool cut[N]; int size[N]; int curbest,curval; int lis[N],cnt; void findRoot_dfs(int u,int fa,int cursize)&#123; size[u]=1; int maxsub=-1; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;!cut[v])&#123; findRoot_dfs(v,u,cursize); size[u]+=size[v]; maxsub=max(maxsub,size[v]); &#125; maxsub=max(maxsub,cursize-size[u]); if(maxsub&lt;curval)&#123; curbest=u; curval=maxsub; &#125; &#125; int findRoot(int u,int cursize)&#123; curbest=-1; curval=INF; findRoot_dfs(u,0,cursize); return curbest; &#125; void calc_collect(int u,int fa,int off)&#123; cnt=0; static int pre[N]; pre[u]=fa; static queue&lt;pii&gt; q; while(!q.empty()) q.pop(); q.push(mp(u,off)); while(!q.empty())&#123; int u=q.front().FR,dis=q.front().SE; q.pop(); lis[++cnt]=dis; for(int i=h[u],v;i;i=e[i].next) if(!cut[v=e[i].v]&amp;&amp;v!=pre[u])&#123; pre[v]=u; q.push(mp(v,dis+1)); &#125; &#125; &#125; void calc(int u,int fa,int off,int a)&#123; calc_collect(u,fa,off); for(int k=1,x;k&lt;=m;k++)&#123; x=lucky[k]; for(int i=1,j=cnt;i&lt;j;)&#123; while(i&lt;j&amp;&amp;lis[i]+lis[j]&gt;x) j--; if(i&gt;=j) break; int num=0; while(i&lt;j&amp;&amp;lis[i]+lis[j]==x)&#123; num++; j--; &#125; if(lis[i]*2==x)&#123; sum[k]+=1ll*a*num*(num+1)/2; break; &#125; else&#123; int t=i; while(lis[i]==lis[t]&amp;&amp;i&lt;=cnt)&#123; sum[k]+=1ll*a*num; i++; &#125; &#125; &#125; &#125; &#125; void solve(int x,int cursize)&#123; int u=findRoot(x,cursize); cut[u]=true; calc(u,0,0,1); for(int i=h[u],v;i;i=e[i].next) if(!cut[v=e[i].v]) calc(v,u,1,-1); for(int i=h[u],v;i;i=e[i].next) if(!cut[v=e[i].v]) solve(v,size[v]&lt;size[u]?size[v]:cursize-size[u]); &#125;&#125;double calc(ll plan,ll a)&#123; return ((double)a*(a-1))/((double)n*(n-1))*plan;&#125;void solve()&#123; int num[3]; if(n%3==0) num[0]=num[1]=num[2]=n/3; else if(n%3==1) num[0]=(n/3+1), num[1]=num[2]=n/3; else num[0]=num[1]=(n/3+1), num[2]=n/3; ll s=0; for(int i=1;i&lt;=m;i++) s+=sum[i]; for(int i=0;i&lt;3;i++) printf("%.2lf\n",calc(s,num[i]));&#125;int main()&#123; IO::load(); readData(); P::solve(1,n); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xor-Mul棋盘]]></title>
    <url>%2F2018%2F10%2F09%2Fmulxor%2F</url>
    <content type="text"><![CDATA[Description 咕咕咕 Solution 题目看起来很复杂，要求为每一个位置填入一个数，使得总代价最小 如果真要直接做，我们会发现完全没有下手点：又是异或、范围又大，连暴力都写不出来 考虑到每一个贡献的项，都是形如$d\ \text{xor}\ x$再乘上一个固定的系数的式子。我们发现每一个位相对于其他位的情况都是独立的，因此我们不妨将$d$的每一位单独拿出来考虑，在全局计算贡献 现在我们对于$k=0…20$，确定每一个$d$的第$k$位。考虑第$k$位时，由于位之间独立，且每一位只能填0或者1，因此问题转化成：如果一条边连接的两个点异或值为1，则这条边有$2^kw$的贡献 观察到行数较小，我们直接使用状压DP计算出对于每个$k$的最佳填位方案，累加到答案中即可 如果直接采用逐列转移，我们的复杂度将是$O(\log{1e6}(m4^n))$，但这个复杂度不太能令人接受。我们发现复杂度瓶颈在于$O(4^n)$枚举相邻两列的状态组合，而这个枚举又无法省去 有没有枚举组合时耗时更小的转移方式呢？考虑逐格转移，即按列从左往右转移、每列从上往下转移 类似轮廓线DP，记$f_{i,j,k}$表示转移到$(i,j)$，轮廓线状态为$k$时，由轮廓线及其左方的点组成的点集的导出子图代价最小值是多少 转移到$(i,j)$时，$O(2^n)$枚举转移之后轮廓线的状态，对于每个状态，我们可以简单地计算出新加入的点与同列的、上面的点组成的边是否有贡献。在这个基础上，枚举该点左边的位置填的是0还是1，并从上一层DP（要么是$f{i-1,j}$要么是$f{n,j-1}$）的相应状态转移取$\text{min}$累加上去即可 这样，总复杂度就降到了$O(\log1e6*(nm2^n))$ Summary 对于贡献中有关异或的问题，一般两种套路：如果题目要求用一个自己定的值去异或一堆东西，尝试在Trie上解决；如果各个位对答案独立地贡献且互不干扰（一般都是独立的，这个方法要多考虑），我们不妨将每一个位单独拉出来在原问题上跑一个只和01相关的问题（一般都很好做了，最典型的就是状压），然后通过将各个位的贡献汇总的方法得到原问题的解 此题可以通过数据范围猜测问题可能要使用状压DP，进而往“每个点只填0或1”的方向考虑，反向推出“拆位后分别状压DP求最小值”的做法 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=6,M=10010;const ll LINF=1ll&lt;&lt;60;int n,m,upcnt;int a[N][M],b[N][M],r[N][M],d[N][M],s[M];ll f[2][1&lt;&lt;N];inline ll min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline void updmin(ll &amp;x,ll y)&#123; x=(y&lt;x)?y:x;&#125;inline bool in(int x,int i,bool flag=true)&#123; return (x&gt;&gt;(i-flag))&amp;1;&#125;inline int bit(int i,bool flag=true)&#123; return 1&lt;&lt;(i-flag);&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); upcnt=(1&lt;&lt;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;b[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;m;j++) scanf("%d",&amp;r[i][j]); for(int i=1;i&lt;n;i++) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;d[i][j]); for(int i=1;i&lt;=m;i++) scanf("%d",&amp;s[i]);&#125;ll calcColumn(int id,int st,int p)&#123; ll res=0; for(int k=1;k&lt;=n;k++)&#123; if(in(st,k)^in(a[k][id],p,false)) res+=b[k][id]; if(k&lt;n)&#123; if(in(st,k)^in(st,k+1)) res+=d[k][id]; &#125; &#125; if(in(st,n)^in(st,1)) res+=s[id]; return res;&#125;ll dp(int p)&#123; for(int j=0;j&lt;upcnt;j++) f[1][j]=calcColumn(1,j,p); int cur=0; for(int j=2;j&lt;=m;j++) for(int i=1;i&lt;=n;i++)&#123; for(int k=0;k&lt;upcnt;k++)&#123; f[cur][k]=0; if(in(k,i)^in(a[i][j],p,false)) f[cur][k]+=b[i][j]; if(i&gt;1) if(in(k,i)^in(k,i-1)) f[cur][k]+=d[i-1][j]; if(i==n) if(in(k,1)^in(k,n)) f[cur][k]+=s[j]; f[cur][k]+=min(f[cur^1][k],f[cur^1][k^bit(i)]+r[i][j-1]); &#125; cur^=1; &#125; ll res=LINF; for(int j=0;j&lt;upcnt;j++) updmin(res,f[cur^1][j]); return (1ll&lt;&lt;p)*res;&#125;void solve()&#123; ll ans=0; for(int i=0;i&lt;=20;i++) ans+=dp(i); printf("%lld\n",ans);&#125;int main()&#123; readData(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>转化</tag>
        <tag>DP---状压DP</tag>
        <tag>异或</tag>
        <tag>可做未做</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几何]]></title>
    <url>%2F2018%2F10%2F07%2F%E5%87%A0%E4%BD%95%2F</url>
    <content type="text"><![CDATA[Description 有$n$个正四面体，标号为$1…n$ 其中，第$i$个四面体的每条边都由$i$根长度为1的木棒首尾相接构成 要摧毁第$i$个四面体，你需要断掉一些边，断边必须满足下列两个条件： 断边后，每个顶点连接的边不能少于2条 断掉的边的数量不小于$i$ 如果要达成目的，你需要摧毁至少$k$个四面体。注意，如果你的计划不摧毁某一个四面体，你不能动它的任意一条边 忽略断边顺序，问有多少种断边方案可以达成目的？ $ k \le n \le 60000$ Solution 假设我们知道摧毁第$n$个四面体的方案$dn$，后面的问题显然是一个DP：设$f{i,j}$表示前$i$个四面体中，已摧毁$j$个的方案数，显然有转移： f_{i,j}=f_{i-1,j}+f_{i-1,j-1}*d_i 完事后直接统计$\sum{i=k}^nf{n,i}$就是答案 考虑到这是一个整体偏移、乘上一个系数再加回原数组的DP，我们第一反应想到用生成函数解决 f_{n,j}=(\prod_{i=1}^n(d_ix+1))[x^j] 又看到$n$相对于10w而言较小，我们直接上两个log的FFT就可以完成后面的DP 关键是如何求出$d_n$ 手算得出$d_1$等于9。接下来考虑$n&gt;1$的情况 将与四个角相连的12条边单独拉出来考虑，然后再考虑从剩余的边中选多少以补齐满足“至少$n$条”的要求 考虑到每个角要么断1条，要么不断，我们可以枚举总共断$a$条边，然后计算出四个角的方案组合；断掉$a$条边之后，未考虑的边还有$6n-12$条，要从中至少选$n-a$条边断掉，则可以列出式子： d_n=\sum_{a=0}^4{4 \choose a}3^aS(6n-12,n-a)\\ S(n,m)=\sum_{i=m}^n{n \choose i} 问题转向如何快速求得$S(n,m)$。这玩意是组合数某一行的后缀和 使用直接计算化简的方法貌似行不通；由于想起了之前做另一道题时的思路：连续一段$n$相同的组合数可以快速整体向下转移，考虑直接维护$S(6n-12,n)$；其余情况当$a&gt;0$时，只需要从$S(6n-12,n)$中$O(1)$加上一些组合数即可 我们有$S(n,m)*2+{n \choose m-1}=S(n+1,m)$ 因此，当手上拿着$S(6n-12,n)$时，用上述式子做6次可以得到$S(6(n+1)-12,n)$，再减去一个${6(n+1)-12 \choose n}$就可以得到$S(6(n+1)-12,n+1)$，也就是计算$n+1$时所需要的数组 由此我们可以在$O(n)$的时间递推$S$，并一同计算出$d$ 然后就做完了 注意FFT预处理根的幂 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define pb push_backusing namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;const int N=60010;const int MOD=1e5+3;const int UP=300010;const double PI=acos(-1.0);int fact[UP],iact[UP];int d[N];int fmi(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void init()&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;MOD;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[MOD-1]=fmi(fact[MOD-1],MOD-2); for(int i=MOD-2;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;int C(int n,int m)&#123; if(n&lt;m) return 0; if(n&lt;MOD&amp;&amp;m&lt;MOD) return m&lt;=n?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0; return 1ll*C(n/MOD,m/MOD)*C(n%MOD,m%MOD)%MOD;&#125;void calcD()&#123; int n=60000; d[1]=9; int s=0; const static int pow3[5]=&#123;1,3,9,27,81&#125;; for(int i=2;i&lt;=n;i++)&#123; int cur=s; for(int j=0;j&lt;=4;j++)&#123; (d[i]+=1ll*C(4,j)*pow3[j]%MOD*cur%MOD)%=MOD; if(j&lt;4)&#123; if(i-(j+1)&gt;=0) (cur+=C(6*i-12,i-(j+1)))%=MOD; &#125; &#125; if(i&lt;n)&#123; for(int j=0;j&lt;6;j++) s=(2ll*s+C(6*i-12+j,i-1))%MOD; (s-=C(6*(i+1)-12,i))%=MOD; &#125; &#125;&#125;struct Comp&#123; double x,y; Comp()&#123;&#125; Comp(double _x,double _y):x(_x),y(_y)&#123;&#125; friend Comp operator + (const Comp a,const Comp b)&#123; return Comp(a.x+b.x,a.y+b.y); &#125; friend Comp operator - (const Comp a,const Comp b)&#123; return Comp(a.x-b.x,a.y-b.y); &#125; friend Comp operator * (const Comp a,const Comp b)&#123; return Comp(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x); &#125;&#125;;namespace FFT&#123; const int S=200010; int n,bit; int rev[S]; Comp W[17][S]; void build()&#123; for(int i=2,j=1;j&lt;17;i&lt;&lt;=1,j++) for(int k=0;k&lt;(i&gt;&gt;1);k++) W[j][k]=Comp(cos(k*PI/(i&gt;&gt;1)),sin(k*PI/(i&gt;&gt;1))); &#125; void init(int _n)&#123; for(n=1,bit=0;n&lt;_n;n&lt;&lt;=1,bit++); for(int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); &#125; void fft(Comp *a,int f)&#123; for(int i=0;i&lt;n;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); Comp u,v,w; for(int i=2,ni=1;i&lt;=n;i&lt;&lt;=1,ni++)&#123; for(int j=0;j&lt;n;j+=i)&#123; for(int k=0;k&lt;(i&gt;&gt;1);k++)&#123; w=W[ni][k]; if(f) w.y*=-1; u=a[j+k]; v=w*a[j+(i&gt;&gt;1)+k]; a[j+k]=u+v; a[j+(i&gt;&gt;1)+k]=u-v; &#125; &#125; &#125; if(f) for(int i=0;i&lt;n;i++) a[i].x/=n; &#125;&#125;vi divide(int l,int r)&#123; if(l==r)&#123; vi res(2); res[0]=1; res[1]=d[l]; return res; &#125; int mid=(l+r)&gt;&gt;1; vi lf=divide(l,mid); vi rf=divide(mid+1,r); static Comp ta[FFT::S],tb[FFT::S]; FFT::init((r-l+1)+1); for(int i=0;i&lt;=mid-l+1;i++) ta[i]=Comp(lf[i],0); for(int i=0;i&lt;=r-mid;i++) tb[i]=Comp(rf[i],0); for(int i=mid-l+2;i&lt;FFT::n;i++) ta[i]=Comp(0,0); for(int i=r-mid+1;i&lt;FFT::n;i++) tb[i]=Comp(0,0); FFT::fft(ta,0); FFT::fft(tb,0); for(int i=0;i&lt;FFT::n;i++) ta[i]=ta[i]*tb[i]; FFT::fft(ta,1); vi res((r-l+1)+1); for(int i=0;i&lt;=r-l+1;i++) res[i]=llround(ta[i].x)%MOD; return res;&#125;int solve(int n,int k)&#123; vi poly=divide(1,n); int res=0; for(int i=k;i&lt;=n;i++) (res+=poly[i])%=MOD; return res&lt;0?res+MOD:res;&#125;void answerQuery()&#123; int q,x,y; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;x,&amp;y); printf("%d\n",solve(x,y)); &#125;&#125;int main()&#123; init(); calcD(); FFT::build(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>数论---组合数学</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【GDOI2018】巡逻]]></title>
    <url>%2F2018%2F10%2F06%2F%E3%80%90GDOI2018%E3%80%91%E5%B7%A1%E9%80%BB%2F</url>
    <content type="text"><![CDATA[Description 给定一个无向图，每条边有一个长度 每次询问从某一个点出发的最小环 同时，你需要支持停用或者启用某一些点。一个点停用时，不可以被经过 $n \le 400$ Solution 我一开始总想着怎么对于每一个点直接维护其最小环，结果完全行不通 但考虑数据范围较小，我们完全可以在每次询问的时候枚举这个最小环，而不需要实时维护 看来自己的“维护”思想太过头了 每次询问时，要找一个从$x$出发的最小环。我们不妨枚举某一个点$y \neq x$，钦定最小环一定要经过$y$。我们只要统计出$x$走到$y$的最短路，加上另一条从$y$走到$x$的、走入$x$之前的接口点与前者不同的、尽可能短的路径，加起来，就可以形式化地作为“$x$走到$y$，再从$y$走到$x$构成的环“的环长 这样做，我们可以保证环在$x$的那一端不会重合，也就是至少会扯开一个口；但我们却无法保证环在$y$的一端不会重合。没关系，我们只需要对每一个$y$的答案取$\min$就可以了。因为即使$y$的答案路径有重合，在枚举到重合的第一个点$y’$时其答案显然会比$y$更优 对于修改操作，我们直接修改状态，由于不需要维护什么东西，这一步没什么难度 对于查询操作，我们要对于所有的$y$事先算出每个距离。算法容忍我们单次询问$O(n^2)$的复杂度，再考虑到我们想要在完全图上求最短路，因此首先想到Dijkstra。稍微转化一下，对于上述的两条路径，我们只需要算出：从$x$出发到每一个点$y$的、第一个走出的点不相同的两条最短路径即可，这样更好计算也更好考虑。具体实现上，要对Dijkstra进行一定的改造：每个点的距离数据记录的是从$x$出发经由两个不同出口到达当前点的路径，每个记录是一个pair，表示路径总长度和出口编号。确定锚点更新时，枚举锚点的两条路径，按边长转移后，直接像维护最大值次大值一样将新的pair推进转移点的两个pair以直接更新，而不需要考虑锚点的最/次长路径是否要对应地转移到转移点的最/次长路径 Summary 看数据范围行事。维护虽然强大，但也有干不了的事情（比如无法探知和记录的限制）。如果数据范围较小，不妨针对每次询问都直接做一遍，问题或许就会在暴力的思路下变得很显然了 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;cstdio&gt;#include &lt;utility&gt;#define mp make_pair#define FR first#define SE secondusing namespace std;typedef pair&lt;int,int&gt; pii;const int N=410;const int INF=1e9;int n;int a[N][N];bool enable[N];pii dis[N][2];bool vis[N];inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]);&#125;void init()&#123; for(int i=1;i&lt;=n;i++) enable[i]=true;&#125;void update(int u,pii &amp;p)&#123; if(p.FR&lt;=dis[u][0].FR)&#123; if(p.SE!=dis[u][0].SE) dis[u][1]=dis[u][0]; dis[u][0]=p; &#125; else if(p.FR&lt;dis[u][1].FR)&#123; if(p.SE!=dis[u][0].SE) dis[u][1]=p; &#125;&#125;int solve(int x)&#123; for(int i=1;i&lt;=n;i++)&#123; vis[i]=false; dis[i][0]=dis[i][1]=mp(INF,-1); &#125; dis[x][0]=mp(0,0); for(int i=1;i&lt;=n;i++)&#123; int u=-1; for(int v=1;v&lt;=n;v++) if(enable[v]&amp;&amp;!vis[v]&amp;&amp;(u==-1||dis[v][0].FR&lt;dis[u][0].FR)) u=v; if(u==-1) break; vis[u]=true; pii t; for(int v=1;v&lt;=n;v++) if(enable[v]&amp;&amp;!vis[v]&amp;&amp;a[u][v]!=-1) for(int k=0;k&lt;2;k++)&#123; t=mp(dis[u][k].FR+a[u][v],(u==x)?v:dis[u][k].SE); update(v,t); &#125; &#125; int res=INF; for(int u=1;u&lt;=n;u++) if(u!=x) res=min(res,dis[u][0].FR+dis[u][1].FR); return res&lt;INF?res:-1;&#125;void answerQuery()&#123; int q,opt,x; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;opt,&amp;x); if(opt==0) printf("%d\n",solve(x)); else enable[x]^=1; &#125;&#125;int main()&#123; readData(); init(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>GDOI</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[覆盖独立集]]></title>
    <url>%2F2018%2F10%2F05%2F%E8%A6%86%E7%9B%96%E7%8B%AC%E7%AB%8B%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Description 对于长度为 $n$ 的序列 $A$ ，定义其逆序图 $G$ 如下：无向图 $G$ 有 $n$ 个节点，编号为 $1.. n$ ；对于任意的 $0 \leq i \le j \le n-1$ ，如果有 $a[i] &gt; a[j]$ ，那么 $G$ 中存在一条 $i$ 和 $j$ 之间的边 定义独立集 $S$ ：对于$\forall x \in S, y \in S$ ，都不存在一条边 $(x,y)$ 定义覆盖集 $S$ ：对于$\forall x \notin S$ ，至少存在一条边 $(x,y)$ ，使得 $y \in S$ 问题来了：给你一个逆序图 $G$（保证合法），求 $G$&nbsp;有多少个点集既是独立集又是覆盖集 Solution 首先清楚一个界限：一般图的独立集是NP问题，一般做不动 观察到题目给出的“图”实际上是由一个序列转化而来，则可以猜测这个图、这个序列有很好的性质，或许能够迎合我们的两个要求 可以发现每一个逆序图都对应着至少一个序列$A$。我们不妨先构造出序列$A$，然后把两个限制照搬到序列上，看看有没有将两个限制转化成一些序列问题 考虑一个独立集$S$，其内部满足两两之间的点没有连边，也就是如果考虑$S$的每一个点对，它们在原序列上都不是逆序对。这相当于$S$在原序列上对应的位置构成了一个不下降子序列 考虑一个覆盖集$S$，要满足所有不在$S$的点都与$S$有连边，意味着所有不在$S$中的点都要和$S$中的某些元素构成逆序对。考虑原序列中的每个未选中的元素，下列情况必须满足其一： 左边有严格大于它的$S$中元素 右边有严格小于它的$S$中元素 我们综合上述两个条件，得出最后的转化结果：一个点集$S$满足要求，当且仅当此点集在原序列中对应着一个不下降子序列，且对于$S$中按编号排序后两个相邻的元素在原序列中对应的两个元素$a_i,a_j$，中间夹着的每一个元素$k\in(i,j)$都要满足$a_ka_j$；换言之，不可以出现$a_i\le a_k \le a_j$的情况 序列上的带限制的统计问题，我们一般使用DP解决。在原序列上，设$f_i$表示以$a_i$结尾的合法子序列数目。考虑正向转移，$a_i$后面可以跟哪一些$a_j$呢？我们只需要从$i+1$开始往后枚举每一个$j$，维护中间夹着的、满足$a_k\ge a_i$的最小值，看是否大于$a_j$即可。若合法，令$f_j+=f_i$。这样一来，我们就可以在$O(n^2)$的时间完成这个DP 为了方便，可以令$a0=-\infty， a{n+1}=\infty$。我们钦定这两个元素必选，则DP完成后，$f_{n+1}$就是答案 对于从图还原成序列的过程，我们先通过输入统计对于序列上的每一个位置，其右边的比它小的位置有多少个，记为$s_i$。还原时，从后往前填入每一个数，每次找到右边第$s_i$大的数，记为$x$，将右边所有不小于$s_i$的数全部+1，偏移一位，空出$x$，令$a_i$为$x$即可 注意细节，比如$a0$和$a{n+1}$应该设成$\pm (\infty-1)$，以防DP维护最小值时，初值$\infty$无法成功判定严格大于 Summary 如果题目涉及到一些较困难的传统问题，最好应观察题目是否有给定一些性质。我们应该从那些性质入手构建并转化出另一套更简单的模型并解决，而不是纠缠于如何将几个复杂的问题套在一起解决 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=1010;const int INF=1e9;int n,m;int sum[N];int a[N];ll f[N];inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); u++; v++; if(u&lt;v) sum[u]++; else sum[v]++; &#125;&#125;void initSequence()&#123; a[0]=-INF; static int who[N],up=0; for(int i=n;i&gt;=1;i--)&#123; for(int j=up-1;j&gt;=sum[i];j--)&#123; a[who[j]]++; who[j+1]=who[j]; &#125; a[i]=sum[i]; who[sum[i]]=i; up++; &#125; a[n+1]=INF-1;&#125;void solve()&#123; f[0]=1; for(int i=0,k;i&lt;=n;i++)&#123; k=INF; for(int j=i+1;j&lt;=n+1;j++) if(a[j]&gt;=a[i]&amp;&amp;k&gt;a[j])&#123; f[j]+=f[i]; if(a[j]&gt;a[i]) k=min(k,a[j]); &#125; &#125; printf("%lld\n",f[n+1]);&#125;int main()&#123; readData(); initSequence(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>转化</tag>
        <tag>DP</tag>
        <tag>好题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU5036】Explosion]]></title>
    <url>%2F2018%2F10%2F05%2Fhdu5036_explosion%2F</url>
    <content type="text"><![CDATA[Description 给一张有向图 初始时所有点都是白色的 每次随机选择一个点，将其能够到达的点全部染黑（包括它自己） 问染黑所有点的期望步数 $n \le 1000$ Solution 对于某一种合法的操作方案，我们对其记操作序列$a$，表示序列中的元素被逐个取出操作之后，原图可以被完全染黑 这个序列的构建不是主动的，而是由实际合法方案被动构造得来 这个序列对答案的贡献显然就是其长度，但这个序列出现的概率怎么考虑？ 直接想非常困难；我们换一个统计方法，考虑从每个元素自身贡献的角度来计算： 一个元素$x$对某个序列有1的贡献，当且仅当其出现在操作序列中；处于操作序列有一个前提：为了保证序列合法，该序列中，$x$之前不可以存在任何属于集合$S_x-x$的点，否则$x$不可以放入序列，其中$S_x$表示原图中$x$的前驱构成的点集（包括$x$自己） 为了涂黑每个点，一个合法序列显然不会存在$S_x$中的点完全没有出现的情况，因此$S_x$中有且仅有一个元素出现在序列中。要让$x$出现，换言之作为$S_x$中被选中的点，此事件发生的概率显然是$\frac 1 {\mid S_x\mid}$，故$x$对该序列的期望贡献也为$\frac 1 {\mid S_x\mid}$ 根据期望线性性，我们只需要将“每一个点对任意一个合法操作序列的期望贡献”求和，就可以得到整体局面的期望答案值 要求出每个点的$\mid S_x\mid$，我们用bitset优化计算传递闭包，在$O(\frac{n^3}{64})$的时间内完成求解；或者缩点构建出DAG后$O(\frac{n^2}{64})$计算 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;bitset&gt;using namespace std;const int N=1010;int n;bitset&lt;N&gt; f[N];void reset()&#123; for(int i=1;i&lt;=n;i++) f[i].reset();&#125;void readData()&#123; scanf("%d",&amp;n); for(int u=1,k,v;u&lt;=n;u++)&#123; scanf("%d",&amp;k); while(k--)&#123; scanf("%d",&amp;v); f[v][u]=1; &#125; f[u][u]=1; &#125;&#125;void floyd()&#123; for(int j=1;j&lt;=n;j++) for(int i=1;i&lt;=n;i++) if(f[i][j]) f[i]|=f[j];&#125;double solve()&#123; double res=0; for(int i=1;i&lt;=n;i++) res+=1.0/f[i].count(); return res;&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++)&#123; reset(); readData(); floyd(); printf("Case #%d: %.5lf\n",i,solve()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>概率与期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4299】ForbiddenSum]]></title>
    <url>%2F2018%2F10%2F04%2Fbzoj4299_ForbiddenSum%2F</url>
    <content type="text"><![CDATA[Description Solution 考虑如何计算一个确定集合的值 将集合内的元素从小到大排序后，我们从前往后逐个加入新元素，考虑答案的改变： 集合为空时，值显然为1 现在我们已知$ans{i-1}$，要求出$ans_i$，记第$i$个数数为$a{i}$。设前$i$个数构成集合的值为$ans_i$，这意味着前$i$个元素可以组成$[0,ans_i)$中的所有数。考虑新加入的$a_i$对可行区间的影响： $ai \le ans{i-1}$：我们发现$[0,ans{i-1})$这一段会整体向右平移$a_i$，从而使得$[a_i,ans_i+a_i)$也可以被组合出来。我们还发现，在保证$a$递增时，$ans{i-1}+ai$这个位置就是$ans{i}$ $ai&gt;ans{i-1}$：想要把$ai$这个数和之前的数组合生成新的数，最小也只能得到$a_i$，而$a_i&gt;ans{i-1}$，这意味着$ans{i-1}$这个位置依然不能被组合得到。因此$ans{i}=ans_{i-1}$。 由于递增，显然之后的所有$ans$都将等于$ans_{i-1}$ 由此，若$1…i$都没有出现过第二种情况，则$ansi$可以表示为$1+\sum{k=1}^ia_k$ 想要求答案，我们应找到一个最小的$i$，使得$ai&gt;1+\sum{k=1}^{i-1}ak$，此时$ans{i-1}$就是答案 在$O(n)$的做法，我们逐步模拟每一个$i$，判断第二种情况并停止即可 然后我就懵逼了，这玩意没有二分性，于是我就想到了用树套树之类的方法维护区间是否存在不合法……到头说来，树套树根本不支持在两维的情况下实现合并两端区间信息的操作。我就卡在这里卡到了比赛结束 实际上，我们不仅可以一步一步地模拟，还可以跳着模拟。具体来说，原本我们从$ans{i-1}$推到$ans_i$，要考虑$a_i$是否不超过$1+\sum{k=1}^{i-1}ak$；而现在我们可以将结论推广，对于$j&gt;i$，只要其满足$a_j \le 1+\sum{k=1}^{i}a_k$，我们就可以从$ans_i$直接跳到$ans_j$。具体要怎么分析呢？直接套用第一种情况的思路：只要新值不超过当前的第一段可行范围，这个值加入集合后，就可以帮助第一段可行范围向右无缝增长；更何况处理到新值时，可行范围还在不断增长，所以显然如果一次性处理到新值，我们在中途都不会触碰到界限。 我们发现第一种模拟方法其实是狭义的，而后者是广义的，前者包含于后者 这样一来，我们可以每次跳多步，以此来加速过程。假设当前$1…i$都没有发生第二种情况，也就是我们拿着$ansi$，转移时，我们找到一个最大的$j$使得$a_j\le ans_i$，并令$ans_j$为$ans_i+\sum{k=i+1}^ja_k$，对$j$重复上述过程，直到没有新的$j$满足情况、或者走完了整个序列位置 如此操作，步数有没有保证呢？有，而且很快。转移的长度（或者说是速度）取决于$ansi$，当$ans_i$足够大时，$j$就直接溜完了整个序列；如果想要将其卡到最慢，也就是每次令$j=i+1$，$a{j+1}$必须大过$ans_i$，也就是翻一倍。由此，步数不会超过$O(\log \sum a)$，完全可以接受 至于二分$j$的过程，我们使用一个主席树维护区间权值和，在二分出最大的$aj$时顺带统计$a_j$左边的权值之和，以准备更新$ans$。实际实现计算$ans_j$时不需要用$ans_i+\sum{k=i+1}^j$辅以“判断小于等于某个值得最大值”这种计算方式，太过麻烦；我们不需要真正去找到$j$，直接按上述方法，二分时计算出出权值在$ans_i$以内的值之和。如果这个和等于$ans_i$说明本次操作一点长进都没有，$j=i$，退出；否则将$ans$设为这个新的和。我们相当于把下标的概念模糊掉，以方便实现 Summary 树套树一般不能在要求其统计两维数据的情况下，指定第一维时在第二维里合并数据 如果感觉$O(n)$一步一步模拟已经足够简单无法简化时，考虑转移本身是否不一定要逐个元素走，而是存在一种广义的转移：找到一个当前可转移的最远状态，使得中间经历的所有转移都合法，并直接模拟中间的所有转移 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;int n;int a[N];int dcnt,d[N];namespace SEG&#123; const int S=N*18; int rt[N],sz; int ch[S][2]; int sum[S]; inline int copy(int u)&#123; int v=++sz; ch[v][0]=ch[u][0]; ch[v][1]=ch[u][1]; sum[v]=sum[u]; return v; &#125; void insert(int u,int &amp;v,int l,int r,int pos)&#123; v=copy(u); sum[v]+=d[pos]; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) insert(ch[u][0],ch[v][0],l,mid,pos); else insert(ch[u][1],ch[v][1],mid+1,r,pos); &#125; int findright(int u,int v,int l,int r)&#123; if(sum[v]-sum[u]==0) return -1; if(l==r) return l; int mid=(l+r)&gt;&gt;1; if(sum[ch[v][1]]-sum[ch[u][1]]) return findright(ch[u][1],ch[v][1],mid+1,r); else return findright(ch[u][0],ch[v][0],l,mid); &#125; int binary_find(int u,int v,int l,int r,int r_val)&#123; if(sum[v]-sum[u]==0) return -1; if(l==r) return d[l]&lt;=r_val?(sum[v]-sum[u]?l:-1):-1; int mid=(l+r)&gt;&gt;1; int res=-1; if(r_val&lt;=d[mid]) res=binary_find(ch[u][0],ch[v][0],l,mid,r_val); else res=binary_find(ch[u][1],ch[v][1],mid+1,r,r_val); if(res==-1&amp;&amp;d[mid]&lt;=r_val) res=findright(ch[u][0],ch[v][0],l,mid); return res; &#125; int query(int u,int v,int l,int r,int L,int R)&#123; if(L&gt;R) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return sum[v]-sum[u]; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(ch[u][0],ch[v][0],l,mid,L,R); else if(mid&lt;L) return query(ch[u][1],ch[v][1],mid+1,r,L,R); else return query(ch[u][0],ch[v][0],l,mid,L,mid)+query(ch[u][1],ch[v][1],mid+1,r,mid+1,R); &#125;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++) d[i]=a[i]; sort(d+1,d+1+n); dcnt=unique(d+1,d+1+n)-d-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(d+1,d+1+dcnt,a[i])-d;&#125;void buildSeg()&#123; for(int i=1;i&lt;=n;i++) SEG::insert(SEG::rt[i-1],SEG::rt[i],1,dcnt,a[i]);&#125;int solve(int l,int r)&#123; int res=1,d_cur,d_last=0; while(true)&#123; d_cur=SEG::binary_find(SEG::rt[l-1],SEG::rt[r],1,dcnt,res); if(d_cur==-1||d_cur&lt;=d_last) break; res+=SEG::query(SEG::rt[l-1],SEG::rt[r],1,dcnt,d_last+1,d_cur); d_last=d_cur; &#125; return res;&#125;void answerQuery()&#123; int q,l,r; scanf("%d",&amp;q); for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;l,&amp;r); printf("%d\n",solve(l,r)); &#125;&#125;int main()&#123; readData(); Diz(); buildSeg(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>思考题</tag>
        <tag>数据结构---主席树</tag>
        <tag>好题</tag>
        <tag>凑数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC023C】Paint Machines]]></title>
    <url>%2F2018%2F10%2F03%2Fagc023_c--paintmachine%2F</url>
    <content type="text"><![CDATA[Description 题目链接 Solution 一开始自以为是地想到了isn的做法，然而好像由于某些原因咕咕咕了 考虑对于每一个$k$，计算出有多少排列满足恰好在其第$k$次染色时序列变为全黑 先考虑前$k$个操作的分布位置，最后统计时乘上$k!$即可 对于前$k$个操作位置的布局$a_1&lt;a_2&lt;…&lt;a_k$，我们可以发现如下规律： $a_1=1,\ a_k=n-1$ 对于$i=1…k-1$，满足$a_{i+1}-a_i\le 1$ 也就是对于$1…n-1$这些位置，$1$和$n-1$必选，且中间的两两元素间隔不可以超过$1$ 直接统计不好搞，我们考虑用组合意义快速计算：将间隔看成一个球，一共有$n-1-k$个球；现有$k-1$个空位，每个位置只能放一个球。只要计算出这个问题的答案，我们就等价地求出了前$k$个操作位置的合法布局方案数 显然，这个值就是${ k-1 \choose n-1-k}$ 确定了前$k$个元素，再使用组合意义补上后面的$n-1-k$个元素，我们可以计算出在$k$次操作以内填涂完毕的排列个数$f_k={k-1 \choose n-1-k}k!(n-1-k)!$ 则恰好在第$k$次操作时填涂完毕的排列个数就是$gk=f_k-f{k-1}$ 有了$g_k$，计算的答案的部分就很简单了 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;using namespace std;const int N=1000010;const int MOD=1e9+7;int n;int fact[N],iact[N];int f[N];int fmi(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void init()&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;=n;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[n]=fmi(fact[n],MOD-2); for(int i=n-1;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;inline int C(int n,int m)&#123; return m&lt;=n?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;&#125;void solve()&#123; int ans=0,last=0; for(int k=(n+1)&gt;&gt;1;k&lt;n;k++)&#123; int f=1ll*C(k-1,n-1-k)*fact[k]%MOD*fact[n-1-k]%MOD; int num=(f-last)%MOD; last=f; (ans+=1ll*num*k%MOD)%=MOD; &#125; printf("%d\n",ans&lt;0?ans+MOD:ans);&#125;int main()&#123; scanf("%d",&amp;n); init(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>数论---组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2017】列队]]></title>
    <url>%2F2018%2F10%2F03%2F%5Bnoip2017%5D%E5%88%97%E9%98%9F%2F</url>
    <content type="text"><![CDATA[Description 题目链接 Solution 由于这个问题自身的规模过大、看起来无法记录，我们考虑使用不开满的数据结构维护这个队伍 鉴于最后一列的行进方向特殊，而每一行除去最后一列以后，其可以看做一个整体来维护，我们使用$n$棵动态开点线段树维护每一行的前$m-1$个元素，再用一棵线段树维护最后一行 操作分两种情况： $y==m$: 在维护最后一列的线段树上查询第$x$个元素，将其删去，在线段树末加入这个元素 $y&lt;m$: 在维护第$x$行的线段树上查询第$y$个元素$a$，将其删去 在维护最后一列的线段树上查询第$x$个元素$b$，将其删去 将$b$加到第$x$行的线段树末尾 将$a$加到最后一列的线段树末尾 这些看似是平衡树的操作其实可以用线段树模拟：我们维护区间有值点的个数$siz$。则删去一个点等价于将其所属叶子节点的$siz$设置为0，然后一路上推。查询第$k$个元素时利用$siz$二分即可。由于线段树要支持每次在其大小+1的位置插入一个数，而总操作数为$q$，因此我们可以预先将线段树的宽度开到$[1,n+q]$或者$[1,m-1+q]$ 对于原始值的初始化问题，在模拟开始前，我们对每一棵线段树的$[1,n]$或者$[1,m-1]$区间打上相应的等差数列标记和以下省略标记（两者要么同时存在，要么同时清空）。在之后的所有操作中，我们都不再增加新的标记，而是直接使用单点修改，且之后加入的数显然都不会被一开始时打的任何标记所影响。 由于时空限制较宽，我们可以在$O((n+q)\log(n+q))$的时间内解决问题 Summary 网格图警告 严重失误 回想去年，自己打的50分暴力在模拟两个看齐时，用来循环的变量$i$竟然打成了$x$ 12for(int j=y;j&lt;m;j++) id[x][j]=id[x][j+1];for(int i=x;i&lt;n;i++) id[x][m]=id[x+1][m]; 今年重写时，我在程序中多次将$n$和$m$打反，包括宽度高度打反、等差数列的首项和公差打混，而因为测试数据和手构的数据大多都是$n$等于$m$，这些错误一点都看不出来 当然，后者是在我懒得拍的情况下才会出现的失误。但不排除自己会脑袋一热，数据仍然构造成$n=m$ 以此警戒自己： 写网格矩阵题时，一定要复查代码中关于长和宽的语句是否有混淆，且手构小数据、对拍大数据时$n$和$m$要随机波动 考场上越是简单的代码，越要详细看，越要保证其正确性，不要懒，构造一些数据出来跑一下；即使是那些已经不能再暴力的部分，也要仔细看清楚是否含有低级错误 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=300010,Q=300010;int n,m,q;int pos[N];namespace SEG&#123; const int S=(N+Q)*18*2; int rt[N],sz; int ch[S][2]; int siz[S]; ll tag[S][2]; void pushup(int u)&#123; siz[u]=siz[ch[u][0]]+siz[ch[u][1]]; &#125; void build(int &amp;u,int l,int r,int up,ll a,ll b)&#123; u=++sz; if(r&lt;=up)&#123; siz[u]=r-l+1; tag[u][0]=a; tag[u][1]=b; return; &#125; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid,up,a,b); if(mid&lt;up) build(ch[u][1],mid+1,r,up,a+b*(mid-l+1),b); pushup(u); &#125; void pushdown(int u,int l,int r)&#123; if(!tag[u][1]) return; if(!ch[u][0]) ch[u][0]=++sz; if(!ch[u][1]) ch[u][1]=++sz; int lc=ch[u][0],rc=ch[u][1],mid=(l+r)&gt;&gt;1; tag[lc][1]=tag[rc][1]=tag[u][1]; tag[lc][0]=tag[u][0]; tag[rc][0]=tag[u][0]+tag[u][1]*(mid-l+1); siz[lc]=mid-l+1; siz[rc]=r-mid; tag[u][0]=tag[u][1]=0; &#125; void modify(int &amp;u,int l,int r,int pos,ll val)&#123; if(!u) u=++sz; if(l==r)&#123; tag[u][0]=val; siz[u]=1; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modify(ch[u][0],l,mid,pos,val); else modify(ch[u][1],mid+1,r,pos,val); pushup(u); &#125; ll query(int &amp;u,int l,int r,int k)&#123; siz[u]--; if(l==r) return tag[u][0]; pushdown(u,l,r); int mid=(l+r)&gt;&gt;1; if(k&lt;=siz[ch[u][0]]) return query(ch[u][0],l,mid,k); else return query(ch[u][1],mid+1,r,k-siz[ch[u][0]]); &#125;&#125;void initSeg()&#123; for(int i=1;i&lt;=n;i++)&#123; pos[i]=m-1; SEG::build(SEG::rt[i],1,m-1+q,m-1,1ll*(i-1)*m+1,1); &#125; SEG::build(SEG::rt[n+1],1,n+q,n,m,m); pos[n+1]=n;&#125;void answerQuery()&#123; int x,y; ll id,in; for(int i=1;i&lt;=q;i++)&#123; scanf("%d%d",&amp;x,&amp;y); if(y&lt;m)&#123; id=SEG::query(SEG::rt[x],1,m-1+q,y); in=SEG::query(SEG::rt[n+1],1,n+q,x); SEG::modify(SEG::rt[x],1,m-1+q,++pos[x],in); SEG::modify(SEG::rt[n+1],1,n+q,++pos[n+1],id); &#125; else&#123; id=SEG::query(SEG::rt[n+1],1,n+q,x); SEG::modify(SEG::rt[n+1],1,n+q,++pos[n+1],id); &#125; printf("%lld\n",id); &#125;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;q); initSeg(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>数据结构---线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC024B】Backfront]]></title>
    <url>%2F2018%2F10%2F01%2Fagc024_b--Backfront%2F</url>
    <content type="text"><![CDATA[Description 给一个长度为$n$的序列，满足其为一个排列 现要求用最少步数将其排序，每一步可以将一个数提到序列的首位或者末尾 求最少步数？ $1 \le n \le 2 * 10^5$ Solution 考虑最暴力的整理过程：对于$i=n…1$，如果$i$不在首位，则将其提到首位 但这样只使用了前提的操作；同样地，我们可以提出一个后提的做法。但显然两者都不是最优的 考虑综合二者，发现每个合法的整理都是这样一个过程：将一部分数字前提，一部分数字后提，而未操作的数字自然呈连续上升状态。我们发现，前提的数字一定属于形如$[1,x]$的区间，后提的数字一定属于形如$[y,n]$的区间。因此，重复$i=x…1$和$i=y…n$做前提后提即可。相应地，我们要保证$(x,y)$这些数具有一个在原序列上的相对顺序与权值相对顺序相同的性质。 规定了$x$和$y$且$(x,y)$的数字满足性质时，步数上界显然是$x+(n-y+1)$。但有没有可能更小呢？就是说会不会在前提的过程中减少了后提的次数、在后提的时候减少了前提的次数呢？我们发现在这种情况发生时，$(x,y)$这个区间总是能向两端扩展。也就是只要我们找到了$(x,y)$区间的最大宽度，我们一定能覆盖到所有最优情况 接下来使用一个$O(n)$的DP计算最长连续上升子序列的长度就可以了 Summary 如果题目给出了一个目标，要求你使用某种方式构造最优解，而又感觉无从下手时，不妨先找到每一种可行方案的共同点和本质模式，然后在模式的层面上想怎么构造才能最优。 Code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;unordered_map&gt;using namespace std;const int N=200010;int n;int a[N],f[N];inline void updmax(int &amp;x,int y)&#123; x=(x&gt;=y)?x:y;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]);&#125;void solve()&#123; int ans=0; for(int i=n;i&gt;=1;i--)&#123; f[a[i]]=f[a[i]+1]+1; updmax(ans,f[a[i]]); &#125; printf("%d\n",n-ans);&#125;int main()&#123; readData(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC025C】Interval Game]]></title>
    <url>%2F2018%2F09%2F30%2Fagc025_c--Interval_game%2F</url>
    <content type="text"><![CDATA[Description A站在数轴上的原点，B有$n$个线段 游戏分为$n$个阶段：每次B从还未选择的线段中选择一个，然后A必须走到该线段之中（可以站在端点上） $n$个阶段结束后，A会再走回原点 B可以任意规定线段拿出来的顺序，然后A会以最优的策略走完全程，也就是A走的总路程会尽可能的少 问A总路程的最大值？ Solution 这题让我联想到火车那一题转化之后的情况：那题使用了DP解决站在左右端点的情况。然而那题的人只能往右走，而本题的人可以左右走，所以并不适用 首先明确A的策略：如果选择线段包含本身，A一定不动，不动肯定不会更劣；否则，走到目标线段中，靠近自己的一个端点上，执行这种策略不会更劣 先不说那些包含当前位置的线段：如果A在线段的右边，那么A会走到右端点；如果在左边，那么A会走到左端点 我们要最大化A走的距离，一个最暴力直观的想法，就是让A反复横跳：先尽可能地让A往左走，再尽可能地让A往右走。要做到这一点，我们先选择右端点最小的线段，再选择左端点最大的线段，然后重复上述过程，并模拟A的走路过程即可。具体实现上，用两个set按左端点和右端点同步维护剩余未选的线段 直觉告诉我们：出发点有两种决策：先往左和先往右。因此，我们将第一步往左和第一步往右的两种情况的答案取$max$输出。具体是为什么？我也不是特别清楚，应该是因为这样能覆盖到所有较优情况吧…… Summary 使最小值最大的问题，如果尝试用贪心解决，就想想如何构造最坏情况，使得“最小”的决策方式最劣 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;set&gt;#define mp make_pair#define FR first#define SE secondusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;const int N=100010;int n;int a[N][2];set&lt;pii&gt; l,r;inline ll max(ll x,ll y)&#123; return x&gt;y?x:y;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i][0],&amp;a[i][1]); a[n+1][0]=0; a[n+1][1]=0;&#125;void addseg(int i)&#123; l.insert(mp(a[i][0],i)); r.insert(mp(a[i][1],i));&#125;void remseg(int i)&#123; l.erase(l.find(mp(a[i][0],i))); r.erase(r.find(mp(a[i][1],i)));&#125;void initSet()&#123; for(int i=1;i&lt;=n;i++) addseg(i);&#125;void move(int &amp;cur,ll &amp;sum,int t)&#123; if(a[t][0]&lt;=cur&amp;&amp;cur&lt;=a[t][1]) return; else if(cur&lt;a[t][0])&#123; sum+=a[t][0]-cur; cur=a[t][0]; &#125; else&#123; sum+=cur-a[t][1]; cur=a[t][1]; &#125;&#125;void goleft(int &amp;cur,ll &amp;sum)&#123; static set&lt;pii&gt;::iterator it; it=r.begin(); int id=(*it).SE; move(cur,sum,id); remseg(id);&#125;void goright(int &amp;cur,ll &amp;sum)&#123; static set&lt;pii&gt;::iterator it; it=l.end(); it--; int id=(*it).SE; move(cur,sum,id); remseg(id);&#125;ll solve(int f)&#123; ll res=0; int cur=0; initSet(); for(int i=1;i&lt;=n;i++) if(i&amp;1^f) goleft(cur,res); else goright(cur,res); move(cur,res,n+1); return res;&#125;int main()&#123; readData(); printf("%lld\n",max(solve(0),solve(1))); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC008D】Kth-K]]></title>
    <url>%2F2018%2F09%2F29%2Fagc008_d--Kth-K%2F</url>
    <content type="text"><![CDATA[Description 给你一个长度为$N$的整数序列$Xi$，请判断是否存在一个满足下列条件的整数序列$a$，如果存在，请构造一种方案 条件如下： $a$的长度为$N^2$，并且满足数字$1,2,3…N$都各出现恰好$N$次 对于$1 \le i \le N$，数字$i$在$a$中第$i$次出现的位置是$X_i$ $1 \le N \le 500, \;1\le X_i\le N^2$，保证$X_i$互不相同 Solution 转化一下问题。题目相当于对于每个$i$，规定在$[1,x_i)$要放$i-1$个$i$，在$(x_i,n^2]$要放$n-i$个$i$ 我们称前者为“向前”的请求，后者为“向后”的请求 这样，我们就得到了$2n$个有范围和次数限制的请求。我们可以将它们看做各自独立的请求。 考虑从左往右枚举每一个位置$p=1…n^2$，并确定当前位置应该用来填入哪一个请求（或者说对其贡献） 首先，观察考虑对象的变化：当前位置右移时，能填入的向前请求越来越少，而能填入的向后请求越来越多 假设我们对于当前可用的向前的请求，按其结束位置（右端点$x_i-1$）从小到大排序，显然当前位置$p$应该填入结束位置最靠左的那一个请求，记其为$A$；如果$p$填入的请求不是$A$，而是结束位置更靠右的请求，我们完全可以填入$A$，且情况一定不会更劣，因为我们从左到右填时，优先填入了那些剩余周旋空间更小的请求 那么我们的策略就是：如果当前有可用的向前请求，将当前位置填入结束位置最靠左的那一个。如果填完后该请求已满，则删去这个请求。 当前位置右移时，弹出的显然是结束位置最靠左的请求，如果此时其还未被满足，则无解 那么向后请求怎么办呢？我们发现，在考虑向前请求时之所以要优先分配给最靠左的请求，是因为最靠左的元素在最近的将来就要失去考虑机会；而对于向后的请求，随着枚举位置的右移，机会反而越来越多。因此，我们就不需要给向后请求太多的关照。当且仅当没有向前请求时，我们再随便给一个当前可考虑的向后请求填入$p$即可 整体算法可以用一个数组和界限指针模拟 Summary 感觉无法很好地设置状态、刻画阶段的题目，有可能就是贪心了 线性贪心，一般是从左往右扫，优先考虑、调配和满足那些所剩考虑余地更小的元素（隐形前提是，这些考虑余地和从左往右扫呈线性相关） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define END &#123;puts("No"); return 0;&#125;using namespace std;const int N=510;int n;int a[N];int who[N];int ans[N*N];struct Set&#123; int id,rest;&#125;s1[N*N],s2[N*N];int s1cnt,s2cnt;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); ans[a[i]]=i; &#125;&#125;bool cmpByA(const int &amp;u,const int &amp;v)&#123; return a[u]&lt;a[v];&#125;bool init()&#123; for(int i=1;i&lt;=n;i++) who[i]=i; sort(who+1,who+1+n,cmpByA); for(int i=1;i&lt;=n;i++)&#123; int x=who[i]; if(x-1&gt;a[x]-1||n-x&gt;(n*n)-a[x]) return false; if(x&gt;1) s1[++s1cnt]=(Set)&#123;x,x-1&#125;; if(x&lt;n) s2[++s2cnt]=(Set)&#123;x,n-x&#125;; &#125; return true;&#125;bool solve()&#123; int b1=1,b2=1,c1=1,c2=1; int m=n*n; for(int i=1;i&lt;=m;i++) if(!ans[i])&#123; while(c1&lt;=s1cnt&amp;&amp;a[s1[c1].id]-1&lt;i)&#123; if(s1[c1].rest) return false; c1++; &#125; while(b2&lt;=s2cnt&amp;&amp;a[s2[b2].id]+1&lt;=i) b2++; if(c1&gt;s1cnt&amp;&amp;c2&gt;=b2) return false; if(c1&lt;=s1cnt)&#123; ans[i]=s1[c1].id; s1[c1].rest--; if(!s1[c1].rest) c1++; &#125; else&#123; ans[i]=s2[c2].id; s2[c2].rest--; if(!s2[c2].rest) c2++; &#125; &#125; return true;&#125;int main()&#123; readData(); if(!init()) END; if(!solve()) END; puts("Yes"); for(int i=1;i&lt;=n*n;i++) printf("%d ",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC001C】Squared Graph]]></title>
    <url>%2F2018%2F09%2F29%2Fagc011_c--Squared_Graph%2F</url>
    <content type="text"><![CDATA[Description 有一个$n$个点的无向图，这个图中有$m$条边$(u_i,v_i)$且无自环或重边 高桥君现在要用这个图构建一个有$n^2$个点的新图，新图中的每个节点的编号为有序数对$(a,b)(1\leq a,b\leq n)$ 新图的边按照以下规则生成 点$(a,b)$和点$(a’,b’)$有边当且仅当原图中存在边$(a,a’),(b,b’)$ 那么新图中有多少个联通块呢 $ 2\le n \le 10^5$ $0 \le m \le 2 * 10^5$ Solution 又是这种组织概念的玄乎题 每一个新的点都由两个点组成。我们可以考虑将原图复制一份出来，记为$A$和$B$。那么每一个新点就可以实体化为在$A$上的某个点$a$和在$B$上的某个点$b$组成的点对，或者说叫一个状态$(a,b)$ 那么$(a,b)$能直接走到$(a’,b’)$，当且仅当在$A$中$a$和$a’$有边直接相邻、在$B$中$b$和$b’$有边直接连接 关键的一步扩展：$(a,b)$能走到$(a’,b’)$，当且仅当$a$走到$a’$的某条路径长度奇偶性与$b$走到$b’$的某条路径长度奇偶性相同？为什么？先往那边走，如果有一者先到达了终点，那么它可以来回在终点折返；由于奇偶性相同，某个时刻它折返回终点时另一者也会到达 由于新点的移动和单点的移动有一定关系，因此单点移动的范围是比较关键的划分。单点移动的范围即其所处连通块，我们考虑每个单点处在的连通块的特征 现在考虑如何把这些抽象的“点”的连通块刻画出来：只要从某个状态出发遍历足够多的情况，就可以遍历完其所在的整个连通块 所以当下我们考虑某一个点对$(a,b)$能走到其他哪一些点对 首先，如果$a$或$b$某一个点是一个单点，此时另一个点不论所处情况如何，点对$(a,b)$都根本走不动。因此只要一个点对中某一个点为孤立点，那么这个点对在新图上也是孤立的 单点考虑完毕，我们去除掉它们。下面考虑的$a$和$b$的所处位置都不是单点 由于上述提到长度奇偶性相同就可以互达的结论，可联想到二分图，我们将连通块按是否为二分图来分类 如果$a$和$b$都处于某个二分图中，不妨记两个二分图的两部分分别为$L_a,R_a,L_b,R_b$，则我们发现$(L_a,L_b)\cup(R_a,R_b)$这些全部可以互达，因为这些点对的两点对应路径的长度奇偶性都一样；同理$(L_a,R_b)\cup (L_b,R_a)$也是。这两个点集已经覆盖了当下所有点对，因此这种情况会贡献恰好2个连通块。 如果只有某一个处于二分图中，则没有这个性质；但结论是两点分别在两个连通块内的所有点对都属于一个连通块。因为一旦某一个图不是二分图，就意味着存在奇环，即存在调整路径长度奇偶性的机会。这个结论保证了任意两点都可以互达。这种情况会贡献1个连通块 记原图单点数量为$a$，非二分图连通块数量为$b$，二分图连通块数量为$c$，总点数为$n$ 则答案为 a^2+2a(n-a)\\ + \\c^2+2cb+2b^2Summary 如果新元素是由原本的元素组成二元组、或者其他形式得到，尝试通过复制等方式迎合这个概念，构造出一个具体的模型、或者思考角度 图上玄学计数，一般是分类讨论搞出来的，存在一些结论可以归并大部分情况。一般都是对某个性质分类，比如此题的是不是二分图 之所以联想到二分图，是因为点对互达的条件是二者对应点路径长度奇偶性相同。这要求我们联想到二分图上，处于某一种出发状态的两点走来走去路径长度奇偶性始终相同、且到达位置的情形和出发点类似这一个特征 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=100010,M=200010;int n,m;int h[N],tot;struct Edge&#123; int v,next;&#125;e[M*2];bool vis[N];int col[N];bool flag;// sumll single,nobi,bi;void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125;&#125;void paint(int u)&#123; vis[u]=true; if(!h[u]) throw 0; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; if(!vis[v])&#123; col[v]=(col[u]^1); paint(v); &#125; else if((col[u]^col[v])!=1) flag=false; &#125;&#125;void calcNum()&#123; for(int u=1;u&lt;=n;u++) if(!vis[u])&#123; try&#123; flag=true; paint(u); &#125; catch(int e)&#123; single++; continue; &#125; if(flag) bi++; else nobi++; &#125;&#125;int main()&#123; readData(); calcNum(); printf("%lld\n",(single*single+2*single*(n-single))+nobi*nobi+2*nobi*bi+2*bi*bi); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>分类讨论</tag>
        <tag>计数问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[银河战舰]]></title>
    <url>%2F2018%2F09%2F28%2F%E9%93%B6%E6%B2%B3%E6%88%98%E8%88%B0%2F</url>
    <content type="text"><![CDATA[Description 给一棵点带权的树，求所有简单路径的权值最大值 一条路径的权值定义为它经过的点的权值构成序列的最长严格上升子序列 $1 \le N \le 200000$ Solution 先想一下序列上的简化问题：从左往右扫时，维护$f_i$表示长度为$i$的LIS的结尾最小权值 搬到树上：就是从下往上扫，维护$f_{u,i}$表示$u$子树内，自下向上的任意一条长度为$i$的LIS的结尾最小值 同理维护$g_{u,i}$，表示$u$子树内自下向上任意一条长度为$i$的LDS结尾最大值 考虑如何贡献答案。树上路径统计无非是在合并子树时考虑合并两条路径 当加入一个新的子树时，会构成两种新LIS： LIS包含$u$，我们只需要使用$u$的权值在归并子树$f$和新子树的$g$上二分、交换$g$和$f$再二分即可 LIS不包含$u$，对于归并子树和新子树的$f$和$g$，挑选规模小的一个枚举每个元素，在另一边二分即可 这一步的复杂度瓶颈在后者，合并一次子树的复杂度是$O(\min(\mid f_u\mid,\mid g_v \mid)\log n)$或者$O(\min(\mid f_v\mid,\mid g_u \mid)\log n)$，使用了启发式思想保证了复杂度 至于合并操作，我们直接暴力将$f_u$和$f_v$取$\min$，将$g_u$和$g_v$取$\max$即可。同样，用规模小的往大的上合并，合并复杂度$O(\min(f,g))$ 我们发现$f_u$或者$g_u$的第二维的有效范围不会超过$u$子树的最大深度。因此$fg$的规模和最大深度相关。我们在合并和统计的时候又运用到了有关最大深度的启发式思路。依此思路我们发现：如果某一个子树在统计时作为被枚举的一方在另一方中二分，那么在合并时它也会被合并到另一方，并且从此之后这个存在就消失了。换句话说，每个$f_u$被作为规模较小的一方枚举，这种情况从始至终最多发生一次，因此每个子树对整体的贡献都恰好是其子树长链长度带个$log$。由此我们保证了总复杂度为$O(n \log n)$ Summary 对于树上问题，如果其在序列版本上有简单、易于考虑的做法，先思考在序列上的做法，再尝试搬到树上 注意如果序列上有多种做法，我们在搬到树上时，要尽可能选择那些可以在树上实现的做法 如果DP时需要记录子树信息，考虑记录信息的规模是否和子树大小或者子树最大深度有关，以此用启发式或者长链剖分的思想保证每个子树对复杂度只贡献一次，达到总贡献次数不超过$n$的结果 不要因为感觉树上的DP开不下就放弃，我们完全可以在树上从下往上一边扫一边合并，以此 来离线求得每一个点的结果 Code 自认为写的很好看的代码（一直被模仿，轻松被超越）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define pb push_backusing namespace std;namespace IO&#123; const int S=10000000; char buf[S]; int pos; void load()&#123; fread(buf,1,S,stdin); pos=0; &#125; char getChar()&#123; return buf[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;typedef vector&lt;int&gt; vi;const int N=200010;const int INF=1e9;int n;int a[N];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];vi f[N],g[N];int ans;inline void updmin(int &amp;x,int y)&#123; x=(y&lt;x?y:x);&#125;inline void updmax(int &amp;x,int y)&#123; x=(y&gt;x?y:x);&#125;void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) a[i]=getInt(); int u,v; for(int i=1;i&lt;n;i++)&#123; u=getInt(); v=getInt(); addEdge(u,v); &#125;&#125;bool cmpR(const int &amp;x,const int &amp;y)&#123; return x&gt;y;&#125;void cross(int u,int v)&#123; // f[u] g[v] int pos; if(f[u].size()&lt;g[v].size())&#123; for(int i=0,sz=f[u].size();i&lt;sz;i++)&#123; pos=lower_bound(g[v].begin(),g[v].end(),f[u][i],cmpR)-g[v].begin(); updmax(ans,(i+1)+pos); &#125; &#125; else&#123; for(int i=0,sz=g[v].size();i&lt;sz;i++)&#123; pos=lower_bound(f[u].begin(),f[u].end(),g[v][i])-f[u].begin(); updmax(ans,(i+1)+pos); &#125; &#125;&#125;void updateAns(int u,int v)&#123; // use u as a point int l1,l2; l1=lower_bound(f[u].begin(),f[u].end(),a[u])-f[u].begin(); l2=lower_bound(g[v].begin(),g[v].end(),a[u],cmpR)-g[v].begin(); updmax(ans,l1+l2+1); l1=lower_bound(f[v].begin(),f[v].end(),a[u])-f[v].begin(); l2=lower_bound(g[u].begin(),g[u].end(),a[u],cmpR)-g[u].begin(); updmax(ans,l1+l2+1); // cross over u cross(u,v); cross(v,u);&#125;void merge(int u,int v)&#123; // u &lt;- v int lu,lv; lu=f[u].size(); lv=f[v].size(); if(lu&gt;=lv) for(int i=0;i&lt;lv;i++) updmin(f[u][i],f[v][i]); else&#123; for(int i=0;i&lt;lu;i++) updmin(f[v][i],f[u][i]); swap(f[u],f[v]); &#125; lu=g[u].size(); lv=g[v].size(); if(lu&gt;=lv) for(int i=0;i&lt;lv;i++) updmax(g[u][i],g[v][i]); else&#123; for(int i=0;i&lt;lu;i++) updmax(g[v][i],g[u][i]); swap(g[u],g[v]); &#125;&#125;void join(int u)&#123; int len,pos; len=f[u].size(); pos=upper_bound(f[u].begin(),f[u].end(),a[u])-f[u].begin(); if(!len||(!pos||a[u]&gt;f[u][pos-1]))&#123; if(pos==len) f[u].pb(INF); f[u][pos]=a[u]; &#125; len=g[u].size(); pos=upper_bound(g[u].begin(),g[u].end(),a[u],cmpR)-g[u].begin(); if(!len||(!pos||a[u]&lt;g[u][pos-1]))&#123; if(pos==len) g[u].pb(-INF); g[u][pos]=a[u]; &#125;&#125;void solve(int u,int fa)&#123; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; solve(v,u); updateAns(u,v); merge(u,v); &#125; join(u);&#125;int main()&#123; IO::load(); readData(); solve(1,0); printf("%d\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>2016北京集训</category>
      </categories>
      <tags>
        <tag>启发式</tag>
        <tag>最长上升子序列</tag>
        <tag>长链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Description 给你一个数组，每个元素都有一个颜色。要求支持两种操作： 修改某个元素的颜色。 询问这个数组有多少个子区间内没有重复的颜色。 （只是为了凑摘要） Solution 【BZOJ4059】是一道类似的题。由于那题是单次询问，所以可以化成平面染色覆盖问题，用扫描线求解 然而本题是动态询问，扫描线一类的东西难以支持实时查询。可是考场上我还是依着这个思路死磕了好一会 打完暴力后，我体会了一下统计答案的方式：对于每一个固定的右端点$i$，其左端点能往左走的最远位置应该是$\max (pre_j\mid 1 \le j \le i )+1$，其中$pre_i$表示上一个和$i​$颜色相同的位置 而答案也就可以表示成： \begin{aligned} Ans&=\sum_{i=1}^n(i-\max\{pre_j\mid 1 \le j \le i\})\\ &=\sum_{i=1}^ni-\sum_{i=1}^n\max\{pre_j\mid 1 \le j \le i\} \end{aligned} 我们只需要专注维护后面一部分的值即可 这个问题要求我们提供一个能够维护每个前缀信息的算法。运用分治思想，我们尝试使用线段树合并两段信息，以达到维护的目的 一个线段树节点$[l,r]$记一个值$sum$，表示 \sum_{i=l}^r\max\{pre_j\mid l \le j \le i\} 即每一个位置到该段左端点的$\max$，之和 叶子节点的$sum$即该位置的$pre$ 下面考虑上推$lc$、$rc$到父节点$u$，计算$u$的$sum$ $sum_{lc}$在新的线段中意义没有改变，我们将其直接加到$sum_u$上 而$sum{rc}$的$\sum$中的每一个元素，都要继续$\max$上$lc$代表线段的各个位置的值，因此当下我们不能直接用$sum{rc}$累加到$sum_u$ 既然$n$的范围是$10^5$，我们完全受得住两个$\log$的算法。对于无法解决的信息，我们不妨使用多一个$\log$，递归右儿子解决 记$d=\max_{lc}$ 递归直接调用$calc(rc)$，设当前递归节点为$u$，左右儿子为$lc$和$rc$，区间为$[l,r]$ 如果$u$的整一段$[l,r]$的$\max$都不超过$d$，这意味着$\sum$中的每一个$\max$最终都会受$d$影响变成后者，因此返回$d * (r-l+1)$ 套路：如果整段不满足，考虑左半边$[l,mid]$是否满足整段的值都不超过$d$ 若满足，则返回$d * (mid-l+1)$加上递归右半边的结果 若不满足，左半边的结果递归计算； 对于右半边的每一个位置，原本它们只$\max$到$mid+1$，现在一直$\max$到$l$ 由于从左往右看，每个位置计算的$\max$单调不减，因此当前的情形恰好为$d&lt;\max{lc}$，也就是右半边元素在往左扩展时，$lc$带来的影响已经大大超过$d$，后者不起作用。至于$d$对应区间的右边一直到$l$左边这段区间的每个位置的值，我们回头考虑递归过程：我们之所以往右递归，是因为左半边影响力都不及$d$，而当下$d$不及$\max{lc}$，更可以忽略它们 因此右半边的贡献其实就是每个元素在$[l,r]$意义下的结果之和：$sumu-sum{lc}$（之所以不用$sum{rc}$，是因为$sum{rc}$计算的是右半边每个元素在$(mid,r]$意义下的结果） 至此我们在$O(n \log ^2 n)$内解决了修改。至于外层的$pre$维护，只需要用set做一下就好了，其复杂度不是瓶颈 Summary 扫描线做法一般只能处理单次总体询问的题目。因此如果题目涉及多次询问，那就换一个角度做吧 对于前缀信息问题或者区间信息问题，如果我们能够支持合并两段信息、或者两段要维护的东西，我们不妨直接用线段树套上这个合并过程来维护全局 这种做法中，分类讨论非常重要 在合并过程中，如果某一半遇到了难以考虑的情况，在时间允许的情况下（多一个$\log$），可以尝试递归并分类处理 线段树套路：若整段ok返回；左段ok的话利用左段信息加上右边递归计算的值；左段不ok就进去递归，并看看能不能直接考虑右段发生了生么变化 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;cstdio&gt;#include &lt;set&gt;#define FR first#define SE secondusing namespace std;namespace IO&#123; const int S=10000000; char buf[S]; int pos; void load()&#123; fread(buf,1,S,stdin); pos=0; &#125; char getChar()&#123; return buf[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;typedef long long ll;const int N=100010;int n;int a[N];int pre[N];set&lt;int&gt; ps[N];inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;namespace SEG&#123; const int S=N*2; int rt,sz; int ch[S][2]; int mxs[S]; ll sum[S]; ll calc(int u,int l,int r,int stdval)&#123; if(mxs[u]&lt;=stdval) return 1ll*stdval*(r-l+1); if(l==r) return sum[u]; int mid=(l+r)&gt;&gt;1; if(mxs[ch[u][0]]&lt;=stdval) return 1ll*stdval*(mid-l+1)+calc(ch[u][1],mid+1,r,stdval); else return calc(ch[u][0],l,mid,stdval)+(sum[u]-sum[ch[u][0]]); &#125; void pushup(int u,int l,int r)&#123; int mid=(l+r)&gt;&gt;1; mxs[u]=max(mxs[ch[u][0]],mxs[ch[u][1]]); sum[u]=sum[ch[u][0]]+calc(ch[u][1],mid+1,r,mxs[ch[u][0]]); &#125; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r)&#123; mxs[u]=sum[u]=pre[l]; return; &#125; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); pushup(u,l,r); &#125; void modify(int u,int l,int r,int pos,int val)&#123; if(l==r)&#123; sum[u]=mxs[u]=val; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modify(ch[u][0],l,mid,pos,val); else modify(ch[u][1],mid+1,r,pos,val); pushup(u,l,r); &#125; ll query()&#123; return 1ll*n*(n+1)/2-sum[rt]; &#125;&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) a[i]=getInt();&#125;void init()&#123; for(int i=1;i&lt;=n;i++) ps[a[i]].insert(i); static int last[N]; for(int i=1;i&lt;=n;i++)&#123; pre[i]=last[a[i]]; last[a[i]]=i; &#125;&#125;void change(int x,int y)&#123; set&lt;int&gt;::iterator pos,mo; pos=ps[a[x]].find(x); pos++; ps[a[x]].erase(x); if(pos!=ps[a[x]].end())&#123; int cur=(*pos); if(pos!=ps[a[x]].begin())&#123; pos--; pre[cur]=(*pos); &#125; else pre[cur]=0; SEG::modify(SEG::rt,1,n,cur,pre[cur]); &#125; a[x]=y; mo=pos=ps[a[x]].insert(x).FR; if(pos==ps[a[x]].begin()) pre[x]=0; else&#123; pos--; pre[x]=(*pos); &#125; SEG::modify(SEG::rt,1,n,x,pre[x]); mo++; if(mo!=ps[a[x]].end())&#123; pre[(*mo)]=x; SEG::modify(SEG::rt,1,n,(*mo),x); &#125;&#125;void answerQuery()&#123; int q,opt,x,y; q=getInt(); while(q--)&#123; opt=getInt(); if(!opt) printf("%lld\n",SEG::query()); else&#123; x=getInt(); y=getInt(); change(x,y); &#125; &#125;&#125;int main()&#123; IO::load(); readData(); init(); SEG::build(SEG::rt,1,n); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>2016北京集训</category>
      </categories>
      <tags>
        <tag>数据结构---线段树</tag>
        <tag>分类讨论</tag>
        <tag>数据结构---维护题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[错位排列]]></title>
    <url>%2F2018%2F09%2F27%2F%E9%94%99%E4%BD%8D%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[Description 考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错位排列。 例如，当n=3时，它有两个错位排列 {3,1,2} 和 {2,3,1} 现在我们想计算n个元素能组成的错位排列的数量，并将答案对m取模。 $T \le 100$ $1 \le n \le 10^9$ $ 1 \le m \le 10^5$ Solution 问题相当于：求有多少由$n$个点构成的环森林没有自环，即没有大小为1的环 想法1 使用容斥，设$f_i$表示至少有$i$个自环时的方案数，则 \begin{aligned} f_i&={n \choose i}(n-i)!\\ &=\frac{n!}{i!} \end{aligned} \\ \begin{aligned} ans&=\sum_{i=0}^n(-1)^if_i \\ &=\sum_{i=0}^n(-1)^i \frac{n!}{i!} \end{aligned} 显然可以直接$O(n)$计算 但是接下来不会做了 我坚持这个想法，尝试优化这个式子。但事实上这个式子已经到了死胡同了： 有正负系数的存在 有无法处理到的阶乘存在 下次看到式子包含奇怪元素、但又已经简洁到不能进一步推导时，提醒自己大方向错了，应该有另一个方向的解法 想法2 我们观察到询问有$100$组数据，$n$为$10^9$，这题怎么看都不是个数论分块题，那单次询问的复杂度还能是什么，很可能是矩阵快速幂的复杂度 于是考虑构造线性递推式： 设$f_n$表示编号为$1…n$的点构成合法环森林的方案数，则易得递推式 f_0=1\\ \begin{aligned} f_n&=(n-1)f_{n-1}+(n-1)f_{n-2}\\ &=(n-1)(f_{n-1}+f_{n-2}) \end{aligned} 前者是将$n$号点并入之前的某个环，而后者是将$n$与$1…n-1$的某个点组合成一个大小为2的新环 接下来使用矩阵乘法加速： A_1= \begin{bmatrix} 1 &0 \end{bmatrix} \\ A_n= \begin{bmatrix} f_{n-1} &f_n \end{bmatrix} \\ T_n=\begin{bmatrix} 0 &n\\ 1 &n \end{bmatrix} \\ A_n=A_1\prod_{i=1}^{n-1}T_i 问题来了，递推式中有一个系数$n-1$与转移次数有关。这意味着转移矩阵$T$不断在变化，怎么做？ 一般情况下，可能做不了（待填）；我们已经换了一个方向，还不对么？这时候我们要回看一次数据范围：给出模数$m$的范围很小！利用模$m$后运算的数字只在$[0,m)$的这个性质，我们再看看原递推式可以做什么转化：乘上去的系数模一个$m$，也就是每$m$次转移的系数是相同的： f_n=((n-1)\mod m)(f_{n-1}+f_{n-2}) 则转移矩阵变成 T_n=\begin{bmatrix} 0 &n\;\text{mod}\;m\\ 1 &n\;\text{mod}\;m \end{bmatrix} 这意味着$Ti=T{km+i}\;(1 \le i \le m,\;k \ge 0)$ 所以在用$\prod$计算$An$时，如果将乘上去的$T$每$m$个分成一组，每组的形式和乘积都是一样的，因此总体可以用$(\prod{i=1}^mT_i)^{\lfloor \frac{n-1}{m}\rfloor}$表示，用乘法+快速幂解决 而余下的$\prod_{i=1}^{(n-1)\;\text{mod}\;m}T_i$直接计算即可 Orz 看起来有10行做法，我太弱了 Summary 此题关键是利用模$m$的性质，成功构造并利用了一个同余模型，将大步快速处理，而余下的小步也在$m$步以内，可以直接处理 遇到极其间接但是含有阶乘等元素，计算复杂度降不下来时，一般是大体方向想偏了。尝试换一个大方向思考（结合数据范围猜测） Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;using namespace std;int n,mod;struct Mat&#123; int n,m; int a[2][2]; Mat()&#123; reset(); &#125; Mat(int _n,int _m)&#123; n=_n; m=_m; reset(); &#125; void reset()&#123; a[0][0]=a[0][1]=a[1][0]=a[1][1]=0; &#125; void setUnit()&#123; a[0][0]=a[1][1]=1; &#125; friend Mat operator * (Mat &amp;u,Mat v)&#123; Mat res(u.n,v.m); for(int i=0;i&lt;u.n;i++) for(int j=0;j&lt;v.m;j++) for(int k=0;k&lt;u.m;k++) (res.a[i][j]+=1ll*u.a[i][k]*v.a[k][j]%mod)%=mod; return res; &#125;&#125;;Mat A,T;void readData()&#123; scanf("%d%d",&amp;n,&amp;mod);&#125;void multi(Mat &amp;s,int l,int r)&#123; static Mat cur(2,2); cur.a[1][0]=1; for(int i=l;i&lt;=r;i++)&#123; cur.a[0][1]=cur.a[1][1]=i; s=s*cur; &#125;&#125;Mat fmi(Mat x,int y)&#123; Mat res(x.n,x.n); res.setUnit(); for(;y;x=x*x,y&gt;&gt;=1) if(y&amp;1) res=res*x; return res;&#125;void solve()&#123; if(n==0)&#123; puts("1"); return; &#125; n--; // A=[f0,f1] A=Mat(1,2); A.a[0][0]=1; A.a[0][1]=0; Mat sum(2,2); sum.setUnit(); if(n/mod)&#123; multi(sum,1,mod-1); multi(sum,0,0); A=A*fmi(sum,n/mod); n%=mod; &#125; multi(A,1,n); int ans=A.a[0][1]; printf("%d\n",ans&lt;0?ans+mod:ans);&#125;int main()&#123; int t; scanf("%d",&amp;t); for(int i=1;i&lt;=t;i++)&#123; printf("Case #%d: ",i); readData(); solve(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DP---计数</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cot]]></title>
    <url>%2F2018%2F09%2F27%2Fcot%2F</url>
    <content type="text"><![CDATA[Description 网格图上有一个直角三角形 操作有两种： 给一个子直角三角形内的每一个整点+1 询问一个子直角三角形内的点值之和 $N \le 10^3,\;\;Q \le 10^5$ Solution 场上想的是用某一种特殊的方式维护三角形，然而由于各种原因行不通。主要是“区间加”这个操作很难实现，因为每一行的操作长度都不一样 然后题解就说往暴力方向想 为了表述方便，以下“直角三角形”都称作“三角形” 询问 询问要求一个三角形的和，考虑使用前缀和解决。假设我们能维护两个前缀和： $rec_{i,j}$表示由$(1,1)$和$(i,j)$组成的矩形内部的值之和 $tri_{i,j}$表示以$(i,j)$作为右下角，往$[135^\circ,180^\circ]$角度延伸的三角形内部的值之和 那么每次查询$(x,y,a)$，答案就是 (tri_{x+a-1,y+a-1}-tri_{x-1,y-1})-(rec_{x+a-1,y-1}-rec_{x-1,y-1})修改 考虑修改如何实现。最暴力的修改方法显然，接下来是优化： 如果直接更新两个前缀和数组，非常难考虑；但如果直接更新每一个整点的值，再重新计算两个前缀和数组，单次复杂度又是$O(n^2)$的 我们还有一个操作保底：对于每个询问，枚举每一个之前的操作对这个询问的影响，即求一个三角形的交集，单次枚举复杂度为$O(1)$ 考虑分块综合上述操作加速。这可能是一个神秘的套路，慢慢体会： 设一个块大小$B$，将修改操作按$B$分块 每次堆积到$B$个修改时，我们把这$B$个修改一次性$O(n^2)$推入两个前缀和数组，表示历史所有块的前缀和；如果当下剩余的修改次数未到达$B$，我们暂且不将这些修改推进两个前缀和数组中 对于查询，先使用前缀和数组计算出历史块的答案；再枚举每个未推入前缀和数组的修改，依次单独考虑影响 这样总体复杂度就降为了$O(\frac Q BK+QB)$，其中$K$是将$B$个操作推入前缀和数组的复杂度 关键思路是：由于加入复杂度过高，而直接一一考虑复杂度极低，于是我们存储一段修改再加入，未加入的修改直接一一考虑对询问的影响。这样就平衡了两种操作的复杂度 接下来是如何加入存储的一堆修改 对于一个三角形$(x,y,a)$，我们希望内部都+1。对于每一行，维护一个这个+1标记的差分：假设在$n^2$扫描时扫到了这个三角形的某一行$i$，我们在$y$这个位置打上+1标记，在$y+(i-x)+1$这个位置打上-1标记。这样，对于每一行使用一个标记累加器$sum+=tag{i,j}$，然后使当前位置的值$a{i,j}+=sum$即可 但这意味着我们单次修改打标记有$O(n)$的复杂度，$K=O(nB+n^2)$还不够快 我们发现这个+1标记是某一条竖着的线段，-1标记是某一条斜着的线段。于是，我们再维护每一列的差分和每一斜的差分，来控制每一个位置的标记即可。单次修改复杂度降为$O(1)$，而两层标记的维护都可以在$O(n^2)$的扫描种同步完成 那么将$B$个操作推入历史块前缀和的复杂度就是$K=O(n^2+B)$了 Summary 修改复杂度高、单独考虑复杂度低，而修改可以批量处理时，考虑按操作分块处理 非常规形状求和问题，要尝试用基本图形极其前缀和法容斥出来，而不要老是想着空造一种可以支持这种形状的数据结构（当然，也要想一想） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;cstdio&gt;using namespace std;typedef long long ll;namespace IO&#123; const int L=10000000; char in_buf[L],out_buf[L]; int in_pos,out_pos; void load()&#123; fread(in_buf,1,L,stdin); in_pos=0; &#125; void flush()&#123; fwrite(out_buf,1,out_pos,stdout); &#125; char getChar()&#123; return in_buf[in_pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; void writeChar(char c)&#123; out_buf[out_pos++]=c; &#125; void writeInt(ll x,char endc='\n')&#123; static int sta[20],top; if(!x) writeChar('0'); else&#123; for(top=0;x;x/=10) sta[++top]=x%10; for(;top;top--) writeChar('0'+sta[top]); &#125; writeChar(endc); &#125;&#125;using IO::getInt;using IO::writeInt;const int N=1010;const int B=2000;int n,q;ll rec[N][N],tri[N][N];ll inc[N][N],dec[N][N],tag[N][N];ll sum[N][N];int his[B+5][3],cnt;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void mergeBlock()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=i;j++)&#123; inc[i][j]+=inc[i-1][j]; dec[i][j]+=dec[i-1][j-1]; tag[i][j]=tag[i][j-1]+inc[i][j]+dec[i][j]; sum[i][j]+=tag[i][j]; rec[i][j]=rec[i-1][j]+rec[i][j-1]-rec[i-1][j-1]+sum[i][j]; tri[i][j]=tri[i-1][j-1]+(rec[i][j-1]-rec[i-1][j-1])+sum[i][j]; &#125; rec[i][i+1]=rec[i][i]; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) inc[i][j]=dec[i][j]=0;&#125;void addTri(int x,int y,int a)&#123; cnt++; his[cnt][0]=x; his[cnt][1]=y; his[cnt][2]=a; inc[x][y]++; inc[x+a][y]--; dec[x][y+1]--; dec[x+a][y+a+1]++;&#125;int queryInfluence(int x1,int y1,int a1,int x2,int y2,int a2)&#123; int low=min(x1+a1-1,x2+a2-1); int lef=max(y1,y2); int hei=max(x1-y1,x2-y2); int len=low-lef-hei+1; return len&gt;0?(len*(len+1)&gt;&gt;1):0;&#125;ll queryTri(int x,int y,int a)&#123; ll res=(tri[x+a-1][y+a-1]-tri[x-1][y-1])-(rec[x+a-1][y-1]-rec[x-1][y-1]); for(int i=1;i&lt;=cnt;i++) res+=queryInfluence(x,y,a,his[i][0],his[i][1],his[i][2]); return res;&#125;void answerQuery()&#123; n=getInt(); q=getInt(); int opt,x,y,a; int mergeTimer=0; while(q--)&#123; opt=getInt(); x=getInt(); y=getInt(); a=getInt(); if(opt==1)&#123; addTri(x,y,a); mergeTimer++; if(mergeTimer==B)&#123; mergeBlock(); mergeTimer=0; cnt=0; &#125; &#125; else writeInt(queryTri(x,y,a)); &#125;&#125;int main()&#123; IO::load(); answerQuery(); IO::flush(); return 0;&#125;]]></content>
      <categories>
        <category>2016北京集训</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【HDU5794】A Simple Chess]]></title>
    <url>%2F2018%2F09%2F25%2Fhdu5794-asimplechess%2F</url>
    <content type="text"><![CDATA[Description 原题链接 从$(1,1)$走到$(n,m)$，每次只能往右上方走“日”字对角 某一些点不可走 求方案数？ Solution 联想一道题：BZOJ3782，做法几乎一样 先假设我们有一个函数$s(x,y)$，表示从$(0,0)$走到$(x,y)$有多少种走法 设$f_a$表示从$(1,1)$走到第$a$个障碍物处，中途不经过其他障碍物的走法方案数 考虑容斥。从全集里面扣去不合法的路径 全集为$s(a_x-1,a_y-1)$ 对于任意一条不合法的路径，我们都要找到一个唯一确定的特征，用那个特征来统计 我们运用最小表示法，枚举每一个障碍点$b$，删去那些以$b$作为第一个碰到的障碍物的不合法路径。也就是先不碰其他障碍走到$b$，再肆无忌惮地走到$a$ 则有 f_a=s(a_x-1,a_y-1)-\sum_{b}f_b * s(b_x-a_x,b_y-a_y) 下面关键是如何实现$s(d_x,d_y)$这个函数 考虑每一步，都是在某一个方向推进2格，另一个方向推进1格。设一共在$x$上走了$n_x$步，在$y$上走了$n_y$步，则 \begin{aligned} 2n_x+n_y&=d_x\\ 2n_y+n_x&=d_y \end{aligned} 不妨设$d_x\ge d_y$（否则可以交换二者，这一步是为了尽可能排除潜在的负数），解二元方程组得： \begin{aligned} n_x&=\frac{2d_x-d_y}{3}\\ n_y&=d_x-2n_x \end{aligned} 在解方程的过程中，我们发现如果当前计算的情况有解，那么局面必须满足$d_x+d_y\mod3=0$ 同时，最终计算出来的$n_x$和$n_y$都不能为负数 现在我们得知了往各个方向走2格的次数。此时问题又变成了经典的走格子计数，方案数为${n_x+n_y\choose n_x}$ Summary 非常规走格子问题，不一定完全是一套新的解法；解一个方程或者思考一下，说不定它能转化成常规走格子问题解决 Code 假装自己过了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=110;const int MOD=110119;ll n,m;int o;struct Point&#123; ll x,y;&#125;;Point a[N];int f[N];int fact[MOD],iact[MOD];int fmi(int x,int y)&#123; int res=1; for(;y;x=1ll*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1ll*res*x%MOD; return res;&#125;void readData()&#123; scanf("%lld%lld%d",&amp;n,&amp;m,&amp;o); for(int i=1;i&lt;=o;i++) scanf("%lld%lld",&amp;a[i].x,&amp;a[i].y);&#125;void init()&#123; fact[0]=fact[1]=1; for(int i=2;i&lt;MOD;i++) fact[i]=1ll*fact[i-1]*i%MOD; iact[0]=iact[1]=1; iact[MOD-1]=fmi(fact[MOD-1],MOD-2); for(int i=MOD-2;i&gt;=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;&#125;int C(ll n,ll m)&#123; if(m&gt;n) return 0; if(n&lt;MOD) return 1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD; return 1ll*C(n/MOD,m/MOD)*C(n%MOD,m%MOD)%MOD;&#125;int calc(ll dx,ll dy)&#123; if((dx+dy)%3!=0) return 0; if(dx&lt;dy) swap(dx,dy); ll nx=(2*dx-dy)/3,ny=dx-2*nx; if(nx&lt;0||ny&lt;0) return 0; return C(nx+ny,nx);&#125;bool cmpByRectGo(const Point &amp;a,const Point &amp;b)&#123; if(a.x!=b.x) return a.x&lt;b.x; return a.y&lt;b.y;&#125;void solve()&#123; a[++o]=(Point)&#123;n,m&#125;; sort(a+1,a+1+o,cmpByRectGo); for(int i=1;i&lt;=o;i++)&#123; f[i]=calc(a[i].x-1,a[i].y-1); for(int j=1;j&lt;i;j++) if(a[j].x&lt;=a[i].x&amp;&amp;a[j].y&lt;=a[i].y) (f[i]-=1ll*f[j]*calc(a[i].x-a[j].x,a[i].y-a[j].y)%MOD)%=MOD; &#125; printf("%d\n",f[o]&lt;0?f[o]+MOD:f[o]);&#125;int main()&#123; readData(); init(); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>数论---Lucas定理</tag>
        <tag>DP---计数</tag>
        <tag>最小表示法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC011E】Increasing Number]]></title>
    <url>%2F2018%2F09%2F25%2Fagc011_e_increasing_number%2F</url>
    <content type="text"><![CDATA[Description 如果一个十进制非负整数的所有数位从高位到低位是不减的，我们称它为“上升数”，例如$1558,11,3,0$都是上升数，而$10,20170312$则不是 给定整数$N$，求最小的$k$使得$N$能被表示为$k$个上升数之和 $1 \le N \le 10^{50000}$ Solution 题目让我们把$N$拆分成尽可能少的上升数之和 注意到上升数之和并没有什么可以深究的地方，因此我们应该转而研究上升数本身 观察上升数的构成，它的每个数位随着数位的降低而不降。这启发我们：如果对于一个上升数，把每个数位的数看成该位置的高度，整个数看起来就像是一个右斜的金字塔 而且金字塔的高度不会超过9 那么每个上升数，不就是9个数位全为1的数之和么？ 我们称由$k$个$1$组成的数为$f_k$。特别地，$f_0=0$。我们有通项公式 f_i=\frac{10^i-1}{9} 则每个上升数可以表示成$\sum{i=1}^9f{a_i}\;\;\;(0\le a_i)$ 考虑答案为$k$时，$k$个上升数组成了$N$。我们发现了一个等式，等式通过转化经常能发现玄机。我们把它写出来： \begin{aligned} N&=\sum_{i=1}^k\sum_{j=1}^9f_{a_{i,j}}\\ &=\sum_{i=1}^k\sum_{j=1}^9\frac{10^{a_{i,j}}-1}{9}\\ 9N+9k&=\sum_{i=1}^k\sum_{j=1}^910^{a_{i,j}}\\ 9N+9k&=\sum_{i=1}^{9k}10^{b_i} \end{aligned} 倒数第二步时，我们发现这两个求和，等价于$9k$次单独操作，因此将$a_{i,j}$展平成$b_i$，问题等价 这是什么意思呢？右边和式每加一个项，相当于和的某一位+1 那么加$9k$次，等价于这个数数位之和恰好等于$9k$ 那么问题变成，寻找最小的$k$，使得$9N+9k$的数位之和等于$9k$ 注意到第一步我们表示上升数时，$a_i$可以取到0，这意味着表示每个上升数所需的$f$小于等于$9$ 将概念顺移下来，判定条件就会变成：$9N+9k$的位数只要不超过$9k$即可 使用高精度模拟枚举$k$从1开始往上走的过程。每次对$9N$这个数加上9，时间复杂度均摊$O(1)$。可以证明，当$k$超过$N$的位数时，等式就不可能成立了。因此枚举的上界也有保证。总复杂度为$O(n)$ Summary 若题目给出一个具有某种特征的元素，除了知道它的特征是什么以外，我们还要深究其特殊在什么地方、是否能用奇怪方式构造出来，而不能总停留在第一步，只从“特征”方面入手考虑 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N=10000050;int a[N];int dsum;void readData()&#123; static char inp[N]; scanf("%s",inp+1); a[0]=strlen(inp+1); for(int i=1;i&lt;=a[0];i++) a[i]=inp[a[0]-i+1]-'0';&#125;void multiply(int x)&#123; int k=0; for(int i=1;i&lt;=a[0];i++)&#123; a[i]=x*a[i]+k; k=a[i]/10; a[i]%=10; &#125; while(k)&#123; a[++a[0]]=k%10; k/=10; &#125;&#125;void plus(int x)&#123; int k=0; for(int i=1;i&lt;=a[0];i++)&#123; dsum-=a[i]; a[i]=a[i]+(i==1?x:0)+k; k=a[i]/10; a[i]%=10; dsum+=a[i]; if(!k) return; &#125; while(k)&#123; a[++a[0]]=k%10; k/=10; dsum+=a[a[0]]; &#125;&#125;int solve()&#123; for(int i=1;i&lt;=a[0];i++) dsum+=a[i]; for(int k=1;;k++)&#123; plus(9); if(dsum&lt;=9*k) return k; &#125;&#125;int main()&#123; readData(); multiply(9); printf("%d\n",solve()); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ1014】火星人]]></title>
    <url>%2F2018%2F09%2F25%2F%5BBZOJ1014%5D%E7%81%AB%E6%98%9F%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[Description 题目链接 大意是给一个字符串，支持单点修改字符、插入一个字符，以及询问两个后缀的LCP Solution 为什么我想半天想不到呢？因为我总想着用后缀数组的思想去维护了。一上场就去想后缀平衡树之类的东西、想怎么维护一段字符的排名，等等等等 既然这样往后缀数组的方向想行不通，那么我们要从LCP的匹配来考虑 直接枚举肯定是不行的，那么就采用倍增（然后我就想到了什么波兰表的历史记录） 倍增什么啊，那是静态的 应该用二分，二分LCP的长度 然后每次我们只要能快速判定两端长度相同的字符串是否相等，那么就解决了这个问题 遇到这种字符串比较是否相等的情况，我们应该第一反应想到哈希，不要犹豫太多 那么用平衡树维护字符串的哈希值：插入和修改都不难，查询时二分，并查询一段字符的哈希值，判断是否相等即可 Summary 自己的哈希意识太过薄弱，总往后缀数组方面想；字符串匹配问题，要么后缀数组/SAM，要么往哈希想一下。看到题后，两个方法都要过一遍 如果题目的操作十分复杂、显然不能用后缀数组的那一套思想进行维护时，不妨考虑哈希，将问题转化为判断两段子串是否相等的子问题，使用平衡树等数据结构支持快速回答，以此间接解决询问 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include &lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=100010;const ull B=133;char str[N];int n,curn;ull bas[N];inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;namespace T&#123; int rt,sz,dest; int ch[N][2],fa[N]; int size[N],key[N]; ull sum[N]; inline int who(int u)&#123; return ch[fa[u]][1]==u; &#125; inline void pushup(int u)&#123; size[u]=size[ch[u][0]]+size[ch[u][1]]+1; sum[u]=sum[ch[u][0]]+bas[size[ch[u][0]]]*key[u]+bas[size[ch[u][0]]+1]*sum[ch[u][1]]; &#125; inline void rotate(int u)&#123; int f=fa[u],g=fa[f],c=who(u); if(g) ch[g][who(f)]=u; fa[u]=g; ch[f][c]=ch[u][c^1]; if(ch[f][c]) fa[ch[f][c]]=f; ch[u][c^1]=f; fa[f]=u; pushup(f); pushup(u); &#125; void splay(int u,int destfa=0)&#123; for(;fa[u]!=destfa;rotate(u)) if(fa[fa[u]]!=destfa) rotate(who(u)==who(fa[u])?fa[u]:u); if(!destfa) rt=u; &#125; void _insert(int &amp;u,int f,int pos,int val)&#123; // insert before pos if(!u)&#123; u=++sz; dest=u; fa[u]=f; size[u]=1; key[u]=val; pushup(u); return; &#125; if(pos&lt;=size[ch[u][0]]+1) _insert(ch[u][0],u,pos,val); else _insert(ch[u][1],u,pos-(size[ch[u][0]]+1),val); pushup(u); &#125; void insert(int pos,int val)&#123; _insert(rt,0,pos,val); splay(dest); &#125; void _modify(int &amp;u,int pos,int val)&#123; if(size[ch[u][0]]+1==pos)&#123; dest=u; key[u]=val; pushup(u); return; &#125; if(pos&lt;=size[ch[u][0]]) _modify(ch[u][0],pos,val); else _modify(ch[u][1],pos-(size[ch[u][0]]+1),val); pushup(u); &#125; void modify(int pos,int val)&#123; _modify(rt,pos,val); splay(dest); &#125; void _findByPos(int &amp;u,int pos)&#123; if(size[ch[u][0]]+1==pos)&#123; dest=u; return; &#125; if(pos&lt;=size[ch[u][0]]) _findByPos(ch[u][0],pos); else _findByPos(ch[u][1],pos-(size[ch[u][0]]+1)); &#125; int findByPos(int pos)&#123; _findByPos(rt,pos); splay(dest); return dest; &#125; ull query(int l,int r)&#123; if(l==1&amp;&amp;r==size[rt]) // [1,curn] return sum[rt]; if(l==1)&#123; int rr=findByPos(r+1); splay(rr); return sum[ch[rt][0]]; &#125; else if(r==size[rt])&#123; int ll=findByPos(l-1); splay(ll); return sum[ch[rt][1]]; &#125; int ll=findByPos(l-1),rr=findByPos(r+1); splay(ll); splay(rr,ll); return sum[ch[rr][0]]; &#125;&#125;void readData()&#123; scanf("%s",str+1); n=strlen(str+1);&#125;void initBas()&#123; bas[0]=1; for(int i=1;i&lt;=100000;i++) bas[i]=bas[i-1]*B;&#125;void buildSplay()&#123; for(int i=1;i&lt;=n;i++) T::insert(i,str[i]-'a'+1);&#125;int query(int a,int b)&#123; if(a&gt;b) swap(a,b); int l=1,r=curn-b+1,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(T::query(a,a+mid-1)==T::query(b,b+mid-1)) l=mid+1; else r=mid-1; &#125; return r;&#125;void answerQuery()&#123; curn=n; char opt[2]; int q,a,b; scanf("%d",&amp;q); while(q--)&#123; scanf("%s",opt); if(opt[0]=='Q')&#123; scanf("%d%d",&amp;a,&amp;b); printf("%d\n",query(a,b)); &#125; else if(opt[0]=='R')&#123; scanf("%d%s",&amp;a,opt); T::modify(a,opt[0]-'a'+1); &#125; else&#123; scanf("%d%s",&amp;a,opt); T::insert(a+1,opt[0]-'a'+1); curn++; &#125; &#125;&#125;int main()&#123; readData(); initBas(); buildSplay(); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>字符串---哈希</tag>
        <tag>数据结构---平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【NOIP2017】逛公园]]></title>
    <url>%2F2018%2F09%2F22%2F%5Bnoip2017%5D%E9%80%9B%E5%85%AC%E5%9B%AD%2F</url>
    <content type="text"><![CDATA[Description 题目链接 在一张有向图上，求$1$到$n$有多少条路径，满足其长度不超过$1$到$n$的最短路长度加上$K$ $1 \le n \le 10^5\;\;\;\;0 \le K \le 50$ Solution 一年了，才回来补坑 首先肯定是把最短路先算出来（用SPFA已经心有余悸了，不过真香） 考虑到$K$很小，整道题又是计数题，因此考虑设计一个有关$K$的计数DP DP的第一维是点的编号，这是必须的；考虑第二维，其应该和已走距离相关，然而却我们记录不下真实走过的长度。由于我们考虑的路径长度范围都在[最短路,最短路+$K$]这个范围，因此我们可以考虑记录走过路径相对于最短路增加了多少 设$f_{u,x}$表示：从$1$出发走到$u$的路径中，有多少条的长度不超过$dis_u+x$。其中$dis_u$表示$1$到$u$的最短路长度 考虑$f{u,x}$的转移来源：我们考虑的任意一条$f{u,x}$表示的路径，都应该从某一个点走过来。因此我们枚举有向边$(v,u,w)$，可以得到如下式子： f_{1,0}=1\\ f_{u,x}=\sum_{(v,u,w)\in E}f_{v,trans(u,v,x,w)}[0 \le trans(u,v,x,w)\le K]\\trans(u,v,x,w)=dis_u+x-w-dis_v\\ ans=\sum_{x=0}^Kf_{n,x} 到目前为止，我们感觉无从下手。感性的理解一下，会不会出现循环转移，即自己调用自己的情况呢？其实是不会的。如果从$f{n,x}$依转移来源往下搜索，那么我们其实是在反向走一条路径；将第二维表示的相对路径长度转成绝对路径来看，它在这个过程中不断减小。也就是说，即使在搜索$f{n,x}$时多次访问到了$f_{n}$，在先不考虑零环的情况下，第二维肯定会减少。因此搜索是有界的。 既然提到了搜索，又无循环，我们自然而然地就使用记忆化搜索完成这个$f$的计算。 上述做法已经足以应付无零环的情况了；而有零环的做法又有什么区别呢？ 如果我们在搜索的时候，搜索到了一个已经在搜索栈中的状态，这说明我们找到了一个在从$1$走到$n$的过程中能走到的零环，直接判无解。 还有另一种特殊情况，其在良心样例中已经给出。即零环套在$1$号点上。这会有什么问题呢？我们记忆化搜索前，已经为$f_{1,0}$赋定了初值。在搜索时一遇到就会直接返回1，甚至可能没有走完可能存在的零环。这意味着我们的“二次入栈”判定方法不再有效。实际上，我们可以在一开始的spfa中判掉这种情况，详情参见代码 Summary 状态的设置不一定要是绝对，还可以用相对的思想 设置状态时多用排除法，确定哪一维的元素是必要的 如果转移有界、方式复杂，考虑记忆化搜索 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=100010,M=200010,K=55;const int INF=1e9;int n,m,o,mod;int h1[N],h2[N],tot;struct Edge&#123; int v,w,next;&#125;e[M*2];deque&lt;int&gt; q;int dis[N];bool inq[N];int f[N][K];bool ins[N][K];void addEdge(int u,int v,int w)&#123; e[++tot]=(Edge)&#123;v,w,h1[u]&#125;; h1[u]=tot; e[++tot]=(Edge)&#123;u,w,h2[v]&#125;; h2[v]=tot;&#125;void reset()&#123; tot=0; for(int i=1;i&lt;=n;i++) h1[i]=h2[i]=0;&#125;void readData()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;o,&amp;mod); int u,v,w; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addEdge(u,v,w); &#125;&#125;void spfa()&#123; while(!q.empty()) q.pop_front(); for(int i=1;i&lt;=n;i++)&#123; dis[i]=INF; inq[i]=false; &#125; q.push_front(1); dis[1]=0; inq[1]=true; while(!q.empty())&#123; int u=q.front(); q.pop_front(); inq[u]=false; for(int i=h1[u],v;i;i=e[i].next)&#123; v=e[i].v; if(v==1&amp;&amp;dis[u]+e[i].w==0) // 判零环套在1号点的情况 throw 0; if(dis[v]&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if(!inq[v])&#123; if(q.empty()||dis[v]&lt;dis[q.front()]) q.push_front(v); else q.push_back(v); inq[v]=true; &#125; &#125; &#125; &#125;&#125;int search_dfs(int u,int x)&#123; if(f[u][x]!=-1) return f[u][x]; if(ins[u][x]) throw 0; ins[u][x]=true; int res=0,nx; for(int i=h2[u],v,w;i;i=e[i].next)&#123; v=e[i].v; w=e[i].w; nx=dis[u]+x-w-dis[v]; if(0&lt;=nx&amp;&amp;nx&lt;=o) (res+=search_dfs(v,nx))%=mod; &#125; ins[u][x]=false; f[u][x]=res; return res;&#125;void solve()&#123; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=o;j++)&#123; f[i][j]=-1; ins[i][j]=false; &#125; f[1][0]=1; int ans=0; for(int i=0;i&lt;=o;i++) (ans+=search_dfs(n,i))%=mod; printf("%d\n",ans);&#125;int main()&#123; int cases; scanf("%d",&amp;cases); while(cases--)&#123; reset(); readData(); try&#123; spfa(); solve(); &#125; catch(int e)&#123; puts("-1"); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Triangle]]></title>
    <url>%2F2018%2F09%2F22%2FTriangle%2F</url>
    <content type="text"><![CDATA[Description 给一棵$n$个点的树，每条边附有边权$w$ 现有$q$个询问。每个询问给出一个点对$(a,b)$，求对于其路径上的所有边，是否存在三条边可以构成三角形 $ 1 \le q,n \le 10^5\;\; 1 \le w \le 10^9$ Solution 一开始直接写了个维护路径3个最大值的算法，显然是错的，随手卡掉 考虑正确暴力：将所有边权拿出来排序存进一个数组$a$，判断是否存在一个$i$满足$ai+a{i+1}&gt;a_{i+2}$即可 对于三角形存在性问题，这样贪心显然是正确的，每次选择“最大”的两条边，然后看看它们的和是否超过最小的一个比它们大的边 复杂度太高了，怎么办？ 如果数据想卡这种贪心方法，那么每次都要满足$a{i}+a{i+1}\le a_{i+2}$ 我们发现这种递增方式的下界恰好是斐波那契数列 想到斐波那契数列的增长速度之快，再联想到$w$的权值不超过$10^9$，我们发现这种卡法至多只能卡到大约$i=45$的位置。一旦超过了45，这种构造法就无法进行，必定会出现有解的情况 也就是说，如果同一次询问考虑的边数如果超过了45，那么必定有解。如果边数少于45，那么我们可以直接暴力做：拿出来排序扫描即可 Summary 对于两者之和大于第三者的题目，不妨尝试观察其下界是否为斐波那契数列，就可以考虑是否能对规模较大的问题直接出解、规模较小的问题直接暴力 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=100010;const int S=45;const int INF=1e9;int n;int h[N],tot;struct Edge&#123; int v,w,next;&#125;e[N*2];int dep[N],pre[N],faw[N];inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;void addEdge(int u,int v,int w)&#123; e[++tot]=(Edge)&#123;v,w,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,w,h[v]&#125;; h[v]=tot;&#125;void reset()&#123; tot=0; for(int i=1;i&lt;=n;i++) h[i]=0;&#125;void readData()&#123; scanf("%d",&amp;n); int u,v,w; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addEdge(u,v,w); &#125;&#125;void build_dfs(int u,int fa)&#123; pre[u]=fa; dep[u]=dep[fa]+1; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; faw[v]=e[i].w; build_dfs(v,u); &#125;&#125;bool queryPath(int a,int b)&#123; static int s[100],cnt; cnt=0; while(a!=b&amp;&amp;cnt&lt;S)&#123; if(dep[a]&lt;dep[b]) swap(a,b); s[++cnt]=faw[a]; a=pre[a]; &#125; if(cnt&gt;=S) return true; sort(s+1,s+1+cnt); for(int i=1;i&lt;=cnt-2;i++) if(s[i]+s[i+1]&gt;s[i+2]) return true; return false;&#125;void answerQuery()&#123; int q,a,b; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d",&amp;a,&amp;b); puts(queryPath(a,b)?"Yes":"No"); &#125;&#125;int main()&#123; int cases; scanf("%d",&amp;cases); for(int i=1;i&lt;=cases;i++)&#123; printf("Case #%d:\n",i); reset(); readData(); build_dfs(1,0); answerQuery(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>斐波那契数列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小割树]]></title>
    <url>%2F2018%2F09%2F22%2F%E6%9C%80%E5%B0%8F%E5%89%B2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[问题 现在有一个$n$个点的无向图，内含$m$条带权边 断开一条边的代价为其边权 我们希望对于每一个无序点对$(u,v)$，计算出至少要花费多少代价，才能使二者不互通 $n \le 100$ 暴力做法 枚举点对，并直接跑网络流 复杂度上界$\mathcal O(n^4m)$ 这个复杂度显然是不行的 最小割树目标 根据相关定理，我们可以构造出一棵树，满足： 这棵树有$n$个点 每一条树边都有一个边权 $(u,v)$的最小割，等于最小割树上$u$到$v$路径上的最小值 构建方法 初始时，先构造一棵菊花树，令1号点为树根，其余点的父亲都为1号点 从2~n枚举每一个点$i$，计算$i$到父亲$pre_i$的最小割，其值记为$f$。此时$i$的父亲已经固定下来，连边$(pre_i,i,f)$ 对于任意一个点$j$（$j&gt;i$），若$j$的父亲与$i$的父亲相同，且在计算$f$时，$j$与$i$在同一割集中，则将$j$的父亲设为$i$ 回到步骤2. 12345678910111213// 主流程代码void buildMincutTree()&#123; for(int i=1;i&lt;=n;i++) pre[i]=1; for(int i=2;i&lt;=n;i++)&#123; int f=getMincut(i,pre[i]); addEdge(pre[i],i,f); for(int j=i+1;j&lt;=n;j++) if(pre[j]==pre[i]&amp;&amp;Flow::dis[j]!=-1) // j与i在同一割集中（体现为距离标号不为空） pre[j]=i; &#125; initDoubly(); // 处理树上倍增&#125; 最终，我们会得到一棵带边权的树 查询也就变得十分容易，只需要使用倍增维护路径边权最小值即可 复杂度 根据算法流程，我们只会执行恰好$n$次网络流 由于每一次网络流都是在整张图上计算的，如果不排除奇妙因素导致计算范围缩减，其上界仍然是$\mathcal O(n^2m)$ 因此总复杂度大约是$\mathcal O(n^3m)$ 关于正确性证明 可能需要ORZ其他题解，在这里先放上链接 先暂时当一个黑箱使用吧 证明1 证明2]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>网络流---最小割树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC072F】DAM]]></title>
    <url>%2F2018%2F09%2F20%2Farc072_f-Dam%2F</url>
    <content type="text"><![CDATA[Description​ 题目链接 Solution 场上推了个$n^2$式子，但是并没有什么用 考虑最特殊的情况——水温随着时间推进单调不减，那么对于每一个$i$计算答案时，显然是取最靠后的、总和为$L$的几份水混合在一起最优，而之前的全部放掉。这一点很像滑动窗口，我们用单调队列维护，使得对于队列内记录的水，其体积总和为$L$。 接下来是普遍情况：水温有增有减。如果新加的水水温高于队尾，直接加入即可；若低于队尾，根据规则，不管怎样这一份冷水都要混合进来，按照贪心策略，我们应该使用也只能使用队尾较热的水与新的冷水混合，直到队列满足不减为止。此时每一份水不再对应特定的一天，而是连续一段日期的水的最佳混合体 混合完成后，从队头弹出多余的水即可。我们发现，使用单调队列可以消除掉“当前是否要留多一点水，以防后续补不到$L$”这一决策，因为当我们考虑每一个位置的答案时，我们记录了选择的水的历史，可以主动地弹出多余部分，而不是死缠于后效性上。 Summary 不显然的贪心，先从最棒的情况考虑（单增单减等） 如果后效性影响的范围是固定的，不妨记录下每个时刻向前看该范围的所有状态 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;const int N=500005;const double EPS=1e-6;int n,m;int a[N],b[N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i],&amp;b[i]);&#125;struct Water&#123; double t,v;&#125;;void simulate()&#123; printf("%.10lf\n",(double)a[1]); static Water q[N]; int head,tail; double sumv,sumtv; q[head=tail=1]=(Water)&#123;a[1],b[1]&#125;; sumv=b[1]; sumtv=(double)a[1]*b[1]; for(int i=2;i&lt;=n;i++)&#123; Water s=(Water)&#123;a[i],b[i]&#125;; sumtv+=s.t*s.v; sumv+=s.v; while(sumv&gt;m)&#123; double part=min(sumv-m,q[head].v); sumv-=part; sumtv-=1ll*part*q[head].t; q[head].v-=part; if(fabs(q[head].v)&lt;EPS) head++; &#125; sumv-=s.v; sumtv-=s.t*s.v; while(head&lt;=tail&amp;&amp;q[tail].t&gt;=s.t)&#123; sumv-=q[tail].v; sumtv-=q[tail].t*q[tail].v; s.t=(double)(s.t*s.v+q[tail].t*q[tail].v)/(s.v+q[tail].v); s.v+=q[tail].v; tail--; &#125; q[++tail]=s; sumtv+=s.t*s.v; sumv+=s.v; printf("%.10lf\n",sumtv/sumv); &#125;&#125;int main()&#123; readData(); simulate(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC081F】Flip and Rectangles]]></title>
    <url>%2F2018%2F09%2F20%2Farc081_f%2F</url>
    <content type="text"><![CDATA[Description 题目链接 给一个01矩阵，可以对一行反色、一列反色，求最终0构成的单一矩阵的最大面积 Solution 猜不到结论，根本没法做 结论是：如果一个2x2的格子的0的个数是偶数，那么其一定能够变成全0。从数据范围反推，既然是n方的题目，又是这种构造最大同色矩阵，猜想是否能转化为较小的元素的操作 那么问题变成：给一个矩阵，已知以某一些点作为左上角的2x2矩阵是黑色的，求最大黑色矩形面积？ 直接做无从下手，我们至少要确定一个枚举方向：枚举矩阵的下底边是哪一行。既然数据为n方，那么这里肯定有优化，大概就是单调栈之类的。我们可以计算出每一个位置往上可以扩展出多少个黑色的2x2，记为$h$。我们从左往右枚举矩形的右下角，维护一个$h$的单增栈。如果新加入的$h$不足以影响栈的情况，那么显然在接下来枚举时枚举到的右下角再来考虑前面的这些点作为左端点的情况更优；如果新加入的$h$弹出了某一些元素，那么就那自己和那个元素分别作为左右边界更新答案 Summary 遇到这种最大矩形问题，应该要想到使用单调栈$O(n)$贴着一条边扫描并计算最大值的方法 Code​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;using namespace std;const int N=2005;int n,m;int a[N][N];int l[N][N];int sta[N],top;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); static char map[N]; for(int i=1;i&lt;=n;i++)&#123; scanf("%s",map+1); for(int j=1;j&lt;=m;j++) a[i][j]=(map[j]=='#'); &#125;&#125;void calc()&#123; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;m;j++) if(((a[i][j]+a[i+1][j]+a[i][j+1]+a[i+1][j+1])&amp;1)==0) l[i][j]=l[i-1][j]+1;&#125;void solve()&#123; int ans=max(n,m); for(int i=1;i&lt;n;i++)&#123; top=0; for(int j=1;j&lt;=m;j++)&#123; while(top&amp;&amp;l[i][sta[top]]&gt;=l[i][j])&#123; ans=max(ans,(j-sta[top-1])*(l[i][sta[top]]+1)); top--; &#125; sta[++top]=j; &#125; &#125; printf("%d\n",ans);&#125;int main()&#123; readData(); calc(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>结论题</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC082】Sandglass]]></title>
    <url>%2F2018%2F09%2F19%2Farc082_Sandglass%2F</url>
    <content type="text"><![CDATA[Description​ 题目链接 Solution 好题 题意是维护一个初始值，交替加减一段时间，有上界$m$和下界0（不能超过这两条界限），问对于某一种初始值，在某一个时刻时该值为多少？ 可以把所有询问按时间排序成一列，然后用线段树区间加减、区间min、max暴力实现，然而我不会做。 实际上直接模拟即可。 如果按时间增长为横坐标，按该时间的权值为纵坐标，画出对于$[0,m]$的每一种初始值的函数图像，我们会发现，随着时间的增长，函数曲线变得原来越少，也就是图像会不断重叠在一起。 形式化地讲，我们可以发现一个重要性质：对于一个在某一时刻触碰到上/下边界的曲线，在这个时刻之后，其函数图像将会和在这个时刻之前已触碰到上/下边界的曲线完全相同。 在某一时刻时，我们称一个初始值为“归上”，当且仅当其在这个时刻及以前已经触碰到了上边界；“归下“同理。我们发现，对于任意确定时刻，”归上“的初始值都是$[y,m]$，而”归下”的初始值都是$[0,x]$。而且随着时间推进，$y$单调不增，$x$单调不减。 既然询问已经以时间递增的顺序给出，那我们就顺序模拟时间推进，并逐一处理询问。 我们要维护的东西有三个：”归上”初始值在当前时间的具体取值$up$、“归下”的初始值在当前时间的具体取值$dn$，以及从开始到现在上下移动的总和$sum$。 对于一个询问$(t,a)$，假设时间已经模拟到了$t$，如果$a$”归上”，也就是曾经碰到上边界，那么答案就是$up$；如果其”归下”，则答案就是$dn$；否则，$a$从开始到现在没有碰到任何边界，所以其取值直接模拟即可，恰好为$a+sum$。至于”是否曾经触边“的判定，可以维护$sum$有史以来的最大值和最小值，加在$a$上判定与0或m的大小关系即可。 对于$up$和$dn$的计算，在初始时令$dn=0$，$up=m$，然后在时间推进的过程中不断对它们进行带边界限制的模拟上下移动，那么我们就可以保证在每一个时刻时，$up$和$dn$都是我们所定义的值。为什么？因为初始时，“归上”恰好只有$m$，”归下”恰好只有0。而之后触碰到上/下边界的所有曲线，都必定在m/0之后触碰，也必定在m/0之后成为”归上”/“归下”。只要一触碰，其函数值就会和m/0相同。于是本质上，我们是在维护$a=0$和$a=m$在任意时刻的取值。 形象地讲，这道题就像一个非弹性形变的柱子在管道里上下移动，柱子的”长度“就代表着那一部分从未触边的初始值，而上面和下面空出来的部分，代表着上面这些取值的答案都是柱子的”上端“，下面这些初始值的答案都是柱子的“下端”。为什么会空出来呢？因为曾经被“挤”在一起了，因此这一部分初始值在以后的取值都相同了。那么$up$和$dn$其实就是柱子的上下端。 Summary 如果询问问的东西是同一种问题的不同出发点导出的某个状态，不妨考虑将所有出发点同步模拟，并离线回答询问。有可能一起模拟的过程会存在简化规模、合并不同状态的机会，就像自动机那一题 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;using namespace std;const int N=100005;int n,m,q,a[N];int l,r,sum,summn,summx;inline int min(int x,int y)&#123; return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;inline void move(int &amp;x,int d,int tim)&#123; x+=d*tim; if(x&gt;m) x=m; if(x&lt;0) x=0;&#125;void cont(int tim,int d)&#123; static int lasttim=0; int delta=tim-lasttim; lasttim=tim; sum+=delta*d; summn=min(summn,sum); summx=max(summx,sum); move(l,d,delta); move(r,d,delta);&#125;int query(int x)&#123; if(x+summn&lt;=0) return l; else if(x+summx&gt;=m) return r; else return x+sum;&#125;int main()&#123; scanf("%d%d",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); scanf("%d",&amp;q); l=0; r=m; sum=summx=summn=0; int i=1,d=-1,x,y; while(q--)&#123; scanf("%d%d",&amp;x,&amp;y); for(;i&lt;=n&amp;&amp;a[i]&lt;=x;cont(a[i++],d),d=-d); cont(x,d); printf("%d\n",query(y)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC068F】双端队列]]></title>
    <url>%2F2018%2F09%2F19%2Farc068_f%2F</url>
    <content type="text"><![CDATA[Description 你有一个双端队列和 $N$ 个数字，先按 $1$ 到 $N$ 的顺序每次从任意一端插入当前数字，再进行 $N$ 次操作每次可以从两端弹出，求有多少种弹出序列满足第 $K$ 位为 $1$ $N \le 2000$ Solution 考虑双端队列的样子，插入完成后，元素大小形象来看一定是一个”V”的形状，并且最低端是1。 再考虑符合要求的、合法的弹出序列的性质： 1. 首先第$K$个必须是1 2. 前$K-1$个数，一定是两个或一个单调减的队列混合而成的 3. 后$N-K$个数，其最大值应小于某一个（2）提到的单调队列的最小值。 一旦前$K-1$个数固定，最后剩下的就是一个单调的队列，取出方式有$2^{N-K-1}$种。 所以接下来要算出合法序列的前$K-1$个数有多少种情况。 设$f_{i,j}$表示已经确定了前$1…i$个数，且确定的数中最小值为$j$，有多少种方案。 考虑从$f{i,j}$转移到$f{i+1}$。$f_{i,j}$代表着若干种符合$j$这个特征的长度为$i$的数列，不论这些数列的两个（或者一个）单调队列是怎么构成的，我们只需要看看它们能够在第$i+1$位填上什么数合法转移就好。 首先，下一位填$1…j-1$都是可行的。由于当前序列是合法序列，也就是说满足（3）。可以这样拆分出两个队列，使得一个队列的最小值是$j$，而另一个队列专门用来满足（3）。那么将新的数接在前面那个队列后面，仍然是合法序列。所以有$f{i,j}\rightarrow f{i+1,k}\;\;\;k&lt;j$ 其次，如果要填大于$j$的数呢？只能填没出现过的、最大的那个数。例如$n=7$，当前序列是7 6 3 2，只能填入5。如果填的是其他数如4，你会发现，4一定要是某一个队列的结尾，由于它不是未出现的数的最大的数，这意味着后$N-K$个数的数列有比它更大的，那么这个队列不满足（3）。考虑另一个队列能否满足，事实上是不可能的，因为最小值一定要是另一个队列的结尾（不然就不止2个队列了），它也不满足（3）。 所以有$f{i,j}\rightarrow f{i+1,j}$。这个转移有点神秘，它没有体现出任何$j$的变化，但它的确能表示，因为这一步转移相当于对每一个确切方案填了唯一确定的一个数，所以可以直接转移去对应特征的状态，也就是最小值仍然是$j$。 注意边界，那些$j&gt;n-i+1$的$f_{i,j}$是不合法的，那些$j=n-i+1$的状态不可以用于第二类转移，因为没有空余的数可以填。 第一个转移用后缀和优化，复杂度是$\mathcal O(n^2)$。 Summary 题目给的具有特殊规律的东西，要发现其内含性质（说起来容易），转化出更加易于考虑的性质，再解决 Code123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;using namespace std;const int N=2005,MOD=1e9+7;int n,m;int f[N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m);&#125;void dp()&#123; f[n+1]=1; int sum,last; for(int i=1;i&lt;m;i++)&#123; sum=f[n-i+2]; for(int j=n-i+1;j&gt;=2;j--)&#123; (sum+=f[j])%=MOD; if(j&lt;=n-i+1) f[j]=sum; &#125; &#125; int ans=0; for(int j=2;j&lt;=n-(m-1)+1;j++) (ans+=f[j])%=MOD; if(m==1) ans=1; for(int i=1;i&lt;=n-m-1;i++) (ans&lt;&lt;=1)%=MOD; printf("%d\n",ans);&#125;int main()&#123; readData(); dp(); return 0;&#125; ​]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[疯狂求导]]></title>
    <url>%2F2018%2F09%2F18%2F%E7%96%AF%E7%8B%82%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[Description 题意简述：一行序列，每一个位置有一个多项式，支持区间加一个系数为1的单项式 ​ 询问如下：对于$[l,r]$多项式之和，找到最小的$k$，使得指数大于等于$k$的项的系数之和不超过给定的界限$s$ Solution 我居然没看出这是一道数据结构题？ 最直接的想法是，按照暴力那样，每一个位置维护一个多项式，然后用二分答案来判定后缀和是否不超过界限…… 可是这样显然没法做啊。第一，怎么可能开的下这么大的数组；第二，求和操作不现实。这个方案应该第一时间被舍弃，可我还是往这里想了半天 所以直想应该是行不通的 考虑二分答案时，每次要查询一段区间的多项式之和中，指数大于等于某个数的单项式系数和是多少 既然以区间作为第一维、指数作为第二维不行，那么我们就要想想能不能交换一下两个维度 把指数作为第一维，下标作为第二维 第一维用线段树维护这一段指数范围中，每个区间的系数和是多少 第二维也用线段树维护，动态开点，这样就不会爆空间 那么就是一个经典的线段树套线段树题，查询在第一维上线段树二分即可 Summary 每个位置一个超长元素，如果第一维是按位置为下标可能不行。不妨交换两维考虑，说不定就更利于操作了 如果感觉线段树根本开不下，有可能是使用动态开点使得总空间复杂度和操作次数有关（利用线段树在表示方面的性质）。不要直接把自己从正解方向吓走了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include &lt;cstdio&gt;using namespace std;typedef long long ll;namespace IO&#123; const int S=20000000; char in_buf[S]; int in_pos; void load()&#123; in_pos=0; fread(in_buf,1,S,stdin); &#125; char getChar()&#123; return in_buf[in_pos++]; &#125; ll getLong()&#123; ll x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getLong;const int N=200010,M=20010,V=1000010;int n,m;int maxa=1000000;namespace SEG2&#123; const int S=V*2*18; int sz,rt[V*2]; int ch[S][2],sum[S],tag[S]; inline void pushup(int u)&#123; sum[u]=sum[ch[u][0]]+sum[ch[u][1]]; &#125; inline void makeTag(int u,int l,int r,int x)&#123; sum[u]+=(r-l+1)*x; tag[u]+=x; &#125; inline void pushdown(int u,int l,int r)&#123; if(tag[u])&#123; int mid=(l+r)&gt;&gt;1; if(!ch[u][0]) ch[u][0]=++sz; if(!ch[u][1]) ch[u][1]=++sz; makeTag(ch[u][0],l,mid,tag[u]); makeTag(ch[u][1],mid+1,r,tag[u]); tag[u]=0; &#125; &#125; void modify(int &amp;u,int l,int r,int L,int R)&#123; if(!u)&#123; u=++sz; sum[u]=tag[u]=0; &#125; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; makeTag(u,l,r,1); return; &#125; pushdown(u,l,r); int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) modify(ch[u][0],l,mid,L,R); else if(mid&lt;L) modify(ch[u][1],mid+1,r,L,R); else&#123; modify(ch[u][0],l,mid,L,mid); modify(ch[u][1],mid+1,r,mid+1,R); &#125; pushup(u); &#125; int query(int &amp;u,int l,int r,int L,int R)&#123; if(!u) return 0; if(L&lt;=l&amp;&amp;r&lt;=R) return sum[u]; pushdown(u,l,r); int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(ch[u][0],l,mid,L,R); else if(mid&lt;L) return query(ch[u][1],mid+1,r,L,R); else return query(ch[u][0],l,mid,L,mid)+ query(ch[u][1],mid+1,r,mid+1,R); &#125;&#125;namespace SEG1&#123; const int S=V*2; int rt,sz; int ch[S][2],val[S]; int nl,nr; ll limit,ans,sum; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; void modify(int u,int l,int r,int pos)&#123; SEG2::modify(SEG2::rt[u],1,n,nl,nr); if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modify(ch[u][0],l,mid,pos); else modify(ch[u][1],mid+1,r,pos); &#125; void setCurrent(int _l,int _r)&#123; nl=_l; nr=_r; &#125; void query(int u,int l,int r)&#123; ll rsum=SEG2::query(SEG2::rt[ch[u][1]],1,n,nl,nr); if(l==r)&#123; ll cur=SEG2::query(SEG2::rt[u],1,n,nl,nr); if(cur&lt;=limit)&#123; ans=l; sum+=cur; &#125; else ans=l+1; return; &#125; int mid=(l+r)&gt;&gt;1; if(limit&gt;=rsum)&#123; limit-=rsum; sum+=rsum; query(ch[u][0],l,mid); &#125; else query(ch[u][1],mid+1,r); &#125; void queryD(ll _limit,ll &amp;_ans,ll &amp;_sum)&#123; limit=_limit; ans=sum=0; query(rt,1,maxa); _ans=ans; _sum=sum; &#125;&#125;void readData()&#123; n=getLong(); m=getLong(); int useless; for(int i=1;i&lt;=n;i++) useless=getLong();&#125;void answerQuery()&#123; int opt,l,r; ll a,ans=0,val; for(int i=1;i&lt;=m;i++)&#123; opt=getLong(); l=getLong(); r=getLong(); a=getLong(); SEG1::setCurrent(l,r); if(opt==0)&#123; a^=ans; SEG1::modify(SEG1::rt,1,maxa,a); &#125; else&#123; SEG1::queryD(a,ans,val); printf("%lld %lld\n",ans,val); &#125; &#125;&#125;int main()&#123; IO::load(); readData(); SEG1::build(SEG1::rt,1,maxa); answerQuery(); return 0;&#125;]]></content>
      <categories>
        <category>2016北京集训</category>
      </categories>
      <tags>
        <tag>数据结构---树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC010D】 Decrementing]]></title>
    <url>%2F2018%2F09%2F11%2Fagc010_d-Decrementing%2F</url>
    <content type="text"><![CDATA[Description 咕咕咕 Solution 日常博弈论做不出来。 首先，数值全部为1的局面先手必败。 在接下来的过程中，我们只关注那些大于1的数值。 按照官方题解的思路，首先想一个简化版的问题：没有除的操作，其余相同。那么局面结果显然和所有值的和的奇偶性有关。 回到原问题。我们发现，当局面中有2个或更多奇数，其余为偶数时，我们对任意一个元素进行一次完整操作，仅仅会将一个元素从奇变偶，或从偶变奇。原因？只要有奇数存在，所有数的GCD必定是奇数。所以当全局除以GCD时，奇数还是奇数，偶数还是偶数，因为它们的2没有被除去。不论操作的是偶数还是奇数，都必定会留下至少一个奇数存在。因此变动也就只发生在操作的数上。暂且称之为A性质。 如果先手手上全是奇数，那么必败。全1时显然必败。根据A，先手对任意数进行操作，将会出现一个偶数，那么后手可以把这个偶数变回奇数。如此反复，必定先手败。 根据题目给的性质：初始时GCD为1。这意味着初始局面必定有1个或以上的奇数。 接下来，对局面按偶数的个数分类： 有奇数个偶数：必胜。证明：先手先操作一个偶数，那么此时局面中有2+个奇数，以及偶数个偶数，符合A，则变化只发生在操作数上。如果后手操作一个偶数变奇数，那么先手再操作一个奇数变偶数；如果后手操作一个奇数变成偶数，那么先手可以再操作这个数变成奇数（既然后手能操作，那么操作前数肯定$\ge 3$）。如此进行，某个时刻后手操作前将会有没有偶数，即全为奇数。我们已经证明此时先手必败。 有偶数个偶数：如果没有奇数，先手任意操作时，-1后出现一个奇数，大概理解为满足A，则都会使得后手有（1）的局面，即先手必败。如果有2+个奇数，此时满足A，先手任做一次操作，都会使后手有（1），先手必败。如果恰好有1个奇数，这时候我们无法推理什么，但是此时我们发现，如果先手操作某一个偶数，那么就直接输了，所以先手只有1种选择：操作那个奇数。于是问题就变成模拟了。我们递归处理，直到遇到上述情况位置。由于每次GCD至少是2，于是层数就是$\mathcal O(\log)$的。 Summary 在这稍微总结一下：博弈论题一般是要发现一些逼迫方法，并从这些角度来考虑必胜策略。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;namespace IO&#123; const int S=10000000; char buf[S]; int pos; void load()&#123; fread(buf,1,S,stdin); pos=0; &#125; char getChar()&#123; return buf[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int N=100005;int n;int a[N];void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) a[i]=getInt();&#125;int gcd(int x,int y)&#123; if(x&lt;y) swap(x,y); for(int z=x%y;z;x=y,y=z,z=x%y); return y;&#125;void simulate(int who)&#123; static int sum[2],oddpos; bool all1flag=true; sum[0]=sum[1]=0; for(int i=1;i&lt;=n;i++) if(a[i]!=1)&#123; all1flag=false; sum[a[i]&amp;1]++; if(a[i]&amp;1) oddpos=i; &#125; if(all1flag) throw who^1; if(sum[0]&amp;1) throw who; if(sum[1]&gt;1) throw who^1; if(sum[1]==0) throw who^1; a[oddpos]--; int g=-1; for(int i=1;i&lt;=n;i++) if(a[i]!=1)&#123; if(g==-1) g=a[i]; else g=gcd(g,a[i]); &#125; for(int i=1;i&lt;=n;i++) if(a[i]!=1) a[i]/=g; simulate(who^1);&#125;int main()&#123; IO::load(); readData(); try&#123; simulate(1); &#125; catch(int e)&#123; puts(e?"First":"Second"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[harmakik]]></title>
    <url>%2F2018%2F09%2F07%2Fharmakik%2F</url>
    <content type="text"><![CDATA[对于原树一个节点$x$： $f_x(h)$表示，$x$作为一个深度为$h$的点时，$x$及其子树的安排方案有多少（不考虑$x$具体在深度为$h$的哪个点） $F_x(h)$表示，对于一个固定的深度为$h$的节点$y$，$x$在$y$或其子树中，$x$及其子树的安排方案有多少。 则有关系： F_x(h)=\sum_{i\ge h}f_x(i)*2^{i-h} 对于叶子： F_x(h)=[h\le h_x]2^{h_x-h} 已知二者都可以表示成这些形式 f_x(h)=\sum_{i\geq 0}c_i*2^{-ih}\\ F_x(h)=\sum_{i\geq 0}c_i*2^{-ih} 对于叶子$x$，赋值后直接回溯： c_1=2^{h_x} 依照60分DP，可以推出由儿子到自己的转移（两个$c$分别是两个$F$的$c$，$c’$是转移后的$f_x$的$c$）： \begin{aligned} f_x(h)&=F_l(h+1)F_r(h+1)\\ &=(\sum_{i\geq 0}c_i2^{-i(h+1)})(\sum_{j\geq 0}c_j2^{-j(h+1)})\\ &=(\sum_{i\geq 0}\frac{c_i}{2^i}2^{-ih})(\sum_{j\geq 0}\frac{c_j}{2^j}2^{-jh})\\ &=\sum_{i\ge0}{c'}_i2^{-ih}\\ \end{aligned} 当然，也可以在卷积完之后每个$c_i$除去$2^i$ 观察到这个卷积，再考虑边界，$c$的下标为$0…siz[x]$，$siz[x]$为$x$子树中叶子数。暴力卷积，用树上背包思路分析，这一步的复杂度是全局$\mathcal O(n^2)$的 得到自己的$f$后，由于父亲要使用自己的$F$，所以根据定义式由$f$推出$F$： \begin{aligned} F_x(h)&=\sum_{h \le i]]></content>
      <categories>
        <category>2016北京集训</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超长思路整合]]></title>
    <url>%2F2018%2F09%2F05%2F%E6%80%9D%E8%B7%AF%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[BZOJ4487每行必填、每列必填、每种颜色必填 发现特征比较普适，直接针对每个不合法的属性容斥 f_{i,j,k}$$表示有$i$行未填，$j$列未填，$k$种颜色未填时，全局方案数 容斥系数就为$(-1)^{i+j+k}$，$ans=\sum(-1)^{i+j+k}f_{i,j,k}$ ## AGC015C 树、断开、统计连通块数量 在树的意义下，连通块数量等于点数减边数 维护矩形内点数和边数 ## azelso [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1142&pid=0) 路程长度不占决策：统计每段路程期望经过次数 期望经过次数与经过概率是倒数关系 经过概率定义为走完以后不再重走此边的概率，则要走这么多次之后才不再重走 就有定义$f_i$表示走过$i$后不再回来 注意分母有0，所以化期望 ## 小Q与进位制 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1142&pid=1) 先减一，转10进制，再加一。还不如直接转十进制 在$k$进制下，如果要转十进制，那第$i$位的贡献恰好有一个系数$k^{i-1}$ 乱进制同理ans=\sumi a_i\prod{j=0}^{i-1}bas_j 由于运算过程中每个数字都是高精度，乘法和加法时间过长。注意到$\prod$感觉有很多重复，所以分治fft，用类似阶梯的方法做 ## 小Q与内存 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1142&pid=2) 暴力即将每一段内存看成一个元素来维护 注意到每次操作的区间很多，而且可能不连续。因此直接上朴素数据结构很难维护跳跃的区间的删除和加入 这启示我们正解中，这些区间应该可以一起维护，也就是应该要连续 所以考虑申请一段区间就把它们从原线段树中分离出来，释放时再合并回去。这样每次申请时，申请到的内存在原线段树中是连续的，很方便 实际上使用到的元素不多，所以不建满，打标记是否省略了这个节点以下的满二叉树；使用动态开点 ## ARC067F [链接](https://arc067.contest.atcoder.jp/tasks/arc067_d) 考虑暴力：固定左端点，将右端点向右移动，查询每张票在当前区间的最大值，求和 每次移动右端点是$O(M)$的复杂度，这意味着有三次方。每次移动我们更新最大值，并求和 每张票都该经历一个更新最大值的过程，但我们却不能逐一枚举每张票来查看并更新。也就是主动更新复杂度很高 考虑被动更新：右端点右移时，每张票的贡献都可以差分出来，其差分的关键点就是当前左端点往右走到顶的单调栈。贡献可以直接赋到全局标记数组上，右端点移动只需查询标记前缀和即可。 ## Decrementing [已有题解](https://www.cnblogs.com/RogerDTZ/p/9628888.html) 在这稍微总结一下：博弈论题一般是要发现一些逼迫方法，并从这些角度来考虑必胜策略。 ## crash的数列 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1140&pid=0) 先想出怎么模拟一个数组 然后发现数组的定义适用于自身 可以采用多层自套的方式，第一层意义为+，第二层意义为×。尝试后加速效果明显 ## fixed [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1140&pid=1) n*n方阵，除了想矩阵，还要想想这是不是个邻接矩阵 矩阵的幂理解为一个点的走向模拟 ## 直径 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1140&pid=2) 显然求的是直径 直径无外乎两种求法：直接dp，或者两遍深搜最远点 考虑前者，太复杂 考虑后者，模拟深搜。直接深搜复杂度显然爆炸。 想想直径性质：一棵树中，距离一个点的最远点必定是直径两个端点之中的一个点。 假设深搜进入了一个子树，我们可以用当前距离加上当前点到两个直径端点的距离更新最远点。而其他点我们根本不需要深搜过去。 所以下一步是搜去另一个复制的子树，这个很好做 所以搜索次数恰好为复制子树数量 ## 自动机 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1139&pid=0) 序列长度可认为无穷，因此这种问题，想想怎么用两两考虑（或者其他简单一些的子过程，可以促进整个过程）来模拟 我可以深搜出0号和某个点要怎么走才能走到一起，再走回0. 这步的复杂度是n方的，因为已访问的点对不需要再访问 我枚举每个点和0号店，重复上述过程。每做一次，就少一个要考虑的点。那我做n-1次，不就完了吗。每做一次就模拟一遍全局，这样就不影响后续过程。最后把操作序列拼接起来即可。 ## 踩气球 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1139&pid=2) 一个人高兴，当且仅当区间内所有点都删掉了 而且操作是每次最多删1个点（可以用数组模拟什么时候删，如果一个点操作后没被删掉，根本不是要考虑的东西）所以修改后全局的变动可以很容易考虑 区间问题想到线段树。一段区间被删完，抽象为一个区间节点变空。 那么删点就是线段树单点修改-1 每个人与cnt=log个节点有关系。每个节点删到空时，所有与它关系的人自己的cnt--。如果减后有人cnt=0那么有人高兴了。 ## 往事 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1138&pid=2) 考虑trie上每个节点u，子树内含所表示的串的lcp至少为dep[u] 暴力枚举每个点u，假装它们的lcp恰好为dep[u]，然后统计子树中两两lcs最大值。如果大于dep[u]，自然后面会在真正的lca上枚举到。这属于定义虽然不严格按照思路，但枚举方式可以确保最优的情况（如2017noipD2T2） 下面是求子树内含字符串两两lcp最大值 想用后缀数组，fou掉什么可持久化、展开成序列之类的后缀数组，我们需要更简明的写法 考虑复杂度，单次查询复杂度要小于等于一个log，说明不可能是O(size)扫相邻的height，而且怎么维护子树的一个大数据结构----------->启发式合并 既然能全局合并，说明不是那种最初始的后缀数组，我们其实要对每个完整的串排序。这点树上sa可以做到。 我要能一个log内查询两两height，一个log又很玄乎。那么这玩意应该是继承、维护上来的一个单一变量 假设我知道某子树的后缀数组的height最大值，启发式合并其实只会引入两个height，所以是O(log)更新 ## 矩阵 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1138&pid=1) 模拟复杂、整体限制----------------------->网络流 1-9，数量少，拆点 限流难，转最小割 用9×点数-最小割，将选数字x变成有9-x的代价。最小化代价。 对着选数的方法，用INF构造最小割 ## 冒泡排序 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1138&pid=0) 冒泡排序性质：外层循环次数为：以每个点为第一个元素的逆序对的数量的最大值 求字典序在第$k$位：考虑从左到右填，枚举当前填数，卡位推进 外层循环恰好为m：至少有一个位置，之后比它小的数的个数等于m。其余位置的这个属性也不可超过m 从左到右填，枚举当前填数，由于是排列，之后有多少个比其小的数可以直接算出来，填每个数的属性已知，可以利用这个属性，用式子直接算出之后的填法（因为后面的填数过程是形式化的）。用这个值来卡位推进。 式子可以运用差分思想：计算属性值最大为j的填法。可以发现填入一个数后位置可插入位置数量不变，即情况完全一致，式子也变得很美观，直接是（选择方案数^选择次数）的形式，当然要乘上一些特殊的数带来的系数（后面没填完的）。那么差分就可以得出恰好为j的填法数量。 ## 打地鼠 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1137&pid=0) 地鼠只能在边界被逼死 由于是打走打走，最终区间必定是奇偶性相同的连续一段 考虑单独维护左右端点 ## 图 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1136&pid=1) 如果不是$O(L^x)$能解决的复杂度，那应该是非多项式的复杂度。 由于要拟合，就去先试几个环感受一下增长速度 发现非简单环的增长速度是$O(2^x)$+的，所以图中不能存在非简单环 缩点，得一DAG 由于最终给出的O要覆盖每种长度的情况，显然考虑那些最长的路径 比如一条长度为L的DAG上的完整路径（从起始点出发走到汇点），途径k个非单点简单环，每个环上都可以绕一段距离再出来。这相当于一个k元一次方程，解的个数是$O(L^{k-1})$级别的。 因此答案为一条路径，满足包含非单点环数目的最大。答案即这个最大值-1 ## isn [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1134&pid=0) 考虑所有非降子序列：如果它们都算进答案的话，一个长度为$l$的子序列，将会有$(n-l)!$的贡献。 问题是不是每个非降子序列都是合法的。如果一个非降子序列能由另一个非降子序列得到，那么它不应该被统计，这是从下往上看。 从上往下看，每个长度为$l$的非降子序列，都会对长度为$l-1$的非降子序列的数量产生$l$的负贡献，因为删去任意一个元素都会得到一个应该被减去的子序列。 想要从总数减去非法的，我们只需要用每个l的人人都算的方案对l-1的真实答案进行负贡献即可。因为每一个不合法的子序列，都会在长度比它刚好多1的地方被统计到并减去，即使减去之前的子序列自己本身不合法。我们发现这个过程对于每个不合法的序列都会恰好统计一次。 减去非法的元素不一定只在合法与非法的边缘减去，还有可能在已经非法的地方继续用自己减，因为我们答案的全局是包含了多层非法元素的，而这样可以一并减去。 ## 兔子的字符串 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1133&pid=0) 最大的最小，想到二分答案。由于答案是一个子串，考虑建出后缀数组后，先二分答案为哪一个排名的后缀，再二分答案是这个后缀的哪个前缀 比答案小的后缀显然不用考虑 考虑比它大的后缀，如果切分后它们都不够二分的串大，那么对于每个后缀都有一个最晚切分点。贪心模拟即可 ## 奇怪的树 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1133&pid=2) 操作对象和深度的奇偶性有关，和黑白有关 以输入为标准，分四组：奇黑奇白偶黑偶白。由于操作只是将深度为某一个奇偶性的点的黑白互换，所以完全可以用两个指针维护当前实质上黑色是相对于输入的黑还是白（懒惰操作） 单点修改相当于单点换组，树剖维护 ## Mountainous landscape [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1493&pid=0) 在x时看到的点一定是(x,n]组成的凸包的点。虽然我们可以二分出是否有交，但是却输出不了具体是哪一条边 既然我能判定有交，那么就可以二分位置了 用线段树维护区间凸包 ## 凸点集 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1491&pid=0) 观察到答案的贡献是2的若干次幂，而且幂恰好为凸包内部点个数。所以想到了子集数量 再转化一下问题，发现原图每个凸包都恰好贡献一次，因此问题完全转化为求合法凸包个数。 ## Poor Turkeys [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1491&pid=1) [已有题解](https://www.cnblogs.com/RogerDTZ/p/9552950.html) 每个人a要存活，某一些人在有关a的事件之前必须存活 由于和之前有关，考虑按时间倒着做，钦定某一些人必须存活 这样可以消除后效性，转成判定问题 ## Tournament [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1490&pid=0) 一个人交手多个人直到失败，在二叉树上是一个链一样的东西。这意味着接出去的子树深度在当前点看来还要加上接出去的层数。 显然自底向上dp，由子树深度从大到小，从浅到深安排 ## 落忆枫音 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1490&pid=2) 一个DAG中，因为每个点都要从另一个点来，所以生成子图的数量，就是每个点的入度的乘积， 现在新加边$(x,y)$ 如果新加的边不成环，那么加边后重算。 如果成环。先钦定不用新边按上面方法算一遍，记为ans。再加上钦定新边一定要用的方案。后者怎么算？ 既然一定要用，那么作为根的1一定要和x联通。不能成环，意味着从y出发的路径不可以与1走到x的路径有交。如果钦定了1到x的路径，那么y根本无法走到x，路径上的每个点的入边都已确定。那么除了路径上的点（它们被固定死了来处），显然其他点对答案的乘积贡献依然是入度。这时候能保证y出发的路径与1到x的路径无交。 所以统计所有从1出发的路径，每条路径的贡献是路径上的点的入度的倒数。求贡献和后，乘上ans就可以达到固定的效果，加上原来的ans就是答案。 ## 国旗计划 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1489&pid=0) 环上走路。 考虑每个人的接棒人固定。对于每个元素的转移是固定终点的这类问题，我们要想到使用倍增加速转移、用倍增二分优化判定 ## Blackout [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1489&pid=1) 如上所示，n*n矩阵考虑邻接矩阵。那么相当于如果有x到y，y到z，那么新连边z到x 由于这个关系是三元的，考虑原图三染色，分成123三块。每次操作都可以抽象为如果1连2,2连3，那么3连1的操作，其他同理。 根据三个块是成功染色、染色失败、还是三种颜色不足，可以对应到完全图、无影响、和三色块两两连边这三种最终结果。 ## Namori Grundy [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1489&pid=2) 看到入边性质和边界条件，是形如最小的未出现的非负整数，想到mex 叶子是0 树上容易模拟钦定 考虑树根，即基环上的点如何确定。在基环上处理问题，由于特殊边：环上边只有一条，所以有些信息可以方便一起考虑和处理。如果不看特殊边，根只有1种取值x。如果环上来边的值恰好为x，那么自己只能取二级mex。如果不是，那么自己又取回x了 所以每个根的选择只有2种 接下来考虑怎么钦定整个环 尝试任挑一个根，枚举两种取值。我们发现，环上一旦填入一个值，那么接下来顺着走的一圈的点的值都不需要枚举，已经确定了（mex{子树内给来的值$\cup$来边的值}）。绕一圈模拟回来判定是否冲突即可。做两次。 ## Snuke Line [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1488&pid=1) 枚举每个d，要统计d,2d,3d,...经过了多少种不同颜色的区间 由于经过多次只算一次，这种存在性而不是数量性的问题根本无法统计 正难则反，用总颜色数减去未被经过的区间数。这样显然每个未经过的区间只会被统计一次，这样行得通 即询问每两个取值之间$(kd,(k+1)d)$包含着多少个区间，求和 对于每个d，有$\mathcal O(\frac m d)$个区间，所以总共只有$\mathcal O(n \log n)$个询问，每个询问询问一段区间内包含着多少段题目给的区间 相当于统计右端点在$[l,r]$中的区间有多少的左端点也在$[l,r]$ 在线做比较复杂，考虑离线做就很简单 右端点$r$往右移，回答每个右端点在此处的询问。用树状数组维护每个已加入的区间（右端点$\le r$）的左端点的位置，区间查询$[l,r]$即可 正难则反，在线难则离线 ## 简单的问题 Many Easy Problems [链接](https://agc005.contest.atcoder.jp/tasks/agc005_f) 对于每个$k$，统计任选$k$个点作为关键点的“最小生成树”的大小之和 正向想法是枚举或者计算大小为$x$、叶子数目为$y$的子树有多少种，然后贡献答案。这种方法参数多、难统计，可以感受到无法适应$1e5$的数据，舍弃 正难则反，自顶向下正向统计难，就考虑自底向上贡献统计。那么这里的自底向上，就应该是对于每一个点，统计其贡献到每个$ans$的次数，并累加。 既然要输出k=1...m的答案，可以猜到贡献是一个卷积加速的形式 所以先考虑每个点对某一个k的答案的贡献 任选k个点之后，一个点对答案有1的贡献，当且仅当选择的点不全在以其为根时的某棵子树中 这个很好统计，不全在某棵子树中这个条件很难考虑，不如直接用总数减去不合法的方案，毕竟所有元素用一个组合数就可以搞定${n \choose k}-\sum_v {size_v\choose k}$ 则ansk=\sum{u=1}^n{n \choose k}-\sum_{v\in \text{sub}_u}{size_v \choose k} 前一部分可以直接算，但后一部分看起来不是一个数组的卷积 遇到这种情况，我们可以用权值作为下标先做一个统计数组$a[size_v]++$，因为统计时使用的数据与这个$size_v$具体是哪一个点的子树大小关系不大，而只和子树大小这个数值有关。因此不以每个点作为视角考虑（具体是谁不重要），而以整棵树为视角考虑，那么$ans_k$就会变成ansk=n{n\choose k}-\sum{i=1}^{n-1}a_i{i \choose k} 减法卷积算出每个$ans_k$的负部分即可 ## 狂飙突进的幻想乡 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1141&pid=2) 题目要求的是期望 指定参数a时，有唯一确定的最短路长度 由于a随机，相当于求出最短路长度关于a的函数在$[0,1]$上的积分 可以辛普森积分爆搞。由于图像是折线而不是曲线，所以估价不用辛普森，而用平均函数 ## 连在一起的幻想乡 [链接](http://192.168.102.138/JudgeOnline/problem.php?cid=1141&pid=1) 如果答案求的是每种情况，但输出时不直接输出而是采用加密或压缩的形式，那么情况一般有两种： 1. 输出量过大。一般题目会有额外说明“由于输出较多，你只需要输出...." 2. 题目本身统计时使用这种”加密方式“的形式统计会非常好做。一般题目不会额外说明，且输出量较小 对于一个使用了$k$条边的联通子图，其贡献为$k^2$，相当于枚举这个子图中的每两条边，问能枚举多少个有序对（自己和自己配对只算一次） 放到全局，就是统计对于任意两条边，有多少联通子图包含它们 首先看一下求解联通子图个数的式子：$f_n$表示$n$个有标号点的联通子图数量，$g_n$表示$n$个点的生成子图数量：fn=g_n-\sum{i=1}^{n-1}{n-1 \choose i-1}fig{n-i} 先统计总数，再枚举1号点所在连通块大小，假设另一部分与i所在位置完全不连通，减去所有不合法情况 接下来不好想了，没思路；没思路就考虑分类讨论着两条边的关系，总会有容易切入的一面 1. 两条边是同一条边：相当于有两个点总是打包连通的。由于枚举每次枚举边时情况相同，所以答案乘上总边数$n \choose 2$直接加进总答案。与朴素算法的差别仅仅在于：$g_n$表示$n$个点的一条边强制选时生成子图数量，$i$枚举的是这两个点所在连通块的大小，因此从2开始枚举，组合数变成$n-2 \choose i-2$ 2. 两条边共用一个顶点：答案乘上$n(n-1)(n-2)$贡献进总答案。考虑这三个点已经有V字的两条边，第三条边加不加都可以，有两种选择，这个选择和外界无关，是个独立系数，假设第三条边不加，最后的答案乘以2即可。然后$g_n$表示强制选3条边时生成子图数量，连通块大小从3开始枚举，组合数变成$n-3 \choose i-3$ 3. 两条边完全独立：答案乘上${n \choose 2}{n-2 \choose 2}$贡献进总答案。先只看这两个条边、四个点。$g_n$变成强制选2条边时的生成子图数量。此时减去的部分不仅有从$i=4$开始枚举，组合数变成${n-4 \choose i-4}$的情况（这是枚举两条边已经联通的情况）;而且有两条边不连通的情况，$i$枚举一条边所在连通块大小，组合数变成$n-4 \choose i-2$，枚举一条边所在连通块大小，那么另一条边在另一个我们假定的与这个连通块完全不连通的部分，那么原来的$g_{n-i}$的定义应该变成一条边必须选时的生成子图个数，而卷积的另一个$f$应该用回第一个情况时算出的$f$ fn=g{2,n}-\sum{i=4}^{n-1}{n-4\choose i-4}f_ig{0,n-i} -\sum{i=2}^{n-2}{n-4 \choose i-2}f’_ih{1,n-i} $$ ARC 065 E链接 问题其实就是从一个点出发，每次可以走与其曼哈顿距离恰好为一个常数$d$的点 显然不可能一一走完所有的边，这样复杂度下界至少是$O(ans)$ 我们采用折中方式：间接统计 （1）找出从起始点能到达哪一些点 （2）统计对于这些点之中的每一个点，与其距离为d的点有多少，求和除二就是总边数 首先考虑第一步，如果我们通过枚举边的思路进行广搜，又要触及边的数目过多这一限制。考虑距离一个点$(x_0,y_0)$曼哈顿距离为$d$的点$(x,y)$应该满足什么特征，分四类：左上左下右上右下。左上右下的限制都是形如$x-y=x_0\pm y_0\pm d$且$x$在一定范围内的点，右上坐下的限制都是形如$x+y=x_0\pm y_0\pm d$的点 枚举四种情况时，两个符号可以直接定下来，关键是对于每个$a$，组织起满足$x+y=a$或$x-y=a$的点，并按$x$大小维护。由于我们不需要统计$x$在某个范围内的数具体有多少个，而仅仅是需要迭代枚举功能，我们马上想到内层应该要用一个set维护这一些点。那么外层是一个$x+y$或$x-y$的索引，关于索引，用map 所以用两个map套set，维护$x+y$和$x-y$的点的信息。对于一个点，它在两个map中都有且仅有一个存在 那么广搜时只需在map上查询所需的特征对应的set，并确定$x$值范围，在set上迭代枚举即可 如果这样，我们发现这个复杂度下界至少是边数。我们第一步是找出所有联通点，而不是统计边数，每个点显然入一次队即可。所以如果一个点入队，我们就把它在两个map中的存在删除。这样就能保证复杂度与点数相关 接下来是第二步，由于是无序边，我们想到顺序往右扫、并单向往左统计连边 对于关键点按$x$排序，顺序右扫。考虑先前加入的点与当前点能连多少边。那么我们还是需要用$x+y$和$x-y$作为两个特征储存先前的点。与（1）不一样的是，这回我们要统计等于某个特征值、$x$在某个范围内的点有多少个。这回我们不用set，而用map套vector，这样就可以通过二分来确定某个范围内有多少个点。由于$x$递增、我们要查询的范围也和$x$有关，所以当前点加入信息时，直接将其pushback到每个vector后即可]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【ARC063E】 Intergers on a tree]]></title>
    <url>%2F2018%2F09%2F04%2Farc063_e-Intergers-on-a-tree%2F</url>
    <content type="text"><![CDATA[Description 给定一棵$n$个点的树，其中若干个点的权值已经给出。现在请为剩余点填入一个值，使得相邻两个点的差的绝对值恰好为1。请判断能否实现，如果能，请将方案一并输出。 Solution 卡了一会，终于想出来了。 首先从深度奇偶性和权值奇偶性这一方面考虑：如果所有已知点的权值与深度的奇偶性关系不全一样，则一定无解。 然后考虑怎么构造。如果用已填点将树分成若干块，显然每一块是独立的，现在考虑单独一块。 直接想有一点困难，所以我们先尝试考虑每一个空点$u$能填什么数：考虑这一个块中的一个有值点，其权值为$x$，如果它到$u$距离为$2k$，那么$u$的权值范围就有$x-2k,x-2k+2,…,x,…,x+2k-1,x+2k$；如果它到$u$距离为$2k+1$，那么$u$的权值范围就为$x-2k-1,x-2k+1,x-2k+3…,x+2k-1,x+2k+1$。 考虑所有的有值点，那么$u$的权值范围就是这些范围的交$S$。也就是说，只要$u$填$S$中的权值，单看$u$而言就一定能填出满足所有有值点的方案。若$S$为空则全局无解。 可是对于每个空点，我们到底选$S$中的哪个权值填入呢？注意到如果随便填的话，可能会出现跳跃的问题。 我画了几个例子。构造例子的方法是先弄一棵填好权值的合法树，再指定有值位置。当我用上述方法考虑空点的$S$时，我们发现：当且仅当将每一个点都取其$S$中的最小值时有解（或都取最大值），原问题才有解，这种填法即一种合法方案；否则无解。 口胡证明：考虑一个点$u$的取值集合$S$，它其实是一个范围$[l,r]$，但中间的取值是每隔1取一个的。对于任意一个与$u$相邻的点$v$，记其权值范围为$[l’,r’]$，则其权值边界的跨度都不会超过1，即有$l’=l\pm1$和$r’=r \pm1$，注意两者不是互不相关的。为什么？$S$记录的是每一个有值点$x$到这个点对应的权值范围的交。走多一步，意味着空隙翻转（原来是跳一次取一次的），对于走近了的$x$，其权值范围以$x$为中心向内空隙翻转，对于走远了的$x$，其权值范围向外空隙翻转；也就是一个多了两端，一个少了两端。仔细分析，$S$的边界变化也不会超过1. 如果有解，那么这样填数一定能够满足条件———我们是贴着边界走的，而有值点本身也在边界上。如果这样填都不能满足，显然全局无解。 因此我们对每个点取$S$的最小值，判断是否合法即可。 至于$S$最小值的计算方法，这里有一个技巧：对于每个点$u$，我们直接维护所有有值点$x$对应的范围的左端点的最大值，即$x-dis$的最大值。这样一来，如果真正意义上$S$交集不为空，那么这个值就是$u$的取值。否则，这个值无论如何都会使得后面的判定出错不合法，毕竟取值不满足所有的有值点。 Summary 如果在构造过程中感觉选择太多、无从下手，不妨在危险的边缘试探：贴着边界条件走（就像闭眼游泳贴着水线一样） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N=100005;const int INF=1e9;int n,m;int a[N];int h[N],tot,dep[N];struct Edge&#123; int v,next;&#125;e[N*2];int f[N],g[N],ans[N];inline int max(int x,int y)&#123; return x&gt;y?x:y;&#125;inline int abs(int x)&#123; return x&gt;=0?x:-x;&#125;void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); int u,v; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125; memset(a,-1,sizeof a); scanf("%d",&amp;m); for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); a[u]=v; &#125;&#125;void mark_dfs(int u,int fa)&#123; dep[u]=dep[fa]+1; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) mark_dfs(v,u);&#125;bool firstCheck()&#123; mark_dfs(1,0); int flag=-1; for(int u=1;u&lt;=n;u++) if(a[u]!=-1)&#123; if(flag==-1) flag=(a[u]^dep[u])&amp;1; else if(((a[u]^dep[u])&amp;1)!=flag) return false; &#125; return true;&#125;void dp_dfs1(int u,int fa)&#123; f[u]=(a[u]!=-1)?a[u]:-INF; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; dp_dfs1(v,u); f[u]=max(f[u],f[v]-1); &#125;&#125;bool dp_dfs2(int u,int fa)&#123; if(a[u]!=-1) g[u]=a[u]; ans[u]=(a[u]!=-1)?a[u]:max(f[u],g[u]); if(fa&amp;&amp;abs(ans[u]-ans[fa])!=1) return false; static int ch[N],cnt; static int l[N],r[N]; cnt=0; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) ch[++cnt]=v; l[0]=g[u]+1; r[cnt+1]=-INF; for(int i=1;i&lt;=cnt;i++) l[i]=max(l[i-1],f[ch[i]]); for(int i=cnt;i&gt;=1;i--) r[i]=max(r[i+1],f[ch[i]]); for(int i=1;i&lt;=cnt;i++) g[ch[i]]=max(l[i-1],r[i+1])-2; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; if(dp_dfs2(v,u)==false) return false; if(abs(ans[u]-ans[v])!=1) return false; &#125; return true;&#125;bool solve()&#123; dp_dfs1(1,0); g[1]=-INF; if(dp_dfs2(1,0)==false) return false; puts("Yes"); for(int i=1;i&lt;=n;i++) printf("%d\n",ans[i]); return true;&#125;int main()&#123; readData(); if(!firstCheck()||!solve())&#123; puts("No"); return 0; &#125; return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC014E】 Blue and Red Tree]]></title>
    <url>%2F2018%2F09%2F04%2Fagc014_e-Blue-and-Red-Tree%2F</url>
    <content type="text"><![CDATA[Description给定一棵$n$个节点的蓝边树，再给定一棵$n$个节点的红边树。请通过若干次操作将蓝树变成红树。操作要求和过程如下： 1.选定一条边全为蓝色的路径； 2.将路径上的一条蓝边断开，并将路径的两个端点之间连一条红边。 问能否实现目标。 Solution我们发现这个过程只会做恰好$n-1$次，因为每次都会减少一条蓝边、增加一条红边。 考虑红树上的一条边$(u,v)$，显然在蓝树上操作时，我们选择了一条以$u$和$v$为端点的路径，才造就了这条边。因此红树上的每条边和蓝树上的每次操作一一对应。 我们相当于要以某种顺序执行这些操作：对于操作$(u,v)$，保证操作前$u$和$v$连通，然后我们断开$u$到$v$路径上的一条边。问所有操作能否执行完。 如果我们要执行一个操作A，那么对于当下该路径上的所有边，我们只能断开只有A占用的边。形式化地讲，如果对于每一个未执行操作，都将路径上的边+1；那么当前我们只能断开边权为1的边。 我们想用树剖的方式维护并模拟这个操作，但这非常难实现。因为寻找边权为1的边这个操作，或许还需要树套树来维护，非常麻烦。 正难则反，考虑整个过程反向进行： 对于最后一次操作，树上一定只剩下一条边$(u,v)$，且最后一次操作也是$(u,v)$。考虑倒数第二次操作，它要么是$(u,z)$，$z$是从最后一次操作的$(u,v)$这条边延伸出的另一条边$(v,z)$，要么是另成的一条独立的边$(x,y)$….. 手玩一会，我们发现：如果把两棵树建在一起，那么每次可操作的边，就是两棵树中都存在的边。操作完之后，我们把操作边的两个端点缩点，继续重复上述操作。如果操作能够执行恰好$n-1$次，则有解，否则无解。 接下来关键是怎么实现。我们根据想的方法，将两棵树实实在在地建在一起。用$n$个set维护每个点的出边到达点，用一个map维护两两点之间边的数量。如果某两个点之间的连边数量等于2，则肯定这条边在两棵树中间都出席那了，我们将这两个点组成的边塞进队列里，表示这个队列里的边在当前都可以操作。接下来，我们不断从队头拿出边，进行缩点操作：启发式合并set，删边或加边直接操作set和map就好。 时间复杂度$\mathcal O(n \log^2 n)$ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;queue&gt;#include &lt;map&gt;#define mp make_pairusing namespace std;typedef long long ll;typedef pair&lt;int,int&gt; pii;typedef set&lt;int&gt; si;typedef set&lt;int&gt;::iterator sit;const int N=100005;int n;int bl[N];si s[N];queue&lt;pii&gt; q;map&lt;ll,int&gt; g;inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125; int find(int u)&#123; return bl[u]==u?u:(bl[u]=find(bl[u]));&#125;inline ll getID(int x,int y)&#123; if(x&gt;y) swap(x,y); return 1ll*n*y+x;&#125;void addEdge(int u,int v)&#123; s[u].insert(v); s[v].insert(u); ll eid=getID(u,v); int t=g[eid]+1; g[eid]++; if(t==2) q.push(mp(u,v));&#125;void removeEdge(int u,int v)&#123; s[u].erase(v); s[v].erase(u); g.erase(getID(u,v));&#125;void readData()&#123; scanf("%d",&amp;n); int u,v; for(int i=1;i&lt;=(n-1)&lt;&lt;1;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125;&#125;bool solve()&#123; for(int i=1;i&lt;=n;i++) bl[i]=i; for(int i=1;i&lt;n;i++)&#123; int u,v; if(q.empty()) return false; u=q.front().first; v=q.front().second; q.pop(); u=find(u); v=find(v); if(s[u].size()&gt;s[v].size()) swap(u,v); bl[u]=v; removeEdge(u,v); for(sit i=s[u].begin(),j;i!=s[u].end();i=j)&#123; j=i; j++; int x=*i; x=find(x); removeEdge(u,x); addEdge(v,x); &#125; &#125; return true;&#125;int main()&#123; readData(); puts(solve()?"YES":"NO"); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC082E】ConvexScore]]></title>
    <url>%2F2018%2F08%2F29%2Farc082_e-ConvexScore%2F</url>
    <content type="text"><![CDATA[Description给定二维直角坐标系上的N个点$(X_i,Y_i)$,定义一个有N个点中的部分点所构成点集为“凸点集”，当且仅当该集合内的所有点恰好构成一个面积为正的凸多边形（每个内角严格小于180°） 对于每一个凸点集S，设这N个在该点集对应凸多边形内（包括边界）的数量为m，则该凸点集对答案的贡献的为$2^{m-\mid S\mid }$，求这N个点中每一个凸点集对答案的贡献之和。 由于最终答案可能非常大，你只需输出答案在模998244353意义下的结果。 Solution 看起来很吓人。 我们先定义一个由点集到凸包外壳集的函数：$f(S)$表示点集$S$的凸包外壳点集。 对于某一个点集$S\cup T$，其中凸包外壳为$S$，内含点集为$T$，则其凸包外壳$f(S+T)=S$。整个凸包对答案的贡献为$2^{\mid T\mid }$，即$T$的子集个数。对于子集$T’\subset T$，$f(S+T’)$都为$S$。我们相当于统计外壳固定时，有多少种点集不影响外壳。 那么我们不就相当于把每一个凸包点集都枚举了恰好一次吗？反向考虑，任意一个有效凸包点集$A$，我们发现其仅会在固定$f(A)$这个凸包外壳统计答案的时候贡献恰好一次。 所以总答案变成：原图有多少个凸包…. 有效凸包数，等于总非空点集数，减去单点凸包$N$，减去双点凸包$N \choose 2$，再减去共线凸包个数。最后一个部分可以用最小/大表示法计算，即枚举每个共线凸包编号最小/大的两个点，计算这两个点的直线，再判断使用比这两个点编号大/小的点能与这两个点组成多少个共线凸包。 这题要怎么说啊，首先要对那个2的幂敏感，看出子集个数的概念。如果正面想求和意义实在行不通，不妨尝试从元素贡献来反向考虑。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;using namespace std;const int N=205;const int MOD=998244353;int n;struct Point&#123; int x,y; Point()&#123;&#125; Point(int _x,int _y)&#123; x=_x; y=_y; &#125; friend Point operator - (Point a,Point b)&#123; return Point(a.x-b.x,a.y-b.y); &#125;&#125;a[N];int pow2[N];void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].x,&amp;a[i].y);&#125;void initPow()&#123; pow2[0]=1; for(int i=1;i&lt;=n;i++) pow2[i]=(pow2[i-1]&lt;&lt;1)%MOD;&#125;int cross(Point a,Point b)&#123; return a.x*b.y-a.y*b.x;&#125;bool on_line(int i,int j,int k)&#123; return cross(a[j]-a[i],a[k]-a[i])==0;&#125;void solve()&#123; int ans=(1ll*pow2[n]-(1ll*n*(n-1)/2)-n-1)%MOD; for(int i=2;i&lt;n;i++) for(int j=i+1;j&lt;=n;j++)&#123; int sum=0; for(int k=1;k&lt;i;k++) if(on_line(i,j,k)) sum++; (ans-=pow2[sum]-1)%=MOD; &#125; printf("%d\n",ans&lt;0?ans+MOD:ans);&#125;int main()&#123; readData(); initPow(); solve(); return 0;&#125; ​]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC016E】Poor Turkeys]]></title>
    <url>%2F2018%2F08%2F29%2Fagc016_e-Poor-Turkeys%2F</url>
    <content type="text"><![CDATA[Description 有$n$（$1 \le n \le 400$）只鸡，接下来按顺序进行$m$（$1 \le m \le 10^5$）次操作。每次操作涉及两只鸡，如果都存在则随意拿走一只；如果只有一只存在，拿走这一只；如果都不存在，什么都不做。 求最后有多少对鸡（无序）可能共同存活。 Solution 个人认为单用集合的解释方法有失偏颇。 首先考虑枚举两只鸡，规定它们一定要存活，然后模拟过程。怎么看单次模拟的复杂度都不会小于$m$，因此要第一时间舍弃这种方法。 于是要换个角度考虑。我们看看能不能算出某一只鸡存活的条件，再枚举两只鸡，并判断它们的条件是否冲突。 假设我们令$a$必须存活。 先看那些与$a$有关的操作：显然，另一只鸡在该操作前必须存活。我们虽然得到了这个结论，但是这些操作的顺序有先后影响，并不好考虑。 为了消除后效性，我们从后往前考虑每个事件。如果遇到与$a$有关的事件$(a,b)$，我们必须令$b$在这个时刻前存活。这意味着下次遇到与$a$或$b$有关的事件，我们必须令另一者在这个时刻前存活。我们记如果”$a$必须存活”，当前所有必须存活的鸡组成的集合为$S$，则形式化地讲： 初始时，$S$里只有$a$ 1.如果遇到一个事件，其中一者属于$S$，则另一者必须在这个时刻前存活。我们将另一者加进$S$ 2.如果两者都属于$S$，则必须死一个。这立刻违反了$S$的定义，因此$a$不可能存活。我们将其纳入统计答案的考虑对象 3.如果两者都不属于$S$，由于我们从后往前考虑，即使这两者在更早的时间与$a$的生死有关，但那个有关的时刻结束之后，这两者的生死并不重要。因此这个事件不需要纳入考虑范围。 由此，扫完全部事件之后，依赖存活关系可以形象为一棵内向树（上述1.发生时，从另一者向属于$S$的一者连一条有向边），我们不再将其看做集合考虑，因为那无法解释接下来的事情。我们称它为$a$的存活树。 $a$的存活树的每一条边都代表着一次依赖事件，每一次事件的成功与否都决定了$a$能否存活。事件发生的具体顺序我们不需要知道，但是一定是按照从叶子节点向上的拓扑序发生的。 考虑两只鸡$a$和$b$能否存活。有了存活树的概念，却无从下手？先从简单的一面看：如果二者的存活树的点集无交，那么显然没有影响，二者可以共存。关键是如果有交，可以共存吗？ 对于一个点$x$，其在$a$和$b$的存活树中都出现。如果$x$在两棵树中的父亲不同，这代表着两次不同的事件，先后发生，却都依赖于$x$。则后发生的一者必然不能保证$x$存活，因此$a$和$b$有一个必须死。如果$x$在两棵树中的父亲相同，首先二者不可能是两个事件，不然二者自身都不可能存活，不在考虑范围之内；既然是同一个事件，那么它们在这一步的确共存，因为它们共同进行了有益的一步。我们会发现，两棵树中可能出现一些“共同链”，但这并不意味着二者可以共存。因为两棵树的根一定不同，所以“共同链”的链顶一定不是根，即“共同链”的链顶一定会出现第一个情况：父亲不一样，有一只鸡必须死。 由上证毕，两只鸡能共存，当且仅当存活树的点集无交集。 在实现时，不需要建树，树只是用来严格证明的，我们只需要计算出每只存活的鸡的存活树点集合即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;bitset&gt;using namespace std;const int N=405,M=10005;typedef bitset&lt;N&gt; bs400;int n,m;int a[M][2];bool die[N];bs400 b[N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=m;i++) scanf("%d%d",&amp;a[i][0],&amp;a[i][1]);&#125;void calc()&#123; for(int i=1;i&lt;=n;i++)&#123; b[i][i]=1; for(int j=m;j&gt;=1;j--)&#123; int u=a[j][0],v=a[j][1]; if(b[i][u]&amp;&amp;b[i][v])&#123; die[i]=true; break; &#125; else if(b[i][u]) b[i][v]=1; else if(b[i][v]) b[i][u]=1; &#125; &#125;&#125;void print()&#123; int ans=0; for(int i=1;i&lt;n;i++) if(!die[i]) for(int j=i+1;j&lt;=n;j++) if(!die[j])&#123; if((b[i]&amp;b[j]).none()) ans++; &#125; printf("%d\n",ans);&#125;int main()&#123; readData(); calc(); print(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mountainous landscape]]></title>
    <url>%2F2018%2F08%2F28%2FMountainous-landscape%2F</url>
    <content type="text"><![CDATA[Description现在在平面上给你一条折线 $P1P_2 \cdots P_n$ 。 $x$ 坐标是严格单调递增的。对于每一段折线 $P_iP{i+1}$ ，请你找一个最小的 $j$ ，使得 $j \gt i$ 且CJB走在 $PiP{i+1}$ 上能看到折线 $PjP{j+1}$ 的任何一个点。注意，CJB的高度无限趋于0但不可忽略。也就是说，请找一条编号最小的折线 $PjP{j+1}$ 使得 $j \gt i$ 且线段 $PjP{j+1}$相交。 Solution首先手玩。 考虑每一条射线$\alpha=(Pi,P{i+1})$的答案，其实就是最小的$j$，满足$j&gt;i$且$P_{j+1}$严格在该射线上方。 有效的、需要考虑的$P_{j+1}$，一定在由$(i,n]$这些点构成的凸包上。我们相当于要判定一条射线$\alpha$与凸包是否有交，并找到交线的具体位置。 第一个问题很好解决，二分凸包上最逼近射线$\alpha$斜率的点，若其在射线上方则凸包与射线有交，否则直接无解。 关键是第二个问题。我们知道射线与凸包有交，甚至可以知道具体是哪一条凸包边与射线相交，却不知道是哪一条原边与射线有交，无法输出答案。我们发现这个凸包的信息已经不足以解决我们的问题了，但我们可以二分继续做：如果按相同方法判定左凸包也与射线有交，那么显然答案在左边，递归左凸包计算，并返回其的答案；否则，只能到右凸包里寻找答案。 单次询问复杂度$\mathcal O(log^2)$。 关键思路是无法确定具体方案的时候，考虑利用存在性二分答案。另一个Tips是有关线段树的二分问题，不要总想着用二分套线段树，而应该想想能否用线段树上二分，后者一般是两个$log$，而前者是三个$log$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;cstdio&gt;#include &lt;vector&gt;#define pb push_backusing namespace std;namespace IO&#123; const int S=10000005; char buffer[S]; int pos; void Load()&#123; pos=0; fread(buffer,1,S,stdin); &#125; char getChar()&#123; return buffer[pos++]; &#125; int getInt()&#123; int x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125;&#125;using IO::getInt;const int N=100005;const double EPS=1e-6;typedef long long ll;typedef vector&lt;int&gt; vi;int n;struct Dot&#123; int x,y; &#125;a[N];bool slope_dec(int i,int j,int k)&#123; return 1ll*(a[j].y-a[i].y)*(a[k].x-a[j].x)&gt;1ll*(a[j].x-a[i].x)*(a[k].y-a[j].y);&#125;double slope(int i,int j)&#123; return 1.0*(a[j].y-a[i].y)/(a[j].x-a[i].x);&#125;void getline(int i,int j,double &amp;k,double &amp;b)&#123; k=slope(i,j); b=a[i].y-k*a[i].x;&#125;namespace SEG&#123; const int S=N*2; int rt,sz; int ch[S][2]; vi hull[S]; int top[S]; double k,b; void build(int &amp;u,int l,int r)&#123; u=++sz; hull[u]=vi(r-l+2); top[u]=0; for(int i=l;i&lt;=r+1;i++)&#123; while(top[u]&gt;=2&amp;&amp;!slope_dec(hull[u][top[u]-2],hull[u][top[u]-1],i)) top[u]--; hull[u][top[u]++]=i; &#125; hull[u].resize(top[u]); if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; void set(double _k,double _b)&#123; k=_k; b=_b; &#125; int find(int u)&#123; int l=0,r=top[u]-2,mid; while(l&lt;=r)&#123; int mid=(l+r)&gt;&gt;1; if(slope(hull[u][mid],hull[u][mid+1])&gt;k) l=mid+1; else r=mid-1; &#125; int who=hull[u][r+1]; return (k*a[who].x+b+EPS&lt;=a[who].y)?who-1:0; &#125; int query(int u,int l,int r,int L,int R)&#123; int mid=(l+r)&gt;&gt;1; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; if(l==r) return find(u); if(!find(u)) return 0; if(find(ch[u][0])) return query(ch[u][0],l,mid,L,R); else return query(ch[u][1],mid+1,r,L,R); &#125; if(R&lt;=mid) return query(ch[u][0],l,mid,L,R); else if(mid&lt;L) return query(ch[u][1],mid+1,r,L,R); else&#123; int left=query(ch[u][0],l,mid,L,mid); if(left) return left; return query(ch[u][1],mid+1,r,mid+1,R); &#125; &#125;&#125;void readData()&#123; n=getInt(); for(int i=1;i&lt;=n;i++) a[i].x=getInt(), a[i].y=getInt();&#125;void solve()&#123; for(int i=1;i&lt;n;i++) if(i&lt;=n-2)&#123; double k,b; getline(i,i+1,k,b); SEG::set(k,b); printf("%d ",SEG::query(SEG::rt,1,n-1,i+1,n-1)); &#125; else printf("0 "); puts("");&#125;int main()&#123; IO::Load(); readData(); SEG::build(SEG::rt,1,n-1); solve(); return 0;&#125;]]></content>
      <tags>
        <tag>二分答案</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CJB的大作]]></title>
    <url>%2F2018%2F08%2F28%2FCJB%E7%9A%84%E5%A4%A7%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Description给你一个长度不超过100的字符串。一共进行$N$次操作，第$i$次操作是将当前字符串复制一份接到后面，并将新的一份循环移位$k_i$（$1 \le k_i \le 100$）次。给出$M$（$1 \le M \le 100000$）个询问，每次询问所有操作完成之后，$[l,r]$中，某个字母出现了多少次。其中$1 \le l \le r \le 10^{18}$。 Solution我开场就写了2个小时的暴力分治，并惊喜地发现单个询问可以秒出。结果一组询问需要0.01s，拿到了40分的好成绩。 首先$N$只有约前60项是有意义的，因此总操作数大约是60次。 这种字符串变换题目要重点观察变换前和变换后是否有一大块一大块是相等的。比如某次操作前，字符串是$S$，$A$和$B$是$S$的两块（即$S=AB$）其中B的长度恰好是这次操作的偏移值。那么操作完之后，字符串的变化如下： AB\rightarrow AB\;BA既然只有60次操作，而每次操作的$B$的长度不超过100，我们完全可以算出每次操作的$B$串。即枚举每个字符，反向模拟这个字符是怎么从原串变换来的，即可在一个$\log$的时间确定每个字符是什么。 将询问查分，则我们要求$[1,n]$中有多少个$c$字符。 考虑从最后一次操作开始递归向前计算（其实应该是：最早的一次操作，满足操作后串长不小于$n$)。 如果$n$落在左边的$AB$内：那么直接递归前一次操作，返回其答案。 如果$n$落在右边的$B$内：左半边$AB$的答案显然，就是原串中这个字符的数量乘上左半边有多少个原串。对于右边部分，我们预处理出每次操作中$B$的字母前缀和，$O(1)$可询问$B$前缀字母数量。两者加起来就是答案。 如果$n$落在右边的$A$内：$ABB$的答案可以用上一个情况的思路直接算，而最右边的$A$的答案，其实就是最左边的$A$的对应位置的答案。和第一种情况一样，我们递归前一次操作即可知道这部分的答案。 我们发现总分治递归层数不会超过有效操作次数。因此这题可以在$\mathcal O(M\log 10^{18})$内解决。 ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;namespace IO&#123; const int S=20000005; char buffer[S]; int pos; void Load()&#123; pos=0; fread(buffer,1,S,stdin); &#125; char getChar()&#123; char res=buffer[pos++]; if(pos&gt;=S) Load(); return res; &#125; ll getLong()&#123; ll x=0,f=1; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; return x*f; &#125; int getStr(char *str)&#123; int len=0; for(char c=getChar();'a'&lt;=c&amp;&amp;c&lt;='z';c=getChar()) str[len++]=c; return len; &#125;&#125;using IO::getLong;using IO::getStr;const int N=110,B=70,C=26;const ll UP=2e18;char str[N];int slen;int n,m,off[100005];int pre[N][C],f[B][N][C];void readData()&#123; slen=IO::getStr(str+1); n=getLong(); m=getLong(); for(int i=1;i&lt;=n;i++) off[i]=getLong();&#125;inline ll get_len(int bit)&#123; return 1ll*slen*(1ll&lt;&lt;bit);&#125;char get_char(int bit,ll x)&#123; if(bit==0) return str[x]; ll mid=get_len(bit-1); if(x&lt;=mid) return get_char(bit-1,x); ll cut=mid+off[bit]; if(x&lt;=cut) return get_char(bit-1,mid-(cut-x)); else return get_char(bit-1,x-cut);&#125;void precount()&#123; for(int i=1;i&lt;=slen;i++)&#123; for(int j=0;j&lt;26;j++) pre[i][j]=pre[i-1][j]; pre[i][str[i]-'a']++; &#125; for(int i=1;get_len(i)&lt;UP;i++)&#123; ll mid=get_len(i-1); off[i]%=mid; for(int j=1;j&lt;=off[i];j++)&#123; for(int k=0;k&lt;26;k++) f[i][j][k]+=f[i][j-1][k]; char c=get_char(i-1,mid-off[i]+j); f[i][j][c-'a']++; &#125; &#125;&#125;ll solve(int bit,ll n,int c)&#123; if(bit==0) return pre[n][c]; ll mid=get_len(bit-1),cut=mid+off[bit]; if(n&lt;=mid) return solve(bit-1,n,c); if(n&lt;=cut) return 1ll*pre[slen][c]*(1ll&lt;&lt;(bit-1))+f[bit][n-mid][c]; else return 1ll*pre[slen][c]*(1ll&lt;&lt;(bit-1))+f[bit][cut-mid][c]+solve(bit-1,n-cut,c);&#125;ll calc(ll n,char c)&#123; if(!n) return 0; int bit; for(bit=0;get_len(bit)&lt;n;bit++); return solve(bit,n,c-'a');&#125;void answerQuery()&#123; ll l,r; char c[2]; for(int i=1;i&lt;=m;i++)&#123; l=getLong(); r=getLong(); getStr(c); printf("%lld\n",calc(r,c[0])-calc(l-1,c[0])); &#125;&#125;int main()&#123; IO::Load(); readData(); precount(); answerQuery(); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ1007】水平可见直线]]></title>
    <url>%2F2018%2F08%2F25%2F%5BBZOJ1007%5D%2F</url>
    <content type="text"><![CDATA[Description传送门 Solution感觉有点套路，反正我想不到。 首先对于斜率相同的直线，显然除了截距最大的一条，其他都是不可见的，直接删去。 观察答案的上表面，它其实是一个由所有可见直线围成的下凸包。 如果将剩余直线按斜率递增作为第一关键字、截距递减按第二关键字排序，并逐个加入，维护下凸包。 类似普通下凸包，我们开一个栈$s$表示当前凸包由哪一些直线组成。 新加入一条直线时，首先它在当前局面一定会作为凸包的一部分。但是它的加入导致哪一些直线被覆盖了呢？考虑栈尾直线是否被覆盖，它被覆盖的情况如下： 即当新直线与$S{t-1}$的交点的$x$坐标小于等于$S{t-1}$与$S_{t}$交点的$x$坐标时，$S_t$会被覆盖。所以我们不断将被覆盖的直线从队尾弹出，最后加入新直线。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=50005;int n;struct Line&#123;int k,b,id;&#125;a[N];int sta[N],top;bool cmp(const Line &amp;u,const Line &amp;v)&#123; if(u.k!=v.k) return u.k&lt;v.k; return u.b&gt;v.b;&#125;bool cmp2(const int &amp;u,const int &amp;v)&#123;return a[u].id&lt;a[v].id;&#125;double inter(int i,int j)&#123; return 1.0*(a[j].b-a[i].b)/(a[i].k-a[j].k); &#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].k,&amp;a[i].b),a[i].id=i; sort(a+1,a+1+n,cmp); int tn=n; n=0; for(int i=1,j;i&lt;=tn;)&#123; j=i; a[++n]=a[i]; for(i++;i&lt;=tn&amp;&amp;a[i].k==a[j].k;i++); &#125; for(int i=1;i&lt;=n;i++)&#123; while(top&gt;1&amp;&amp;inter(sta[top-1],i)&lt;=inter(sta[top-1],sta[top])) top--; sta[++top]=i; &#125; sort(sta+1,sta+1+top,cmp2); for(int i=1;i&lt;=top;i++) printf("%d ",a[sta[i]].id); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC006F】]]></title>
    <url>%2F2018%2F08%2F22%2Fagc006_f%2F</url>
    <content type="text"><![CDATA[Description题目链接 Solution首先，把输入矩阵看成邻接矩阵，将问题转化到图上。 现在的问题变成：给定一个有向图，如果存在$(u,v)$和$(v,w)$，则连边$(w,u)$，重复边不连。求最终状态下，整张图有多少条边。 第一个思路是各个弱联通块互不影响，既然初始时它们之间无边，则按照题目的操作方式，在之后也不会有连边。因此，我们对每个弱联通块分开考虑。 从连边数量级较大这一个方面看，猜想每个联通块的连边数量可能是结论相关。手玩一下图。 如果对每个弱联通块进行三色染色（即从一个点开始染$c$，其到达点染$c+1\mod 3$），可以推出一些东西： （1）如果染色冲突。这种情况下，必然出现了自环或二元环。这两种环的出现带来的变动是巨大的——手玩一下可以发现，这整个弱联通块会变成完全图（包括自环边也会出现）。 （2）如果颜色未用完。这种情况下，题目给出的扩展条件一次都使用不了。因此该弱联通块的边数与原来一样。 （3）如果染色未冲突，且颜色使用完全。我们可以把点按颜色分成三块。其中块内的点互不连边，0色块通过若干边连向1色，1色连向2色，2色连向0色。且任意点有至少一条出边或入边，否则不属于该弱联通块。有结论：0色内的所有点会各自连向1色内的所有点，1色的所有点将连向2色的所有点，2色同理。因为任意一对处于$x$色的点$u$和$x+1 \mod 3$色的点$v$，都可以通过某种方式连上边。 实现上，将图看成无向图进行联通块的搜索。每条边记录一下实际方向，以确定下一个点是$x+1 \mod 3$还是$x-1 \mod 3$ ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int N=100005;int n,m;int h[N],tot;struct Edge&#123; int v,f,next;&#125;e[N*2];int col[N],cnt,ecnt,sum[3],type;inline void addEdge(int u,int v,int f)&#123; e[++tot]=(Edge)&#123;v,f,h[u]&#125;; h[u]=tot;&#125;void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int u,v; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v,0); addEdge(v,u,1); &#125;&#125;int trans(int x,int f)&#123; if(f==0) x=(x+1)%3; else x=(x-1+3)%3; return x;&#125;void dfs(int u)&#123; cnt++; for(int i=h[u],v,f;i;i=e[i].next)&#123; v=e[i].v; f=e[i].f; if(!f) ecnt++; if(col[v]!=-1)&#123; if(col[v]!=trans(col[u],f)) type=-1; &#125; else&#123; col[v]=trans(col[u],f); if(type!=-1&amp;&amp;!sum[col[v]]) type++; sum[col[v]]++; dfs(v); &#125; &#125;&#125;void paint()&#123; ll ans=0; memset(col,-1,sizeof col); for(int i=1;i&lt;=n;i++) if(col[i]==-1)&#123; type=1; sum[0]=1; sum[1]=sum[2]=0; col[i]=0; cnt=ecnt=0; dfs(i); if(type==3) ans+=1LL*sum[0]*sum[1]+1LL*sum[1]*sum[2]+1LL*sum[2]*sum[0]; else if(type==-1) ans+=1LL*cnt*cnt; else ans+=ecnt; &#125; printf("%lld\n",ans);&#125;int main()&#123; readData(); paint(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC079F】Namori Gundy]]></title>
    <url>%2F2018%2F08%2F22%2Farc079_f%2F</url>
    <content type="text"><![CDATA[Description题目链接 大意：给一张基环外向树。要求给每一个点确定一个值，其值为所有后继点的$\text{mex}$。求是否存在确定权值方案。 Solution首先，对于叶子节点，其权值必定是0. 对于每一棵外向树，树上的每个点的权值都是唯一确定的。可以通过DFS计算得到。 然而，每棵外向树的根——环上的某个点$u$，其权值不是唯一确定的。因为它要考虑的后继，不仅包括在树上的后继，还有一个环上后继。 根据$\text{mex}$的性质，我们发现不管$u$的环上后继是多少，$u$始终只有两种取值：分别是只考虑树上后继时的一级$\text{mex}$与二级$\text{mex}$。 再一来可以发现，只要我们确定了环上的某个点$u$的权值，我们可以唯一确定地填出剩余环上点的权值。只需要模拟一圈计算回来，判断最终$u$的权值和开始确定的值是否相同即可。 任选一个环上点，两种值各试一次，只要一种OK则存在方案；否则无解。 要对这个$\text{mex}$的取值比较敏感，才能很快地发现“两种取值”这一性质。确定一个点的值就能唯一确定方案这一点只要不要脑抽退却了应该能够比较顺利地发现。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;using namespace std;const int N=200005;int n,pre[N],cnex[N];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];int a[N],len,mex[N][2];inline void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;pre[i]); addEdge(pre[i],i); &#125;&#125;void findCircle(int u)&#123; static int stk[N],top=0; static bool vis[N]; stk[++top]=u; vis[u]=true; if(vis[pre[u]])&#123; int v=pre[u]; cnex[v]=u; for(;stk[top]!=v;top--)&#123; cnex[stk[top]]=stk[top-1]; a[++len]=stk[top]; &#125; a[++len]=v; return; &#125; findCircle(pre[u]);&#125;void dfs(int u,int dep)&#123; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=cnex[u]) dfs(v,dep+1); static int cnt[N]; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=cnex[u]) cnt[mex[v][0]]++; for(mex[u][0]=0;cnt[mex[u][0]];mex[u][0]++); if(dep==0) for(mex[u][1]=mex[u][0]+1;cnt[mex[u][1]];mex[u][1]++); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=cnex[u]) cnt[mex[v][0]]--;&#125;bool run(int x)&#123; int last=x; for(int i=len-1;i&gt;=1;i--)&#123; int u=a[i]; last=(mex[u][0]==last)?mex[u][1]:mex[u][0]; &#125; last=(mex[a[len]][0]==last)?mex[a[len]][1]:mex[a[len]][0]; return x==last;&#125;bool judge()&#123; for(int i=1;i&lt;=len;i++) dfs(a[i],0); return run(mex[a[len]][0])||run(mex[a[len]][1]);&#125;int main()&#123; readData(); findCircle(1); puts(judge()?"POSSIBLE":"IMPOSSIBLE"); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>图论---基环外向树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4712】洪水]]></title>
    <url>%2F2018%2F08%2F21%2F%5BBZOJ4712%5D%2F</url>
    <content type="text"><![CDATA[Description​ 原题链接（权限题） ​ 题目大意：给一棵带点权的树，要求支持两种操作： ​ （1）给某一个点的权值加上$x$ ​ （2）令堵上一个点的代价为其权值，询问以某一个点$u$为根的子树中，至少花费多少代价，使得$u$与子树中的叶子节点不连通（不算$u$，可以赌叶子节点和$u$本身） ​ 点数$n \le 200000$ Solution​ 静态DP很好做：记$u$的点权为$w_u$，设$f_u$表示$u$子树的答案，则有 f_u=\min\{w_u,\sum_vf_v\}​ 现在要支持点权修改，怎么实现？这种题貌似叫动态DP，可以用树剖的套路来解决。 ​ 令$son_u$表示$u$的重儿子，我们把重儿子的权值分离出来： f_u=\min\{w_u,f_{son_u}+\sum_{v \ne son_u}f_v\}​ 令后面一个和式为$g_u$，则有 f_u=\min\{w_u,g_u+f_{son_u}\}​ 使用树链剖分维护两个值：每个点$u$的$w_u$与$g_u$。 ​ 接下来，在此表示法的意义下，我们考虑询问$u$时，其答案$f_u$具体怎么体现。根据套路，我们要尽可能用一种线段树能维护的问题形式表现答案。我们发现，$f_u$所含的比较的元素可以展开来看（其中$v_i$表示$u$的$i$级重儿子）： \min\{w_u,g_u+w_{v_1},g_u+g_{v_1}+w_{v_2},g_u+g_{v_1}+g_{v_2}+w_{v_3},...\}​ 这其实就是一个最小前缀和的形式，只不过前缀和的最后一个元素是该位置的$w$，其余元素是$g$。这其实很好实现，用线段树来维护每一条重链的最小前缀和。具体实现上，两两重链之间插入一个特殊点，其权值设为正无穷，以限制考虑的前缀不可在链之间跨越。 ​ 所以，$w$和$g$是真正记录在树剖中的数据，而每个点$u$的$f_u$，则是体现为从$u$点走重链向下的最小前缀和。 ​ 修改上，也是这类问题的一贯做法。首先单独修改$u$的权值$w_u$。根据定义，其他点的$w$一定不会受到影响。当下唯一影响的，就是$u$所在链链顶元素的$g$值。我们计算出于$u$修改$w_u$后与修改前，链顶$f$值的变化量。这个变化量只会影响到链顶的父亲——另一条重链上的某一个点的$g$值，在线段树上修改。我们发现，这时候我们的操作模式已经和“单独修改$u$的权值$w_u$”一模一样了，只不过初始时我们修改$w_u$通过线段树上推的方式间接影响全局，而现在我们通过直接修改$g_u$的方式直接影响全局。因此计算出该点修改前后，其链顶的$f$的差值，继续向上重复这一过程即可。 ​ 可以发现，这一过程发生的次数，就是从初始点往根节点走遇到的轻边数量。由于每一个点到根节点经过的轻链条数为$\mathcal O(\log n)$，因此单次修改的复杂度是$\mathcal O(\log ^2 n)$。 ​ 在做这题之前，我已经做过了类似的一道动态DP题，并且很快地想到了将重儿子的数据单独分离的套路。可是我在探究答案究竟怎么体现的时候卡住了，没有发现“最小前缀和”的形式，所以没有写出来。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=400005;const ll INF=1LL&lt;&lt;30;int n;ll w[N],f[N],g[N];int h[N],tot;struct Edge&#123; int v,next;&#125;e[N*2];int pre[N],dep[N],size[N],son[N],who[N],loc[N],locnt,top[N];inline ll min(ll x,ll y)&#123; return x&lt;y?x:y;&#125;inline void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%lld",w+i); int u,v; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125;&#125;void d_dfs1(int u,int fa)&#123; pre[u]=fa; dep[u]=dep[fa]+1; son[u]=0; size[u]=1; g[u]=0; bool have=false; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; have=true; d_dfs1(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; g[u]+=f[v]; &#125; if(!have) f[u]=w[u], g[u]=INF; else f[u]=min(w[u],g[u]);&#125;void d_dfs2(int u,int _top)&#123; top[u]=_top; loc[u]=++locnt; who[locnt]=u; if(!son[u])&#123; who[++locnt]=0; return; &#125; g[u]-=f[son[u]]; d_dfs2(son[u],_top); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=pre[u]&amp;&amp;v!=son[u]) d_dfs2(v,v);&#125;namespace SEG&#123; const int S=N*2; int rt,sz; int ch[S][2]; ll sum[S],best[S]; void pushup(int u)&#123; sum[u]=sum[ch[u][0]]+sum[ch[u][1]]; best[u]=min(best[ch[u][0]],sum[ch[u][0]]+best[ch[u][1]]); &#125; void build(int &amp;u,int l,int r)&#123; u=++sz; if(l==r)&#123; int x=who[l]; sum[u]=g[x]; best[u]=w[x]; return; &#125; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); pushup(u); &#125; void modify(int u,int l,int r,int pos,ll delta)&#123; if(l==r)&#123; int x=who[l]; best[u]=w[x]; sum[u]+=delta; return; &#125; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) modify(ch[u][0],l,mid,pos,delta); else modify(ch[u][1],mid+1,r,pos,delta); pushup(u); &#125; ll query(int u,int l,int r,int L,ll &amp;lsum)&#123; if(L&lt;=l)&#123; ll res=lsum+best[u]; lsum+=sum[u]; return res; &#125; int mid=(l+r)&gt;&gt;1; ll res=INF; if(L&lt;=mid) res=min(res,query(ch[u][0],l,mid,L,lsum)); res=min(res,query(ch[u][1],mid+1,r,L,lsum)); return res; &#125; ll queryBest(int l)&#123; ll lsum=0; return query(rt,1,locnt,l,lsum); &#125;&#125;void initTree()&#123; d_dfs1(1,0); d_dfs2(1,1); w[0]=INF; SEG::build(SEG::rt,1,locnt);&#125;void modify(int u,ll x)&#123; ll delta=0,oldval,newval; w[u]+=x; for(;u;u=pre[top[u]])&#123; oldval=SEG::queryBest(loc[top[u]]); SEG::modify(SEG::rt,1,locnt,loc[u],delta); newval=SEG::queryBest(loc[top[u]]); delta=newval-oldval; if(!delta) break; &#125;&#125;void answerQuery()&#123; int q; char opt[2]; ll x,y; scanf("%d",&amp;q); while(q--)&#123; scanf("%s%lld",opt,&amp;x); if(opt[0]=='Q') printf("%lld\n",SEG::queryBest(loc[x])); else&#123; scanf("%lld",&amp;y); modify(x,y); &#125; &#125;&#125;int main()&#123; readData(); initTree(); answerQuery(); return 0;&#125; ​]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>DP---动态DP</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC076F】Exhausted]]></title>
    <url>%2F2018%2F08%2F17%2Farc076_f-Exhausted%2F</url>
    <content type="text"><![CDATA[Description​ 题目链接 Solution​ 场上尝试使用优化建图网络流实现，结果T到怀疑人生。 ​ 鉴于这是个匹配问题，考虑用贪心做一下。 ​ 先退一步，想一下如果每一个人只有$[1,l_i]$单个限制时怎么匹配。 ​ 我们应该对所有人按$l_i$从小到大排序。从前往后扫一次，能放则放，就能做到最大匹配。 ​ 再加上$[r_i,m]$这一种选择，要怎么做？ ​ 上面的贪心法，如果只考虑靠左端的匹配，是正确的；但不被匹配的人，显然要单独拉出，做一次按$r$的与上一个样的贪心。我们能不能在进行左端贪心的时候，保证剩余的人在第二次右端贪心时全局最优呢？有一种直接的想法，就是剩余人的$r$要尽可能的小，这样才能最大化匹配成功率。 ​ 依然按$l_i$从小到大排序，能放则放；如果不能放呢？这时候我们要考虑多一些东西了，我们还有一种选择，就是用当前的人替代掉之前选择的一个人。如果当前人能替代已选择的某一个人，应该满足一个条件，就是当前人的$r$要大于已经选择的某一个人的$r$。如果这样一个人存在，显然用将那个人的位置空出来，让当前人进去，而让那个人不填更加优，因为这样可以使未填的人的$r$尽可能小，最大化匹配成功率。 ​ 因此对于已选择的人，关于$r$维护一个小根堆。如果能加则加，否则和堆顶的$r$进行比较，能替换则替换。 ​ 最后对于未选择的人，进行一次从右向左对于$r$的贪心即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N=200005;int n,m;struct People&#123; int l,r,id; friend bool operator &lt; (People a,People b)&#123; return a.r&gt;b.r; &#125;&#125;a[N],b[N];bool inq[N];int cnt;priority_queue&lt;People&gt; q;bool cmpl(const People &amp;a,const People &amp;b)&#123; return a.l&lt;b.l;&#125;bool cmpr(const People &amp;a,const People &amp;b)&#123; return a.r&gt;b.r;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;a[i].l,&amp;a[i].r); sort(a+1,a+1+n,cmpl); int nowl=0,nowr=m+1,last; for(int i=1;i&lt;=n;i++)&#123; a[i].id=i; if(nowl+1&lt;=a[i].l)&#123; nowl++; q.push(a[i]); inq[i]=true; &#125; else if(!q.empty())&#123; People best=q.top(); if(a[i].r&gt;best.r)&#123; q.pop(); inq[best.id]=false; q.push(a[i]); inq[i]=true; &#125; &#125; &#125; for(int i=1;i&lt;=n;i++) if(!inq[i]) b[++cnt]=a[i]; sort(b+1,b+1+cnt,cmpr); for(int i=1;i&lt;=cnt&amp;&amp;nowr-1!=nowl;i++) if(nowr-1&gt;=b[i].r) nowr--; printf("%d\n",n-(nowl+(m-nowr+1))); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC006E】Rotate 3x3]]></title>
    <url>%2F2018%2F08%2F16%2Fagc006_e-Rotate-3x3%2F</url>
    <content type="text"><![CDATA[Description​ 题目链接 Solution​ 显然每一列只能一起动，乱动则无解。 ​ 对原网格按列黑白染色，显然每一列数只能在相同颜色之间交换，乱动则无解。 ​ 之后考虑构造方案。 ​ 我们需要发(shou)现(wan)出一些好用的变换： ​ （1）使一种颜色的相邻两列同时上下翻转。 ​ （2）使一种颜色的相邻两列交换，不翻转它们，而翻转另一个颜色中，不在这两列中间的，一个列。由于$n \ge 5$，我们总能实现这个操作。 ​ 统计出黑色列总共需要使用（2）交换多少次达到目标、以及需要翻转多少次（由于使用（2）不影响上下状态，直接用初始状态作比较即可），记为$flip_0$与$inv_0$，同理对白色列计算$flip_1$与$inv_1$。 ​ 我们首先使用（2）逐一实现每一个$flip_0$，每做一次$flip_0$的同时，$inv_1$也会减少一次。同理每做一次$flip_1$，$inv_0$也会减少一次。 ​ 优先做完$flip_0$与$flip_1$，此时$inv$不论是正负都没关系（负也是有意义的），只要是偶数，就可以使用（1）逐个翻转回来。重要的是此时$inv$必须是偶数，这意味着没操作前，当且仅当$flip_0$与$inv_1$的奇偶性相同，且$flip_1$与$inv_0$的奇偶性相同时，才有解，否则无解。 ​ 对于$flip$的计算，使用冒泡排序类模拟的套路，通过统计原位置右边有多少已操作的数来计算出当前实际位置，从而确定每一次冒泡的步数。 ​ 总时间复杂度$\mathcal O (n \log_2 n)$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;using namespace std;const int N=100005;int n;int a[N][3],where[N];int inv[2],flip[2];inline int abs(int x)&#123; return x&lt;0?-x:x;&#125;void readData()&#123; scanf("%d",&amp;n); for(int j=0;j&lt;3;j++) for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i][j]);&#125;bool preDraw()&#123; for(int i=1;i&lt;=n;i++)&#123; int id=(a[i][0]-1)/3+1; if((i-id)&amp;1) return false; where[id]=i; int x=(id-1)*3+1,y=x+1,z=y+1; if(a[i][0]==x&amp;&amp;a[i][1]==y&amp;&amp;a[i][2]==z); else if(a[i][0]==z&amp;&amp;a[i][1]==y&amp;&amp;a[i][2]==x) inv[i&amp;1]^=1; else return false; &#125; return true;&#125;namespace BIT&#123; //suffix sum int a[N]; inline void add(int u,int x)&#123; for(;u;u-=u&amp;-u) a[u]+=x; &#125; inline int que(int u)&#123; int res=0; for(;u&amp;&amp;u&lt;=n;u+=u&amp;-u) res+=a[u]; return res; &#125; inline void reset()&#123; for(int i=1;i&lt;=n;i++) a[i]=0; &#125;&#125;void calcFlip()&#123; for(int i=1;i&lt;=n;i+=2)&#123; int nowpos=where[i]+BIT::que(where[i])*2; flip[1]^=(abs(i-nowpos)/2)&amp;1; BIT::add(where[i],1); &#125; BIT::reset(); for(int i=2;i&lt;=n;i+=2)&#123; int nowpos=where[i]+BIT::que(where[i])*2; flip[0]^=(abs(i-nowpos)/2)&amp;1; BIT::add(where[i],1); &#125;&#125;int main()&#123; readData(); if(!preDraw())&#123; puts("No"); return 0; &#125; calcFlip(); if(inv[0]!=flip[1]||inv[1]!=flip[0]) puts("No"); else puts("Yes"); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>思考题</tag>
        <tag>结论题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC003F】Fraction of Fractal]]></title>
    <url>%2F2018%2F08%2F16%2Fagc003_f-Fraction-of-Fractal%2F</url>
    <content type="text"><![CDATA[Description原题链接 Solution神题。 定义一个上边界或下边界的格子为”上下接口“，当且仅当上下边界该位置的格子都是黑色的。 ”左右接口“同理。 首先特判掉$k \le 1 $的情况，答案都是1。 然后特判掉两种情况：上下接口和左右接口同时存在时，答案显然为1；二者皆不存在时，答案就是$s^{k-1}$，其中$s$为给定网格的黑格子数目。 所以接下来我们考虑的问题是：$k\ge 2$，且仅存在上下接口或左右接口。现在我们只考虑前者的情况，后者可以通过旋转原网格来达到同样的效果。 首先来观察2级分形的结构：我们不妨把其中的每一块1级分形看做一个节点，如果两个相邻1级分形可以互相连通，则视为将其对应节点之间连一条边。由此我们对2级分形构造出一张图。 对于3级及其以上分形，节点与边的定义不再扩展，依然是1级分形、表示1级分形之间是否连通。 可以发现，由于当前只存在上下接口，因此2级分形的图是由若干条竖直方向的链构成的。推广一下，就会发现，对于$k$级分形$(k \ge 2)$对应的图，它们都有着这个性质。 将链看成树，我们就可以运用森林的性质：树的个数等于总点数减去总边数。则连通块个数等于总点数减去总边数。 记$a$表示给定网格样式中，上下两个格子都是黑色的位置有多少，即$\sum [map{i,j}=map{i+1,j}=’#‘]$ 记$b$表示上下接口的个数（同一列的两个接口只算1个） 记$V_k$表示$k$级分形图中点的个数，$E_k$表示$k$级分形图中边的条数。则有递推式： $V_2=s$，$E_2=a$ $Vk=V{k-1}s$，$Ek=E{k-1}s+ab^{k-2}$ 其中$V$的递推显然，而$E$的含义则是：每个低级分形中边个数乘上扩增倍数，加上低级分形在组合成高级分形时通过上下接口新产生的边数。注意$b$之所以含有一个幂形式，是因为随着分形级数的不断扩增，上下接口的数量也在不断增长。 使用矩阵快速幂计算就做完了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int N=1005;const int MOD=1e9+7;int n,m,blacksum;ll kk;char str[N][N];int map[N][N];int hcnt,vcnt,lh,lv;inline void plus(int &amp;x,int y)&#123; x=(x+y&gt;=MOD)?(x+y-MOD):x+y;&#125;inline void swap(int &amp;x,int &amp;y)&#123; x^=y^=x^=y;&#125;inline int fmi(int x,ll y)&#123; int res=1; for(;y;x=1LL*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%MOD; return res;&#125;struct Mat&#123; int n,m; int a[4][4]; Mat()&#123; memset(a,0,sizeof a); &#125; Mat(int _n,int _m)&#123; n=_n; m=_m; clear(); &#125; void setUnit()&#123; if(n!=m) return; for(int i=1;i&lt;=n;i++) a[i][i]=1; &#125; void clear()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) a[i][j]=0; &#125; friend Mat operator * (Mat u,Mat v)&#123; Mat res=Mat(u.n,v.m); for(int i=1;i&lt;=u.n;i++) for(int j=1;j&lt;=v.m;j++) for(int k=1;k&lt;=u.m;k++) //(res.a[i][j]+=1LL*u.a[i][k]*v.a[k][j]%MOD)%=MOD; plus(res.a[i][j],1LL*u.a[i][k]*v.a[k][j]%MOD); return res; &#125;&#125;O,T;void readData()&#123; scanf("%d%d%lld",&amp;n,&amp;m,&amp;kk); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",str[i]+1); for(int j=1;j&lt;=m;j++) blacksum+=(str[i][j]=='#'); &#125;&#125;int getTypeAndInit()&#123; for(int i=1;i&lt;=n;i++) hcnt+=(str[i][1]=='#'&amp;&amp;str[i][m]=='#'); for(int j=1;j&lt;=m;j++) vcnt+=(str[1][j]=='#'&amp;&amp;str[n][j]=='#'); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; if(j&lt;m) lh+=(str[i][j]=='#'&amp;&amp;str[i][j+1]=='#'); if(i&lt;n) lv+=(str[i][j]=='#'&amp;&amp;str[i+1][j]=='#'); &#125; if(hcnt&amp;&amp;vcnt) return 1; else if(!hcnt&amp;&amp;!vcnt) return 2; if(hcnt)&#123; swap(hcnt,vcnt); swap(lh,lv); &#125; return 3;&#125;void fillMatrix()&#123; O=Mat(1,3); O.a[1][1]=blacksum; O.a[1][2]=lv; O.a[1][3]=vcnt; T=Mat(3,3); T.a[1][1]=blacksum; T.a[2][2]=blacksum; T.a[3][2]=lv; T.a[3][3]=vcnt;&#125;Mat mat_fmi(Mat x,ll y)&#123; Mat res=Mat(x.n,x.n); res.setUnit(); for(;y;x=x*x,y&gt;&gt;=1) if(y&amp;1) res=res*x; return res;&#125;void solve()&#123; fillMatrix(); T=mat_fmi(T,kk-2); O=O*T; int ans=O.a[1][1]-O.a[1][2]; printf("%d\n",ans&lt;0?ans+MOD:ans);&#125;int main()&#123; readData(); if(kk&lt;=1)&#123; puts("1"); return 0; &#125; int type=getTypeAndInit(); if(type==1)//whole puts("1"); else if(type==2)//isolated printf("%d\n",kk==0?1:fmi(blacksum,kk-1)); else solve(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【ARC075F】Mirror]]></title>
    <url>%2F2018%2F08%2F14%2Farc075_f-Mirror%2F</url>
    <content type="text"><![CDATA[Description​ 给定正整数$D$，求有多少个正整数$N$，满足$rev(N)=N+D$。 ​ 其中$rev(N)​$表示将$N​$的十进制表示翻转来读得到的数（翻转后忽略前导零）。 ​ 答案对$10^9+7$取模。 ​ $D \le 10^{2500}$ Solution​ 原题$D \le 10^9$，暴力可过；但DP做法可以应用到更大的范围。 ​ ​ 考虑枚举$N$有多少位，记为$len$。 ​ 显然$len$不能小于$D$的位数，否则一定不合法。并且可以证明，$len$超过$D$的位数的两倍时，就没有数合法了。再者$len==1$的时候也显然不合法。所以枚举区间是$[\max (2,\mid D\mid ),2\mid D\mid]$。 ​ 设计一个DP来计算在$N$的长度为$len$时，有多少个数满足条件。 ​ 把和式画出来，并从两端向中间标号： ​ 为什么要这么标号？因为既然是翻转，所以确定一组中的一对数$(x,y)​$就可以确定另一对数$(y,x)​$。 ​ 还要考虑进位问题，那么状态里应该有表示进位的东西。 ​ 设$f_{i,j,k}$表示第$i$组数，其中左边一组数从其右边有无收到进位（$j=0,1$），且右边一组数给其左边有无进位（$k=0,1$）： ​ ​ 枚举状态$f{i,j,k}$，正向转移到可去的状态。枚举$i+1$组的$x’$选0…9，并通过右边一组数的$k$和相应位置的$D$的数位算出$y’’$与$k’$。再用左边一组数的$j$来计算出$j’$。如果$j’&lt;0$或者$j’&gt;1$就说明这个转移不合法，舍弃。因此，每个$x$的取值对应了唯一对应（有可能不合法，舍弃）的新状态$f{i+1,j’,k’}$，将方案数加上即可。 ​ 注意第1组数的$x$不可以选0，不然会违背当前正在考虑长度为$len$的$N$这个前提。 ​ 如果$len$是偶数，那么对于$i=1..\frac{len}{2}$计算$f$，答案即为$f{\frac{len}2,0,0}+f{\frac{len}2,1,1}$ ​ 如果$len$是奇数，则先对于$i=1…\lfloor \frac{len}2 \rfloor$计算$f$，先枚举每个最终状态，再枚举最中间一位选择$0…9$，是否能满足各个进位与否的要求，统计进答案即可。 ​ ​ 总时间复杂度$O(\frac{\mid D\mid^2}{2}\times 10\times 2\times2)$，当然，不是满的。]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>DP---数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC074E】 RGB sequence]]></title>
    <url>%2F2018%2F08%2F14%2Farc074_e-RGB-sequence%2F</url>
    <content type="text"><![CDATA[Description​ 一排$n$个格子，每个格子可以涂三种颜色的一种。现在给出$m$个形如“$[l,r]$中必须恰好有$x$种颜色”的限制（$1 \le l \le r \le n, 1 \le x \le 3$）。 ​ 求一共有多少种满足所有限制的合法涂色方案。 ​ 答案对$10^9+7$取模。 Solution​ 首先要想到状态表示法，如何表示才能适应这些限制呢？由于是限制颜色种类数，可以考虑最早出现位置这类套路。 ​ 设$f_{i,j,k}$表示：当前走完$1…i$，在$i$左边最靠右的、与$i$颜色不同的位置为$j$，在$j$左边最靠右的、与$i$和$j$颜色不同的位置为$k$时，目前合法染色方案数是多少。 ​ 逐步计算$f_1,f_2,…$。 ​ 接下来考虑限制。考虑在转移的时候逐一枚举限制来判断新状态是否合法。 ​ 则总复杂度是$\mathcal O(n^3m)$的。还有3倍常数，显然不够优秀。 ​ 然而这只是臆想做法，具体我也没实现出来，因为枚举限制的时候，限制的区间和$i,j,k$的位置的关系实在太多，不好写。 ​ 实际上，对于一个$[l,r]$的限制，它只需要去管$i==r$的那些状态是否合法即可。如果$i&lt;r$，那么显然还没有考虑的必要（都没填完$[l,r]$，考虑什么呢？）。如果$r&lt;i$那么已经晚了。所以每个条件至多被枚举一次。 ​ 因此总复杂度是$\mathcal O (n^2(n+m))$的。 ​ 所以下次觉得枚举限制条件十分复杂且时间复杂度爆炸的时候，不妨想一想限制条件或许只针对特定对象才起效果或必要，这样就可以减少总枚举次数，优化复杂度。 ​ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef pair&lt;int,int&gt; pii;const int N=310;const int MOD=1e9+7;int n,m;int f[N][N][N];vector&lt;pii&gt; lis[N];void readData()&#123; scanf("%d%d",&amp;n,&amp;m); int l,r,x; for(int i=1;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;l,&amp;r,&amp;x); lis[r].pb(mp(l,x)); &#125;&#125;void dp()&#123; f[1][0][0]=1; for(int i=1;i&lt;=n;i++)&#123; for(int d=0,sz=lis[i].size();d&lt;sz;d++)&#123; int l=lis[i][d].first,x=lis[i][d].second; for(int j=0;j&lt;i;j++) for(int k=0;k&lt;=(j-(j&gt;0));k++)&#123; if(x==1)&#123; if(l&lt;=j) f[i][j][k]=0; &#125; else if(x==2)&#123; if(l&lt;=k||j&lt;l) f[i][j][k]=0; &#125; else&#123; if(k&lt;l) f[i][j][k]=0; &#125; &#125; &#125; if(i==n) break; for(int j=0;j&lt;i;j++) for(int k=0;k&lt;=(j-(j&gt;0));k++) if(f[i][j][k])&#123; (f[i+1][j][k]+=f[i][j][k])%=MOD; (f[i+1][i][k]+=f[i][j][k])%=MOD; (f[i+1][i][j]+=f[i][j][k])%=MOD; &#125; &#125; int ans=0; for(int j=0;j&lt;n;j++) for(int k=0;k&lt;=(j-(j&gt;0));k++) (ans+=f[n][j][k])%=MOD; ans=1LL*ans*3%MOD; printf("%d\n",ans&lt;0?ans+MOD:ans);&#125;int main()&#123; readData(); dp(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>DP---计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC083E】]]></title>
    <url>%2F2018%2F08%2F09%2Farc083_e%2F</url>
    <content type="text"><![CDATA[Description​ 给一棵$n$个节点的树，和一个长度同样为$n$的非负整数序列$x_i$。 ​ 请尝试对每个节点染黑或白两种颜色，并确定一个非负整数权值。 ​ 问是否存在一种方案，使得每个点$i$满足其子树内与其同色的点的权值之和恰好为$x_i$。 ​ $1 \le n \le 1000$ ​ $0 \le x_i \le 5000$ Solution​ 一道好题。 ​ 我们自底向上逐步确定权值。假设当前正在考虑$u$这个点。 ​ 我们发现，$u$本身选黑还是白并不重要，其子树中的点只有两种：颜色和$u$相同的点，以及颜色和$u$不相同的点。 ​ 能确定的是，前一类的点的权值值和必须恰好等于$x_u$，而在这个条件下，后者的点的权值值和可以有多种情况。 ​ 回头看一下，对于一种合法方案，单看每一种颜色形成的树的话，每个点$u$都要满足“后继”（单看一个颜色形成的树意义下的后继）的$x$之和小于等于$x_u$，这样一来$u$的权值可以设为一个恰好的值，使得和调整为$x_u$。 ​ 显然我们可以对每个点$u$维护一个值$f_u$，表示在满足与$u$颜色相同的点的权值值和恰好为$x_u$时，与$u$颜色不同的点的权值之和最小是多少。这是一个贪心的思想，由于一种颜色的权值和只能是$x_u$，因此我们尽量保证另一种颜色的权值之和最小，以最大化这种颜色在之后考虑父亲节点时满足“小于等于”的可能性。 ​ 设$g_i$表示当前与$u$同色权值值和为$i$时，另一个颜色的最小值是多少。 ​ 初始有$g0=0,\;g{i}=\infty (i&gt;0)$ ​ 对于每个后继$v$，转移 g_i+f_v\rightarrow g_{i+x_v}\\g_i+x_v\rightarrow g_{i+f_v}​ 注意是非继承转移，即每层强制转移。 ​ 最后$f_u=\min g_i\;\;(0 \le i \le x_u)$ ​ 如果$f_1=\infty$就无解，否则有解。 ​ 此题关键是想到贪心的那一步。如果不贪心的话，相当于每个点有多个状态（另一个颜色有多种和）等待转移，根本做不了。 ​ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;using namespace std;const int N=1005,X=5005,INF=1e9;int n,a[N];int f[N],g1[X],g2[X];int h[N],tot;struct Edge&#123;int v,next;&#125;e[N*2];inline void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;void readData()&#123; scanf("%d",&amp;n); int fa; for(int i=2;i&lt;=n;i++)&#123; scanf("%d",&amp;fa); addEdge(fa,i); &#125; for(int i=1;i&lt;=n;i++) scanf("%d",a+i); &#125;void dfs(int u,int fa)&#123; bool have=false; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; have=true; dfs(v,u); &#125; if(!have)&#123; f[u]=0; return; &#125; for(int i=0;i&lt;=a[u];i++) g1[i]=INF; g1[0]=0; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; for(int j=0;j&lt;=a[u];j++) g2[j]=INF; for(int j=0;j&lt;=a[u]&amp;&amp;(j+a[v]&lt;=a[u]||j+f[v]&lt;=a[u]);j++) if(g1[j]!=INF)&#123; if(j+a[v]&lt;=a[u]) g2[j+a[v]]=min(g2[j+a[v]],g1[j]+f[v]); if(j+f[v]&lt;=a[u]) g2[j+f[v]]=min(g2[j+f[v]],g1[j]+a[v]); &#125; for(int j=0;j&lt;=a[u];j++) g1[j]=g2[j]; &#125; f[u]=INF; for(int i=0;i&lt;=a[u];i++) f[u]=min(f[u],g1[i]);&#125;int main()&#123; readData(); dfs(1,0); puts(f[1]==INF?"IMPOSSIBLE":"POSSIBLE"); return 0;&#125; ​ ​]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC069F】Flag]]></title>
    <url>%2F2018%2F08%2F08%2Farc069_f%2F</url>
    <content type="text"><![CDATA[Description​ 数轴上有 $n$个旗子，第$i$个可以插在坐标$x_i$或者$y_i$。 ​ 请最大化两两旗子之间的最小距离。 ​ $2 \le n \le 10^4$，$1 \le x_i,y_i \le 10^9$ Solution​ 这种有若干组决策，每种决策二选一，然后要求所有决策互相合法的问题，习惯性的要往2-sat想一想。 ​ 我们把每个旗子$i$插在$x_i$还是$y_i$看做一种决策，分别用两个点表示。 ​ 看起来二分答案比较靠谱。 ​ 问题转变为：判定是否存在一种方案，使得两两旗子之间的最小距离不小于$len$。 ​ 有了$x$，我们就很方便地进行逻辑连边了。 ​ 考虑每个旗子$i$的两个位置。如果该旗子选择了$x_i$，则对于所有处于$(x_i-len,x_i+len)$的位置（除了$x_i$），它们对应的旗子在决策时必须选择另一个可选位置，它们必须选择另外一个可选位置$p$。因此，从$x$向所有的$p$连一条边。 ​ 如果该旗子选择了$y_i$同理。 ​ 之后进行2-sat，即用Tarjan缩点。如果一个旗子的两个位置处于同一个强联通分量，则无解。否则一定可以构造出一种方案，由于这是一个判定问题，我们不需要真正构造。 ​ 由于点数较大无法$\mathcal O(n^2)$连边，我们使用线段树进行连边优化。 ​ 总时间复杂度为$\mathcal O(n \log_2 n \log_2 1e9)$ Code​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;#define pb push_backusing namespace std;const int N=10005,NUM=N*6;int n,p[N][2];int dcnt,d[N*2];unordered_map&lt;int,int&gt; tid;int lis[N*2];int nn;int dfntm,dfn[NUM],low[NUM],sta[NUM],top,bl[NUM],blcnt;bool ins[NUM];int h[NUM],tot;struct Edge&#123;int v,next;&#125;e[N*100];inline void addEdge(int u,int v)&#123; //printf("%d %d\n",u,v); e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d%d",&amp;p[i][0],&amp;p[i][1]);&#125;void Diz()&#123; for(int i=1;i&lt;=n;i++) d[++dcnt]=p[i][0], d[++dcnt]=p[i][1]; sort(d+1,d+1+dcnt); for(int i=1;i&lt;=dcnt;i++) if(d[i]!=d[i-1]) tid[d[i]]=i; for(int i=1;i&lt;=n;i++)&#123; int x=p[i][0]; p[i][0]=tid[p[i][0]]; tid[x]++; x=p[i][1]; p[i][1]=tid[p[i][1]]; tid[x]++; lis[p[i][0]]=n+i; lis[p[i][1]]=i; &#125;&#125;namespace SEG&#123; const int S=N*4; int rt,sz; int ch[S][2]; void reset()&#123; rt=sz=0; &#125; void build(int &amp;u,int l,int r)&#123; if(l==r)&#123; u=lis[l]; return; &#125; u=++sz; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); addEdge(u,ch[u][0]); addEdge(u,ch[u][1]); &#125; void link(int u,int l,int r,int L,int R,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; addEdge(v,u); return; &#125; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) link(ch[u][0],l,mid,L,R,v); else if(mid&lt;L) link(ch[u][1],mid+1,r,L,R,v); else&#123; link(ch[u][0],l,mid,L,mid,v); link(ch[u][1],mid+1,r,mid+1,R,v); &#125; &#125;&#125;void reset()&#123;//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! tot=0; dfntm=blcnt=0; top=0; for(int i=1;i&lt;=nn;i++)&#123; h[i]=0; dfn[i]=low[i]=bl[i]=0; &#125; SEG::reset();&#125;void tarjan(int u)&#123; dfn[u]=low[u]=++dfntm; sta[++top]=u; ins[u]=true; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; if(!dfn[v])&#123; tarjan(v); low[u]=min(low[u],low[v]); &#125; else if(ins[v]) low[u]=min(low[u],dfn[v]); &#125; if(dfn[u]==low[u])&#123; blcnt++; int x; do&#123; x=sta[top]; sta[top--]=0; ins[x]=false; bl[x]=blcnt; &#125;while(x!=u); &#125;&#125;bool judge(int x)&#123; reset(); SEG::sz=n*2; SEG::build(SEG::rt,1,dcnt); for(int i=1;i&lt;=n;i++)&#123; int l=lower_bound(d+1,d+1+dcnt,d[p[i][0]]-x+1)-d; int r=upper_bound(d+1,d+1+dcnt,d[p[i][0]]+x-1)-d-1; if(l&lt;=r)&#123; if(l&lt;p[i][0]) SEG::link(SEG::rt,1,dcnt,l,p[i][0]-1,i); if(p[i][0]&lt;r) SEG::link(SEG::rt,1,dcnt,p[i][0]+1,r,i); &#125; l=lower_bound(d+1,d+1+dcnt,d[p[i][1]]-x+1)-d; r=upper_bound(d+1,d+1+dcnt,d[p[i][1]]+x-1)-d-1; if(l&lt;=r)&#123; if(l&lt;p[i][1]) SEG::link(SEG::rt,1,dcnt,l,p[i][1]-1,n+i); if(p[i][1]&lt;r) SEG::link(SEG::rt,1,dcnt,p[i][1]+1,r,n+i); &#125; &#125; nn=SEG::sz; for(int i=1;i&lt;=nn;i++) if(!dfn[i]) tarjan(i); for(int i=1;i&lt;=n;i++) if(bl[i]==bl[n+i]) return false; return true;&#125;void solve()&#123; int l=0,r=1e9,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(judge(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); &#125;int main()&#123; readData(); Diz(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
        <tag>优化建图</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【XSY3030】]]></title>
    <url>%2F2018%2F08%2F07%2Fxsy3030%2F</url>
    <content type="text"><![CDATA[Description​ 现在 Yopilla 和 yww 要开始玩游戏！ ​ 他们在一条直线上标记了 $n$ 个点，从左往右依次标号为 $1, 2, …, n$ 。然后在每个点上放置一些棋子，其中第 $i$ 个点放置了 $a_i$ 个棋子。接下来，从 Yopilla 开始操作，双方轮流操作，谁不能操作谁输。每次的操作是：当前操作方选定一个有棋子的点 $x$ ，然后选择至少一个点 $x$ 上的棋子，然后把这些棋子全都移动到点 $x / prime$ 上，其中 $prime$ 是一个质数，且 $prime \mid x$ ​ Yopilla 最初一次操作的策略是随机的：随机找到一个有棋子的点 $x$ ，随机选择正整数个棋子 $y$ ，随机转移到一个能转移到的点 $z$ 。所有棋子可以看作是一样的，换句话说：两种操作不同，当且仅当三元组 $(x, y, z)$ 不同。之后双方都按照最优策略来操作。 ​ Yopilla 想要预测，他能够获胜的概率是多少，答案对 $998244353$ 取模。 ​ Solution​ 首先介绍阶梯Nim问题。 ​ 问题形式为：有$n$个位置$1…n$，每个位置上有$a_i$个石子。有两个人轮流操作。操作步骤是：挑选$1…n$中任一一个存在石子的位置$i$，将至少1个石子移动至$i-1$位置（也就是最后所有石子都堆在在0这个位置）。谁不能操作谁输。求先手必胜还是必败。 ​ 结论：问题等价于，求位置为奇数的$a_i$的异或和，若异或和等于0，则先手必败，否则先手必胜。你可能已经注意到这非常像$Nim$游戏。其实这个游戏恰好等价于，将每个奇数位置的数$x$看成一堆有$x$个石子的石子堆，然后玩$Nim$游戏。 ​ 证明：拿走某一堆石子的一部分，相当于将某个奇位置的石子移动到它左边的偶位置上。如果大家都只动奇位置的石子，那么这等价于两人在玩$Nim$游戏。但如果有人想打破规则呢？假设$Nim$游戏先手必胜，那么先手肯定优先玩$Nim$游戏；如果后手试图破坏局面，将某个偶位置上的若干石子移动到了左边的奇位置$i$上，那么先手可以将这若干个刚移到$i$的石子继续移动到$i$左边的偶位置上，对$Nim$局面依然没有任何影响，除非后手回头来继续动奇位置的石子，那也只能是输。那么如果$Nim$游戏先手必败，也是同理，后手可以用相同的方式迫使先手玩$Nim$游戏，直到输为止。 ​ 因此，奇数位置的石子的相关信息，就直接决定了阶梯$Nim$问题的结果。 ​ 我们发现，对于每一个数，如果以其幂指数之和为下标来将它们重新排列成一个数组，这个问题就变成了阶梯$Nim$问题。一次操作，相当于将一个数移动到其左边。不能移动者输。 ​ 事实上我们不需要实现这个重排操作。我们只需要知道每个数重排后是否在奇位置即可。 ​ 记输入数列为$a$，我们统计出所有处于奇位置的数$x$的$a_x$的异或和$sum$。 ​ 我们要统计Yopilla一开始的随机操作一共有多少种可能、以及总共有多少种可能，使得操作后局面的先手必败。前者很好计算，就是$\sum_x a_x*b_x$，其中$b_x$表示$x$这个数的不同质因子个数。 ​ 后者如何计算呢？对操作分类：（1）移动奇位置的数至偶位置、（2）移动偶位置的数至奇位置。 ​ 我们枚举所有奇位置的数。假设对该位置$i​$操作后，总异或和$sum​$等于0，即操作后先手必败，则$a_i​$应该由$a_i​$变成$target=sum\; \text{xor}\; a_i​$，如果原值比目标值大，那么显然（1）容易满足，选出$a_i-target​$个数，并将它们通过任意一个质因子移动到偶位置，一共有$b_i​$种合法情况。如果原值与目标值相等，则什么也做不了，一改就不满足要求，不作为合法情况考虑。若原值小于目标值，则考虑（2），枚举所有能转移到$i​$的偶位置$j=i*p​$（其中$p​$是枚举的质数），如果$a_j \ge target-a_i​$，那么合法情况就多了一种，因为$j​$可以选$target-a_i​$个数通过唯一一种方式——除去$p​$——来到达$i​$。 ​ 那么概率也就很好计算了。 ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;using namespace std;const int N=1000005,MOD=998244353;int n,a[N];bool vis[N];int p[N],pcnt,b[N],c[N];void sieve()&#123; int up=1e6; for(int i=2;i&lt;=up;i++)&#123; if(!vis[i])&#123; p[++pcnt]=i; b[i]=c[i]=1; &#125; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;=up;j++)&#123; int x=i*p[j]; vis[x]=true; c[x]=c[i]^1; if(i%p[j]==0)&#123; b[x]=b[i]; break; &#125; b[x]=b[i]+1; &#125; &#125;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i);&#125;inline int fmi(int x,int y)&#123; int res=1; for(;y;x=1LL*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%MOD; return res;&#125;void solve()&#123; int x=0; for(int i=1;i&lt;=n;i++) if(c[i]) x^=a[i]; int legal=0; for(int i=1;i&lt;=n;i++) if(c[i])&#123; int best=x^a[i]; if(best&lt;a[i]) legal+=b[i]; else&#123; int delta=best-a[i]; if(!delta) continue; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;=n;j++) if(a[i*p[j]]&gt;=delta) legal++; &#125; &#125; int all=0; for(int i=1;i&lt;=n;i++) (all+=1LL*a[i]*b[i]%MOD)%=MOD; int ans=1LL*legal*fmi(all,MOD-2)%MOD; printf("%d\n",ans&lt;0?ans+MOD:ans);&#125;int main()&#123; sieve(); readData(); solve(); return 0;&#125; ​ ​]]></content>
      <tags>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【ARC077F】SS]]></title>
    <url>%2F2018%2F08%2F07%2Farc077_f-SS%2F</url>
    <content type="text"><![CDATA[Description​ 如果某个串可以由两个一样的串前后连接得到，我们就称之为“偶串”。比如说“xyzxyz”和“aaaaaa”是偶串，而“ababab”和“xyzxy”则不是偶串。 ​ 对于一个非空串$S​$，我们定义$f(S)​$是在$S​$后面添加一些字符得到的最短偶串。比如$f(​$’abaaba’$)=​$’abaababaab’。容易证明，对于一个非空串$S​$，$f(S)​$是唯一的 。 ​ 现在给定一个由小写英文字母构成的偶串$S$，你需要求出$f^{10^{100}}(S)$，并统计计算结果的第$l$个字符到第$r$个字符中，每个字母出现了多少次 。 ​ 其中，$f^{10^{100}}(S)$是指$f(f(f(…f(S)…)))$，式子中共有$10^{100}$个$f$ 。 Solution​ 打表找规律。从整个串来寻找规律看不出什么，反而是分别考虑两半的变化比较有效。 ​ 我们称$T$为$S$的”Border”，当且仅当$S$作为$T$的循环串的前缀出现，且$T$长度最小。 ​ 现有输入串$SS$，令$S$的”Border”为$T$，则会发现： SS\rightarrow (ST)(ST)\rightarrow (STS)(STS)\rightarrow(STSST)(STSST)...​ 由于操作次数过多，只考虑前半部分的变化，就能回答所有询问： S\rightarrow ST\rightarrow STS\rightarrow STSST\rightarrow STSSTSTS​ 我们发现，从第三个串开始，每一个串$i$，都是由串$i-1$+串$i-2$得来。姑且称它们为$\text{fib}$串。 ​ 特别地：若$|S|-|T|$ 整除$|S|$，则变化为 S\rightarrow ST\rightarrow STT\rightarrow STTT...​ 特判掉这种情况。 ​ 记$leni$为第$i$个串的长度，$g{i,j}$为第$i$个串中$j$字符出现了多少次。由于$\text{fib}$在第85项左右就已经超出了$1e18$，因此我们可以暴力计算出这两个数组。 ​ 对答案差分，假设要求$1…r$中，每个字符的出现次数。 ​ 有结论是，只要有$len{x_1}+len{x2}+…+len{xk}=r$，且$len{x1}&gt;len{x2}&gt;…&gt;len{x_k}$，则$1…r$这个字符串就可以用$x_1,x_2,…,x_k$这$k$个$\text{fib}$串首尾相接得到。 ​ 所以对于询问我们从大到小枚举$\text{fib}$串累加每个字符的答案。最后可能会剩余一定长度无法消去，但剩余的长度一定不超过$|S|$（在$\text{fib}$串中甚至没有组成一个元素$S$），且是$S$的一个前缀，额外计算上这些部分即可。 ​ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int N=200005;int n,up,nex[N],type;char str[N];int pre[N][26];ll l,r,cut,len[100],ans[26];ll f[100][26];void readData()&#123; scanf("%s%lld%lld",str+1,&amp;l,&amp;r); n=strlen(str+1); n&gt;&gt;=1; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;26;j++) pre[i][j]=pre[i-1][j]; pre[i][str[i]-'a']++; &#125;&#125;void getNex()&#123; nex[1]=0; for(int i=2,j;i&lt;=n;i++)&#123; j=nex[i-1]; while(j&amp;&amp;str[j+1]!=str[i]) j=nex[j]; nex[i]=(str[j+1]==str[i])?j+1:0; &#125;&#125;void preWork()&#123; len[1]=n; for(int i=1;i&lt;=n;i++)&#123; f[1][str[i]-'a']++; f[2][str[i]-'a']++; &#125; len[2]=n+cut; for(int i=0;i&lt;26;i++) f[2][i]+=pre[cut][i]; for(int i=3;;i++)&#123; for(int j=0;j&lt;26;j++) f[i][j]=f[i-2][j]+f[i-1][j]; len[i]=len[i-2]+len[i-1]; if(len[i]&gt;1e18)&#123; up=i; break; &#125; &#125;&#125;void calc1(ll m,ll a)&#123; if(m&lt;=0) return; ll t=m/cut; for(int i=0;i&lt;26;i++) ans[i]+=a*t*pre[cut][i]; t=m%cut; for(int i=0;i&lt;26;i++) ans[i]+=a*pre[t][i];&#125;void calc2(ll m,ll a)&#123; for(int i=up;i&gt;=1;i--) if(len[i]&lt;=m)&#123; m-=len[i]; for(int j=0;j&lt;26;j++) ans[j]+=a*f[i][j]; &#125; for(int j=0;j&lt;26;j++) ans[j]+=a*pre[m][j];&#125;int main()&#123; readData(); getNex(); cut=n-nex[n]; if(n%cut==0)&#123; calc1(r,1); calc1(l-1,-1); &#125; else&#123; preWork(); calc2(r,1); calc2(l-1,-1); &#125; for(int i=0;i&lt;26;i++) printf("%lld ",ans[i]); return 0;&#125;]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>字符串---Border</tag>
        <tag>思考题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AGC010F】Tree Game]]></title>
    <url>%2F2018%2F08%2F07%2Fagc010_f-Tree-Game%2F</url>
    <content type="text"><![CDATA[Description​ 有一棵$n$个节点的树（$n \le 3000$），第$i$条边连接$a_i,b_i$，每个节点$i$上有$A_i$个石子，高桥君和青木君将在树上玩游戏。 ​ 首先，高桥君会选一个节点并在上面放一个棋子，然后从高桥君开始，他们轮流执行以下操作： ​ （1）从当前棋子占据的点上移除一个石子； ​ （2）将棋子移动到相邻节点 ​ 如果轮到一个人执行操作时棋子占据的点上没有石子，那么他就输了 。 ​ 请你找出所有的点$v$，使得如果高桥君在游戏开始时把棋子放到$v$上，他可以赢。（按编号从小到大输出） Solution​ 考虑$\mathcal O(n^2)$算法。 ​ 首先两个人的行动是互相约束的。 ​ 假设当前在节点$u$，先手能耗死后手（即先手必胜）当且仅当对于其所有相邻点，至少存在一个点$v$，满足： ​ （1）$a_u&gt;a_v$ ​ （2）$v$先手必败。 ​ 首先（1）是这题对局的一种博弈过程，设想有且只有两个点$u$和$v$，若初始时棋子在$u$，且$a_u&gt;a_v$，那么反复走，后手必死。 ​ 因此只要先手走向了如是的$v$，后手必定不会在这条边上反复横跳，之后也不会，因为一旦后手走回来，先手继续走回$v$，可以把后手耗到死。 ​ 那么后手必定也只能在$v$中寻找机会。只要$v$是先手必败态，那么$u$即为先手必胜态，因为先手可以主动走到$v$引出必败态。 ​ ​ 定义$u$是先手必败态当且仅当不存在上述$v$。 ​ 首先，如果先手走向的点$v$满足$a_u\le a_v$，后手可以走回$u$，因为反复横跳后先手必死。因此这些点不可走。 ​ 走向的点$v$满足$a_u&gt;a_v$时，若$v$为先手必胜态，那么$u$肯定不能走这一步；如果不存在$v$是先手必败态，那么先手就无路可走了。 ​ 综上，因为必须走一步，所以$u$是先手必败态，当且仅当不存在$v$满足$a_u&gt;a_v$且$v$先手必败。 ​ 对于每一个点，以其为根深搜，设$f_u$表示$u$是必胜还是必败，自底向上DP一遍。 ​ 为什么可以自底向上单向考虑？我们是要DP判定每个点$u$是不是必胜态，即要找到是否存在相邻点$v$满足$au&gt;a_v$，并深搜计算它们的必胜必败态。而对于不满足条件的$v$，我们甚至不需要递归进去计算，因为先手不会选择走这边。所以，会选择$u$的父亲作为$v$吗？不会。每递归到$u$时，也就意味着，是上一步的先手想逼我（当前先手）反复横跳才走这一步过来，即满足$a{fa}&gt;a_u$，所以当前先手肯定不能走父亲回去和他反复横跳。因此可以说，DP过程中，是一路向下，走后继递归计算的。 ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;using namespace std;const int N=3005;int n,a[N],f[N];int h[N],tot;struct Edge&#123;int v,next;&#125;e[N*2];inline void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); int u,v; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125;&#125;void dfs(int u,int fa)&#123; f[u]=0; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;a[u]&gt;a[v])&#123; dfs(v,u); if(f[v]==0)&#123; f[u]=1; return; &#125; &#125;&#125;void solve()&#123; for(int u=1;u&lt;=n;u++)&#123; dfs(u,0); if(f[u]) printf("%d ",u); &#125;&#125;int main()&#123; readData(); solve(); return 0;&#125; ​]]></content>
      <categories>
        <category>2017国家集训队作业</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>DP---树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AliceAndBob]]></title>
    <url>%2F2018%2F08%2F06%2FAliceAndBob%2F</url>
    <content type="text"><![CDATA[Description​ XSY1759 Solution​ 肯定是离线对每个子树求答案。 ​ 考虑对每个子树建出所包含的值的Trie树，这点用启发式算法实现即可，即每个元素会被插入$\mathcal O(\log n)$次Trie树。 ​ 假设我们现在在求某棵子树的答案，并已得到这颗Trie树。我们相当于对子树中的每一个值$x$，求出$g(x)$表示$x$与子树中其他值异或起来的最小值。这棵子树的答案即$\max g(x)$。 ​ 定义一个权值$x$的分歧点$u$为：若$x$与权值$y$形成了$g(x)$，则$u$为Trie上$x$与$y$的第一个分歧点。 ​ 维护$f_i$表示对于分歧点为$i$的值$x$，$\max g(x)$是多少。考虑新插入一个值$x$，会对插入时走过的链上的$f$带来什么变化。 ​ 假设插入时遍历到了点$i$。若下一步的去向已经有了节点，这就说明：去向的子树中会有至少2个值，那么左边的所有值的分歧点一定不是$i$，因此对$f_i$无贡献，将$f_i$暂且设为-1；但若另一个方向恰好只包含1个权值$y$，那么我们在插入完成回溯到$i$时，用$y$这个值在去向子树中贪心走一遍，赋到$f_i$中。 ​ 若下一步的去向没有节点，那么如果另一个方向没有权值，则$f_i=-1$；若有，则用$x$在另一个方向贪心走一遍，赋到$f_i$上。 ​ 答案即所有$f_i$的$\max$，实现时计算完目前的$f_i$后，上推即可。 ​ 单次插入的复杂度为$\mathcal O(\log_2^2 n)$（插入链的长度为一个log，在每个位置都或许要贪心走一下） ​ 所以总时间复杂度是$\mathcal O(n \log_2^3 n)$ ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;cstdio&gt;#include &lt;vector&gt;#define pb push_backusing namespace std;const int N=100005,B=17;int n,w[N],m,ans[N];vector&lt;int&gt; q[N];int size[N],son[N],dfntm,dfn[N][2],who[N];int h[N],tot;struct Edge&#123;int v,next;&#125;e[N*2];inline void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;namespace T&#123; const int S=N*18; int rt,sz; int ch[S][2],cnt[S],val[S]; int f[S]; void clear()&#123; sz=rt=0; &#125; inline void pushup(int u)&#123; if(ch[u][0]) f[u]=max(f[u],f[ch[u][0]]); if(ch[u][1]) f[u]=max(f[u],f[ch[u][1]]); &#125; int match(int u,int x,int k)&#123; int res=0; for(;k&gt;=0;k--)&#123; int c=(x&gt;&gt;k)&amp;1; if(ch[u][c]) u=ch[u][c]; else u=ch[u][c^1],res+=(1&lt;&lt;k); &#125; return res; &#125; void insert(int &amp;u,int x,int k)&#123; if(!u)&#123; u=++sz; f[u]=-1; ch[u][0]=ch[u][1]=0; cnt[u]=0; &#125; cnt[u]++; val[u]=x; if(k==-1)&#123; f[u]=cnt[u]&gt;1?0:-1; return; &#125; int c=(x&gt;&gt;k)&amp;1; insert(ch[u][c],x,k-1); f[u]=-1; if(ch[u][0]&amp;&amp;ch[u][1])&#123; if(cnt[ch[u][0]]==1) f[u]=max(f[u],(1&lt;&lt;k)+match(ch[u][1],val[ch[u][0]],k-1)); if(cnt[ch[u][1]]==1) f[u]=max(f[u],(1&lt;&lt;k)+match(ch[u][0],val[ch[u][1]],k-1)); &#125; pushup(u); &#125; int get()&#123;return rt?f[rt]:-1;&#125;&#125;void readData()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",w+i); int u,v; for(int i=1;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125; scanf("%d",&amp;m); for(int i=1,x;i&lt;=m;i++)&#123; scanf("%d",&amp;x); q[x].pb(i); &#125;&#125;void devide(int u,int fa)&#123; dfn[u][0]=++dfntm; who[dfntm]=u; size[u]=1; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; devide(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125; dfn[u][1]=dfntm;&#125;void solve(int u,int fa)&#123; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;v!=son[u])&#123; solve(v,u); T::clear(); &#125; if(son[u]) solve(son[u],u); T::insert(T::rt,w[u],B); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;v!=son[u])&#123; for(int j=dfn[v][0];j&lt;=dfn[v][1];j++) T::insert(T::rt,w[who[j]],B); &#125; int best=T::get(); int sz=q[u].size(); for(int i=0;i&lt;sz;i++) ans[q[u][i]]=best;&#125;int main()&#123; readData(); devide(1,0); solve(1,0); for(int i=1;i&lt;=m;i++) printf("%d\n",ans[i]); return 0;&#125; ​ ​]]></content>
      <tags>
        <tag>字符串---Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【CF472G】]]></title>
    <url>%2F2018%2F07%2F31%2FCF472G%2F</url>
    <content type="text"><![CDATA[Description​ 给出两个01序列$A$和$B$ ​ 要求回答$q$个询问每次询问$A$和$B$中两个长度为$len$的子串的哈明距离 ​ 哈明距离的值即有多少个位置不相等 ​ $1 \le \mid A\mid ,\mid B\mid \le 2*10^5$ ​ $1 \le q \le 4*10^5$ ​ 保证输入合法，序列下标从0开始 Solution​ 大暴力分块，记录一下思想 ​ 题解做法比较繁琐 ​ 先求出每一个位置开始长度为32的序列状态，压进一个unsigned int ​ 每$T$位分一块，处理出$A$中第$i$块整块构成的字符串和$B$中从$j$开始长度为$T$的子串的哈明距离$f_{i,j}$ ​ 询问时两边暴力计算，中间用$f$计算 ​ 时间复杂度$O(\frac {nm}{32})$，常数非常不优秀 ​ 下面是常数小的做法 ​ 求出每一个位置开始长度为64的序列状态，压进一个unsigned long long ​ 询问？直接扫！单次询问复杂度$O(\frac {len}{64})$，实测常数非常优秀，大约1.5s出解 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef unsigned long long ull;const int N=200005;int len;char str[N];ull a[N],b[N];int cnt[65536];inline int sum(ull x)&#123;return cnt[x&amp;65535]+cnt[(x&gt;&gt;16)&amp;65535]+cnt[(x&gt;&gt;32)&amp;65535]+cnt[(x&gt;&gt;48)&amp;65535];&#125;int main()&#123; scanf("%s",str); len=strlen(str); for(int i=len-1;i&gt;=0;i--) a[i]=(a[i+1]&gt;&gt;1)|((ull)(str[i]=='1')&lt;&lt;63); scanf("%s",str); len=strlen(str); for(int i=len-1;i&gt;=0;i--) b[i]=(b[i+1]&gt;&gt;1)|((ull)(str[i]=='1')&lt;&lt;63); for(int i=0;i&lt;65536;i++) cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); int q,x,y,z,ans,up; scanf("%d",&amp;q); while(q--)&#123; scanf("%d%d%d",&amp;x,&amp;y,&amp;z); ans=0; for(;z&gt;=64;x+=64,y+=64,z-=64) ans+=sum(a[x]^b[y]); if(z) ans+=sum((a[x]^b[y])&amp;((ull)(-1)-(((ull)1&lt;&lt;(64-z))-1))); printf("%d\n",ans); &#125; return 0;&#125; ​ ​]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多项式全家桶 欢迎订购KFC多项式全家桶 约定的记号 对于一个多项式$A(x)$，若其最高次系数不为零的项是$x^k$，则该多项式的次数为$k$. 记为$\text{deg}(A)=k$ 对于$x\in(k,+ \infty)​$，称$x​$都为$A(x)​$的次数界. 但一般地，我们都使用$k+1​$作为$A(x)​$的次数界。 取模意义下的多项式运算 这里要消除一下疑惑：当我们把两个次数界为$n$的多项式在模$x^n$意义下相乘时，虽然NTT后我们得到的是一个次数界为$2n-1$的多项式，但是$x^n….x^{2n-1}$的系数没有意义，答案就是$x^0…x^{n-1}$描述的多项式 求分式同理，$\frac {F(x)}{G(x)}\pmod {x^n}$的答案，就是$F(x)*G^{-1}(x)$的前$n$个项 模$x^n$等价于截高位，即将指数不小于$n$的项的系数直接设为0 一个好的函数 由于运算过程涉及各种指针操作，为了避免出现越界修改的情况，我们通常要对数组进行复制，复制的时候还要考虑清零，十分头疼。因此，我们对这个操作进行一下封装： 123456789// target:目标数组指针// source:源数组指针 // len:从source开始复制的长度 // cut:复制完成后，target的后续部分需要清空到多少（-1表示不需要清空）void copy(int *target,int *source,int len,int cut=-1)&#123; memcpy(target,source,sizeof(int)*len); if(cut!=-1) memset(target+len,0,sizeof(int)*(cut-len));&#125; 加减乘 略，加减复杂度为$\mathcal O(n)$，乘法用NTT$\mathcal O(n \log n)$计算 两个多项式的单纯乘法封装为如下函数： 12345678910111213141516// a,b: 两个多项式的指针// c: 答案多项式的指针// n,m: a和b的次数界// out: 答案只取结果的前out位，默认全部取void polyMul(int *a,int *b,int *c,int n,int m,int out=INF)&#123; static int f[NTT::LEN],g[NTT::LEN]; int len=n+m-1; NTT::init(len); copy(f,a,n,NTT::n); copy(g,b,m,NTT::n); NTT::ntt(f,1); NTT::ntt(g,1); for(int i=0;i&lt;NTT::n;i++) f[i]=1ll*f[i]*g[i]%MOD; NTT::ntt(f,-1); copy(c,f,min(len,out));&#125; 求逆 已知一个多项式$A(x)$，求一个多项式$B(x)$，使得 \begin{equation} A(x)B(x)\equiv1 \pmod {x^n} \ \ \ \ \ \ \ \ \ \ \ (1) \end{equation}\\ 采用倍增思路向上倍增模数并求解 当$n=1$时，$A(x)$与$B(x)$各自只剩下一个常数项，因此$B(x)$的常数项恰好等于$A(x)$常数项的逆元。多项式有无逆元也取决于这个常数是否有逆元 当$n &gt; 1$时，假设我们已经求得$A(x)$在模$x^{\lceil\frac n 2\rceil}$意义下的逆元$B’(x)$ \begin{equation} A(x)B'(x)=1 \pmod{x^{\lceil\frac n 2\rceil}}\ \ \ \ \ \ \ \ \ \ \ (2) \end{equation} 而$(1)$放在模$x^{\lceil\frac n 2\rceil}$意义下同样成立，即 \begin{equation} A(x)B(x)\equiv1 \pmod {x^{\lceil\frac n 2\rceil}}\ \ \ \ \ \ \ \ \ \ \ \ (3) \end{equation} 将$(3)-(2)$，除去$A(x)$后可得 \begin{equation} B(x)-B'(x)\equiv 0 \pmod {x^{\lceil\frac n 2\rceil}} \ \ \ \ \ \ \ \ \ \ \ (4) \end{equation} 平方得到 \begin{equation} B^2(x)-2B(x)B'(x)+B'^2(x)\equiv 0 \pmod {x^n} \end{equation} 模数同时平方的原因是：$(4)$左边模$x^{\lceil\frac n 2\rceil}$为$0$，说明$x^0,x^1,\dots,x^{\lceil \frac n2 \rceil-1}$项的系数为$0$；平方后这些$0$系数会导致$x^0,x^1,\dots, x^{2\lceil \frac n2 \rceil}$项系数为$0$。注意到$2\lceil \frac n2 \rceil \ge n$，因此平方后的结果模$x^n$也为$0$。这也是倍增时使用上取整的原因——如果我们使用下取整，模数将不可顺利转化 两边同乘$A(x)$，消去$B(x)$并移项，得到 B(x) \equiv 2B'(x) - A(x)B'^2(x) \pmod {x^n} 至此我们可以得到一个倍增算法，代码如下： 1234567891011121314151617void polyInv(int *a,int *b,int n)&#123; // a是要求逆元的多项式，b是在模x^n意义下的a的逆元 if(n==1)&#123; b[0]=INV(a[0]); return; &#125; int m=(n+1)&gt;&gt;1; polyInv(a,b,m); static int f[NTT::LEN],g[NTT::LEN]; NTT::init(2*m+n); // 注意长度 copy(f,a,n,NTT::n); copy(g,b,m,NTT::n); NTT::ntt(f,1); NTT::ntt(g,1); for(int i=0;i&lt;NTT::n;i++) f[i]=(2ll*g[i]-1ll*g[i]*g[i]%MOD*f[i]%MOD)%MOD; NTT::ntt(f,-1); copy(b,f,n);&#125; 时间复杂度$O(n \log n)$，不过我不知道怎么证。 除法及取模 给定多项式$A(x)$和多项式$B(x)$，求两个多项式$D(x)$与$R(x)$，使得 \begin{equation} A(x)=D(x)B(x)+R(x) \ \ \ \ \ (1) \end{equation} $A(x)$是被除数，$B(x)$是除数，$D(x)$是商，$R(x)$是余数 其中，$\text{deg}(A)&gt;=\text{deg}(B)$ , $\text{deg}(D)\leq \text{deg}(A)-\text{deg}(B)$，$\text{deg}(R)&lt;\text{deg}(B)$ 除法是用一些巧妙的变化来解决的 引入一个翻转多项式的概念：对于一个次数为$n$的多项式$A(x)$，定义 A^R(x)=x^nA(\frac 1 x) 你会发现$A^R(x)$的系数与$A(x)$的系数是镜像关系 将$(1)$的$x$换成$\frac 1 x$，并在两边同乘$x^n$；记$n=\text{deg}(A),\ m=\text{deg}(B),\ \text{deg}(D)=n-m, \ \text{deg}(R)=m-1$（注意此处$\text{deg}(D)$和$\text{deg}(R)$都默认取了最大次数），则有： \begin{aligned} x^nA(\frac1x)&=x^{n-m}D(\frac1x)x^mB(\frac1x)+x^{n-m+1}x^{m-1}R(\frac1x)\\ A^R(x)&=D^R(x)B^R(x)+x^{n-m+1}R^R(x) \end{aligned} 如果把上式放在模$x^{n-m+1}$意义下，我们会发现$x^{n-m+1}R^R(x)$被完全模掉了！ 于是 \begin{aligned} A^R(x)&\equiv D^R(x)B^R(x)\pmod{x^{n-m+1}}\\ D^R(x)&\equiv A^R(x)({B^R})^{-1}(x)\pmod{x^{n-m+1}} \end{aligned} 我们只需要求出$B^R$的逆元即可 123456789void polyDiv(int *a,int *b,int *d)&#123;// a和b对应上文的A和B，d是上文的D，是答案 if(deg(a)&lt;deg(b)) "令d为一个0多项式，返回"; reverse(a); reverse(b); static int invb[]; polyInv(b,invb,deg(b)+1); //b次数界是\text&#123;deg&#125;(b)+1 d=a*invb; reverse(d);&#125; 如果你还要求$R(x)$，带回最初的式子直接算就好，多项式乘法用*直接代替了 123456void polyMod(int *a,int *b,int *r)&#123; if(deg(a)&lt;deg(b)) "令r为a，返回"; static int d[]; polyDiv(a,b,d); r=a-d*b;&#125; 求$\ln$ 已知一个多项式$f(x)$，并知关系$f(x)=e^{g(x)}$，求多项式$g(x)=\ln f(x)$ 两边求导，得到 g'(x)=\frac {f'(x)}{f(x)} 所以 g(x)=\int\frac{f'(x)}{f(x)} 先对$f$求导（$\mathcal O(n)$），再与$f$的逆多项式相乘（都是$\mathcal O(n \log n)$），对结果再积分（$\mathcal O(n)$），得到$g(x)$ 123456789101112131415void polyDeri(int *a,int *b,int n)&#123;//计算一个次数界为n的多项式a的导数，放入b for(int i=0;i&lt;n-1;i++) b[i]=1LL*(i+1)*a[i+1]%MOD; b[n-1]=0;&#125;void polyInte(int *a,int *b,int n)&#123;//计算一个次数界为n的多项式a的积分，放入b for(int i=n-1;i&gt;0;i--) b[i]=1LL*a[i-1]*inv[i]%MOD; b[0]=0;&#125;void polyLn(int *f,int *g,int n)&#123;//整体计算于模x^n意义下进行 static int t1[NTT::LEN],t2[NTT::LEN]; polyDeri(f,t1,n);//求导，放入t1 polyInv(f,t2,n);//求逆，放入t2 polyMul(t1,t2,t1,n,n); polyInte(t1,g,n);//积分，放入g&#125; 多项式牛顿迭代法 已知一个多项式$g(x)$，求$f(x)$使得$g(f(x))\equiv0\pmod{x^n}$ 做法：倍增模数$x^n$。 当$n=1$时，根据$g(x)$的常数项解一下$f(x)$的常数项即可 假设已知$f_0(x)$使得 g(f_0(x))\equiv0\pmod{x^{\lceil \frac n2\rceil}} 根据泰勒展开@%#……&amp;￥，可以构造$f(x)$ f(x)\equiv f_0(x)-\frac{g(f_0(x))}{g'(f_0(x))}\pmod{x^n} 使得$f(x)$可满足$g(f(x))\equiv0\pmod{x^n}$ 求exp 已知一个多项式$f(x)$，并知关系$g(x)\equiv e^{f(x)}\pmod{x^n}$，求$g(x)$ 前置技能：多项式牛顿迭代法。 先化一波式子： \begin{aligned} g(x)-e^{f(x)}&\equiv 0\pmod{x^n}\\ \ln g(x)-f(x)&\equiv 0 \pmod{x^n} \end{aligned} 其实就是要解多项式方程 H(g(x))=\ln g(x)-f(x)\pmod{x^n} 的根。其中$g(x)$是自变量，$f(x)$是常多项式。 套用多项式牛顿迭代，假设已知多项式$g_0(x)$满足 \ln g_0(x)-f(x)\equiv 0\pmod{x^{\lceil \frac n2\rceil}} 则可以构造$g(x)$ \begin{aligned} g(x)&\equiv g_0(x)-\frac{\ln g_0(x)-f(x)}{\frac 1 {g_0(x)}}\\ &\equiv g_0(x)*(1-\ln g_0(x)+f(x))\pmod{x^n} \end{aligned} 使得$g(x)$满足$\ln g(x)-f(x)\equiv 0\pmod{x^{n}}$。 向上倍增即可。 `c++ void polyEXP(int *f,int *g,int n){ if(n==1){ g[0]=1; return; } static int t[S]; polyEXP(f,g,(n+1)&gt;&gt;1);//求得g0，放在g中 polyLn(g,t,n);//求g0的ln，放在t中 for(int i=0;i&lt;n;i++) t[i]=(f[i]-t[i])%MOD;//构造后面一个括号的多项式，还是放在t中 t[0]++; polyMul(t,g,g,n,n,n); } `&lt;!-- more --&gt;]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬币游戏]]></title>
    <url>%2F2018%2F07%2F26%2F%E7%A1%AC%E5%B8%81%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[Description​ Solution​ 设当前走出了一个不匹配任何字符串的串$S$。 ​ 若在$S$后随机增添$m$个字符，单看这些字符而言，这$m$个字符匹配到每个玩家的字符串的概率是相同的，记为$P$。 ​ 问题在于，对于每个字符串来说，并不是所有情况下一定要通过新增添$m$个字符才能匹配到自己，有可能加到中途时，就已经与$S$的某个后缀组成了自己，又或者是与$S$的某个后缀组成了别的字符串，早该停止了。 ​ 但是，对于每个串，不管每种情况中途该不该停下，我们计算出每种情况继续增加满$m$个字符并匹配到自己的概率，它们的概率之和还是$P$。 ​ 记每个人$i$成功被匹配到的概率是$f_i$（答案的定义）。 ​ 现在枚举对于一个人$i$，在新加$m$个字符尝试匹配自己时，所有中途应该停下的情况。 ​ 枚举另一个人$j$，如果$j$的$len$后缀与$i$的$len$前缀相同，则配合$S$的随机性，可能出现了这种情况： ​ 这时候早就该停了，但为了凑齐$P$，要计算在这种情况下继续匹配完全时所需的概率。继续匹配完$i$的子串，则还需要$(\frac 1 2)^{m-len}$的概率。因此，这种情况对总和的贡献有$(\frac 1 2)^{m-len}f_j$。当然，$i$和$j$之间不止有一个$len$满足条件，应找出所有符合描述的$len$，累加$f_j$的贡献系数，记最终$f_j$贡献系数为$a_j=\sum(\frac 1 2)^{m-len}$。 ​ 其实$j$可以等于$i$，这代表着提前匹配到自己的情况。 ​ 我们可以列出等式： P=\sum_{i=1}^na_if_i​ 总的来说，每一个人获胜的概率之和应该是1，因此有等式 \sum_{i=1}^nf_i=0​ 算上$P$，我们拿到了一个$n+1$个未知数的$n+1$条方程，高斯消元解决即可，尽管我们并不需要知道$P$的具体取值。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int N=305;int n,m;char str[N][N];double a[N][N],x[N];int nex[N*2];double mi2[N];double kmp(int x,int y)&#123; static char b[N*2]; for(int i=1;i&lt;=m;i++) b[i]=str[x][i],b[m+i]=str[y][i]; nex[1]=0; for(int i=2,j;i&lt;=m*2;i++)&#123; j=nex[i-1]; while(j&amp;&amp;b[j+1]!=b[i]) j=nex[j]; if(b[j+1]==b[i]) nex[i]=j+1; else nex[i]=0; &#125; double res=0; for(int i=m*2;i;i=nex[i]) if(i&lt;=m) res+=mi2[m-i]; return res;&#125;void fill_matrix()&#123; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++) a[i][j]=kmp(i,j); a[i][n+1]=-1; &#125; for(int i=1;i&lt;=n;i++) a[n+1][i]=1; a[n+1][n+2]=1;&#125;void gaussian(int n)&#123; int best; for(int i=1;i&lt;=n;i++)&#123; best=i; for(int j=i+1;j&lt;=n;j++) if(fabs(a[j][i])&gt;fabs(a[best][i])) best=j; if(best!=i) for(int j=i;j&lt;=n+1;j++) swap(a[i][j],a[best][j]); for(int j=i+1;j&lt;=n;j++)&#123; double t=a[j][i]/a[i][i]; for(int k=i;k&lt;=n+1;k++) a[j][k]-=a[i][k]*t; &#125; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=i+1;j&lt;=n;j++) a[i][n+1]-=a[i][j]*x[j]; x[i]=a[i][n+1]/a[i][i]; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); mi2[0]=1; for(int i=1;i&lt;=m;i++) mi2[i]=mi2[i-1]*0.50000000000; for(int i=1;i&lt;=n;i++) scanf("%s",str[i]+1); fill_matrix(); gaussian(n+1); for(int i=1;i&lt;=n;i++) printf("%.10lf\n",x[i]); return 0;&#125; ​ ​]]></content>
      <tags>
        <tag>高斯消元</tag>
        <tag>字符串---KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字表格]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[Description​ 吃掉了 ​ 在xsy上找找吧 Solution​ 一开始的时候我是这么推的（$f(n)$表示斐波那契数列的第$n$项） \begin{aligned} Ans&=\prod_{x=1}^{\min(n,m)}f(x)^{(\sum_{i=1}^n\sum_{j=1}^m[\gcd(i,j)=x])}\\ &=\prod_{x=1}^{\min(n,m)}f(x)^{\sum_{e=1}^{\min(\lfloor\frac nx\rfloor,\lfloor \frac mx\rfloor)}\mu(e)\lfloor\frac n {ex}\rfloor\lfloor\frac m {ex}\rfloor}\\ \end{aligned}​ 然后我想，根号分段套根号分段，$\mathcal O(\sqrt n(\log+\sqrt n))$解决！嗯不错，一看数据组数1000……..不过还是能拿70的分。 ​ 题解的思路非常神。 ​ 假设我们能构造一个函数$g$，使得 f(n)=\prod_{d|n}g(d)​ 那么答案就变成 \begin{aligned} Ans&=\prod_{i=1}^n\prod_{j=1}^mf({\gcd(i,j))}\\ &=\prod_{i=1}^n\prod_{j=1}^m\prod_{d|i,d|j}g(d)\\ &=\prod_{d=1}^{\min(n,m)}g(d)^{\lfloor\frac nd\rfloor\lfloor\frac md\rfloor} \end{aligned}​ 这样就可以在$\mathcal O(2\sqrt n)$的时间内处理每一个询问了。前提是我们知道$g$及其前缀积。 ​ 考虑式子$f(n)=\prod_{d|n}g(d)$十分像莫比乌斯反演，能否用类似的形式反演出$g$呢？ ​ 在$\sum$的意义下 g_n=\sum_{d|n}\mu(d)f({\frac nd})​ 反演的本质是通过加减来容斥出所需要的组合。而在乘法的意义下，不就是通过乘除来容斥出所需要的组合吗？所以有： g_n=\prod_{d|n}f({\frac nd})^{\mu(d)}=\prod_{d|n}f(d)^{\mu(\frac nd)}​ 因此我们可以在$\mathcal O(n \lg n)$的时间内处理出$g$的取值和前缀积。那么上面的根号分段也就迎刃而解了。 ​ 总体思路是仿造莫比乌斯反演构造一个可求函数，利用该函数化简式子使得答案求和式变得简明且复杂度较低，再通过传统根号分段求解。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;using namespace std;const int N=1e6+10,MOD=1e9+7,PMOD=MOD-1;int n,m;int fib[N],ifib[N],g[N],ig[N];bool vis[N];int p[N],pcnt,mu[N];inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;inline int fmi(int x,int y)&#123; int res=1; for(;y;x=1LL*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%MOD; return res;&#125;void sieve()&#123; mu[1]=1; for(int i=2;i&lt;=1e6;i++)&#123; if(!vis[i]) p[++pcnt]=i,mu[i]=-1; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;=1e6;j++)&#123; int x=i*p[j]; vis[x]=true; if(i%p[j]==0)&#123; mu[x]=0; break; &#125; mu[x]=-mu[i]; &#125; &#125;&#125;void prework()&#123; sieve(); fib[0]=0; fib[1]=1; ifib[1]=1; for(int i=2;i&lt;=1e6;i++)&#123; fib[i]=(fib[i-2]+fib[i-1])%MOD; ifib[i]=fmi(fib[i],MOD-2); &#125; for(int i=1;i&lt;=1e6;i++) g[i]=1; for(int d=1;d&lt;=1e6;d++) for(int n=d;n&lt;=1e6;n+=d) g[n]=1LL*g[n]*(mu[n/d]==1?fib[d]:(mu[n/d]==-1?ifib[d]:1))%MOD; g[0]=ig[0]=1; for(int i=1;i&lt;=1e6;i++)&#123; g[i]=1LL*g[i]*g[i-1]%MOD; ig[i]=fmi(g[i],MOD-2); &#125;&#125;int main()&#123; prework(); int T,up,ans; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); up=min(n,m); ans=1; for(int i=1,j;i&lt;=up;i=j+1)&#123; j=min(n/(n/i),m/(m/i)); ans=1LL*ans*fmi(1LL*g[j]*ig[i-1]%MOD,1LL*(n/i)*(m/i)%PMOD)%MOD; &#125; printf("%d\n",ans&lt;0?ans+MOD:ans); &#125; return 0;&#125; ​]]></content>
      <tags>
        <tag>数论---莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCM]]></title>
    <url>%2F2018%2F07%2F24%2FLCM%2F</url>
    <content type="text"><![CDATA[Description 给你$n,k$，要你选一些互不相同的正整数，满足这些数的lcm为$n$，且这些数的和为$k$的倍数。 求选择的方案数。对$232792561$取模。 $n\le10^{18},k\le20，n的全部质因子都\le100​$ Solution​ $n\le10^{18}$时其质因数个数最多只有15个。记$n$的质因子个数为$m$。 ​ 设$g_{i,j}$表示有多少个$n$的因数$d$，满足$d$中$i$状态的质因子的指数与$n$相同，且$d\%k=j$。 ​ 再设$f{i,j}$，表示从$g{i}$所涉及的数组成的数集$A_i$中有多少个子集，使得子集中的数之和模$k$为$j$。 ​ 这点可以用生成函数解决： G_i(x)=\prod_{a\in A_i}(1+x^a)​ 则$f_{i,j}=G_i(x)[j]$。 ​ 考虑许多个$f_{i,j}$怎样组合才对答案有贡献。当下列条件同时满足时： ​ （1）$i_1\mid i_2\mid …\mid i_s=2^m-1$ ​ （2）$i_1\neq i_2\neq…\neq i_s$ ​ （3）$j_1+j_2+…+j_s\equiv0\pmod k$ ​ 则会对$Ans$有$\prod f_{i,j}$的贡献。 ​ 其实我们要求一个数组$h{i,j}$表示任选所有数字，使得$i$状态表示的每个质因子$p$，至少存在一个数满足其$p$的指数与$n$中相同，且所有数加起来模$k$等于$j$的方案数。显然答案是$h{2^m-1,0}$。 ​ 对每一行$fi$单独做一次DFT，此时得到每行$f_i$的点值表达。我们要做的，是选择那些编号或起来恰好等于$2^m-1$的行，将它们的点值表达对位相乘，累加到一个新数组$tmp$，这相当于枚举哪些行参与贡献、枚举这些行的哪一个$f{i,j}$参与贡献。对此$tmp$做逆DFT，就可以得到$h_{i}$了！ ​ 所以这部分如何操作？我们发现每一列的操作模式是相同的且互不影响。那么现在我们只看第一列即$f_{i,0}$，将这一列数拉出来方便看，设为$a_i$，其中$a_i=DFT(f_i)[0]$。 ​ 另起一个命名空间：$f_i$表示从$a$中选择若干个数使得编号或起来等于$i$时所有选择数的乘积，的所有情况之和。 ​ 构造莫比乌斯变换$FS=\sum{T\in S}{fT}=\prod{i\in S}(1+a_i)$。最后一个式子只要将括号展开，会得到许多乘积之和，每一个乘积都属于某一个$f$，因此是成立的。 ​ 根据莫比乌斯反演，有$fS=\sum{T\in S}(-1)^{\mid S\mid -\mid T\mid}FT$，因此若我们知道$F$，就可以暴力地求$f{2^m-1}$。那么$f_{2^m-1}$其实就是$tmp$的第0项，因为它是一种或的组合形式，满足粗体字，解决了一列的操作，那么其他列同理。 ​ $F$怎么求呢？这里要用到快速莫比乌斯变换FMT，即求解$FS=\prod{T\in S}g(T)$，其中$g$是一个已知函数。 ​ 初始时$FS=g(S)$。考虑补全$F_S$的内容，即考虑自己$F_i$如何去补全别人的$F_j$。有一种方式可以无重复地做到这点。$F_i$能更新$F_j$当且仅当$j$是由$i$的某一位0改成1得到。从低到高枚举改第$x$位，之后从小到大循环$i$，如果$i$的第$x$位是0，那么更新$F{i+2^x}+=F_i$。为什么要这样做？因为这样每个$F_i$所包含的元素都会只统计一次。假设$F_i$中$g(j)$被统计了多次，那就说明$g(j)$贡献去$F_i$的路径出现分叉和合并，即有人先改了高位、有人又先改了低位，两个过程又是同时进行的，这与我们算法设计的“逐位修改”有矛盾。因此可以这么做。 ​ 总时间复杂度$\mathcal O(k^22^m+km2^m)$。 ​ 交题不小心把yww的std交上去了，常数太优秀，我的代码覆盖不掉他。qwq Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int PN=26,MOD=232792561,G=71;ll n;int m;int d[PN],id[PN],idcnt,w[410][2];int p[PN]=&#123;0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97&#125;;int f[1&lt;&lt;15][20];inline int bit(int i)&#123;return 1&lt;&lt;(i-1);&#125;int fmi(int x,int y,int mod=MOD)&#123; int res=1; for(;y;x=1LL*x*x%mod,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%mod; return res;&#125;void init_rt()&#123; int rt=fmi(G,(MOD-1)/m); w[0][0]=1; for(int i=1;i&lt;=400;i++) w[i][0]=1LL*w[i-1][0]*rt%MOD; for(int i=0;i&lt;=400;i++) w[i][1]=fmi(w[i][0],MOD-2);&#125;void dft(int n,int *a,int t)&#123; static int b[30]; for(int i=0;i&lt;n;i++) b[i]=0; for(int i=0;i&lt;n;i++) for(int j=0;j&lt;n;j++) (b[i]+=1LL*a[j]*w[i*j][t]%MOD)%=MOD; if(t)&#123; int invn=fmi(n,MOD-2); for(int i=0;i&lt;n;i++) b[i]=1LL*b[i]*invn%MOD; &#125; for(int i=0;i&lt;n;i++) a[i]=b[i];&#125;void depart()&#123; ll x=n; for(int i=1;i&lt;PN;i++)&#123; d[i]=0; while(x%p[i]==0) x/=p[i],d[i]++; if(d[i]) id[i]=++idcnt; &#125;&#125;void add(int x,int y)&#123; static int t[30]; for(int i=0;i&lt;m;i++) t[i]=f[x][i]; for(int i=0;i&lt;m;i++) (f[x][(i+y)%m]+=t[i])%=MOD;&#125;void dfsdiv(int x,int state,int mulmodk)&#123; if(x==PN)&#123; add(state,mulmodk); return; &#125; for(int i=0;i&lt;=d[x];i++)&#123; if(i&amp;&amp;(i==d[x])) dfsdiv(x+1,state|bit(id[x]),1LL*mulmodk*fmi(p[x],i,m)%m); else dfsdiv(x+1,state,1LL*mulmodk*fmi(p[x],i,m)%m); &#125;&#125;void reset()&#123; memset(f,0,sizeof f);&#125;void Main()&#123; scanf("%lld%d",&amp;n,&amp;m); init_rt(); idcnt=0; depart(); int all=1&lt;&lt;idcnt; for(int i=0;i&lt;all;i++)&#123; f[i][0]=1; for(int j=1;j&lt;m;j++) f[i][j]=0; &#125; dfsdiv(1,0,1); for(int i=0;i&lt;all;i++) dft(m,f[i],0); for(int i=1;i&lt;all;i&lt;&lt;=1) for(int j=0;j&lt;all;j++) if(!(i&amp;j)) for(int k=0;k&lt;m;k++) f[j+i][k]=1LL*f[j+i][k]*f[j][k]%MOD; for(int i=0;i&lt;all-1;i++)&#123; int a=1; for(int j=0;j&lt;idcnt;j++) if(!((i&gt;&gt;j)&amp;1)) a=-a; for(int j=0;j&lt;m;j++) (f[all-1][j]+=a*f[i][j])%=MOD; &#125; dft(m,f[all-1],1); int ans=f[all-1][0]; printf("%d\n",ans&lt;0?ans+MOD:ans);&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) Main(); return 0;&#125;]]></content>
      <tags>
        <tag>FMT</tag>
        <tag>FWT</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intervals]]></title>
    <url>%2F2018%2F07%2F23%2FIntervals%2F</url>
    <content type="text"><![CDATA[Description​ 在一个长度为m的序列中选出n个区间，这些区间互不包含，且至少有一个区间的左端点为x。 ​ 问有多少种方案，注意交换两个区间的顺序视为不同方案。 ​ 答案很大，输出模1000000007后的值。 Input​ 一行三个整数n,m,x Output​ 一行一个整数，表示答案 Sample Input​ 2 3 3 Sample Output​ 6 HINT​ 对于30%的数据，n*m&lt;=20 ​ 对于100%的数据，n*m&lt;=100000 ​ （实际上，$n,m\le 400$） Solution​ 尝试使用DP解决。 ​ 每一个区间的构成分两次事件：从某位置开始，并于某一位置关闭。 ​ 我们想象一下从左往右扫描的过程，当前扫描位置的左端有许多等待关闭的区间，因为区间不可重叠，我们可以得到两个性质：首先显然区间的开始位置不可共用；其次如果我们要关闭一个区间，必然关闭的是开始位置最靠前的区间，因此任意时刻关闭区间的选择是唯一的。 ​ 设$f_{i,j,k}​$表示当前进行到第$i​$位，已经引出了$j​$个区间（不管是否关闭），并且有$k​$个区间等待关闭。 ​ 由$f_{i,j,k}$出发，有4种转移：（i+1处是否开启一个区间）*（i+1处是否关闭最靠前的区间），转移即可。 ​ 如果i+1即下一个位置是$x$，则只能进行（i+1处必须开启一个区间）*（i+1处是否关闭最靠前的区间）=2种转移。 Code123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MOD=1e9+7;int n,m,x;int f[2][405][405];inline int mul(int x,int y)&#123;return 1LL*x*y%MOD;&#125;inline void upd(int &amp;x,int y)&#123;(x+=y)%=MOD;&#125;inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;int main()&#123; scanf("%d%d%d",&amp;m,&amp;n,&amp;x); int u=0,v=1; f[u][0][0]=1; for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;=m;j++) for(int k=0;k&lt;=m;k++) if(f[u][j][k])&#123; if(j&lt;m) upd(f[v][j+1][k],f[u][j][k]); if(j&lt;m&amp;&amp;k&lt;m) upd(f[v][j+1][k+1],f[u][j][k]); if(i+1!=x&amp;&amp;k) upd(f[v][j][k-1],f[u][j][k]); if(i+1!=x) upd(f[v][j][k],f[u][j][k]); &#125; swap(u,v); memset(f[v],0,sizeof f[v]); &#125; int mt=1; for(int i=1;i&lt;=m;i++) mt=mul(mt,i); printf("%d\n",mul(f[u][m][0],mt)); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的难题]]></title>
    <url>%2F2018%2F07%2F14%2F%E6%A0%91%E7%9A%84%E9%9A%BE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Description Solution​ 看到这种路径统计问题，一般就想到要用点分治去做。 ​ 对于每个重心$u$，统计经过$u$的合法的路径之中的最大值。 ​ 第一类路径是从$u$出发的，直接逐个子树深搜统计就可以了。第二类路径是由两棵不同子树中的两条第一类路径拼接而成的。 ​ 如果仅仅是统计长度在$[l,r]$之间的路径有多少条，经典的统计+容斥做法就可以解决。然而现在的问题比较复杂，一来不好容斥，二来两两路径配对需要有判定条件：两条路径的接口边颜色是否相同。 ​ 我们可以采用一种不需要容斥的做法：逐一枚举子树，并逐一考虑由子树内的每个点出发去其他子树的路径。枚举到当前这棵子树内的某个节点$x$时，我们用$sum[d]$记录在之前的子树中，相对于$u$深度为$d$的点的某些信息。那么对于一个点$x$，它可以接上的路径的信息应该有$sum[i],\;i\in[l-dep_x,r-dep_x]$。 ​ 所以$sum[d]$记录的是什么呢？按照题目意思，我们应该记录所有从深度为$d$的点出发到$u$路径中的路径最大值。可是注意这个最大值不一定相对所有询问点来说都是最大值，有可能此最大值对应的路径$\alpha$与当前询问点路径接口边相同，权值重复，需要减去一次，说不定就不是最大的了。所以，我们额外要记录一个接口颜色异于最大值路径$\alpha$的另一条权值最大路径$\beta$。 ​ 这样一来，对于当前枚举点对应的路径$\gamma$，想要和先前子树中一条长度为$d$的路径结合时，有$sum[d]=(\alpha,\beta)。先看$$\alpha$的接口边颜色是否和$\gamma$相同，如果是，取$\max{\alpha-c,\beta}$作为最大路径和$\gamma$拼接（$c$表示$\alpha$和$\gamma$的接口边颜色）；否则，取$\alpha$拼接。 ​ 有意思的是，因为我们是一个一个子树进行处理，所以当前枚举的所有点的接口边颜色都是一样的，也就意味着不同点尝试配对同一个$sum$时的选择都是完全一样的。因此每一个$sum$的贡献是定值。我们相当于有一个数列，每次求$[l-dep_x,r-dep_x]$中的最大值。如果我们把点按照深度来排序，那么这个范围就是一个滑动窗口，可以使用单调队列进行$\mathcal O(n)$解决。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int N=200005,INF=2e9+5;int n,m,l,r,cv[N],all;int best,bestval,size[N];int udep[N],cc[N];int lis[N],lcnt,info[N][3];deque&lt;int&gt; q;int qv[N];bool cut[N],vis[N];int ans;struct Data&#123; int v1,c1,v2,c2; Data()&#123;v1=v2=-INF; c1=c2=-1;&#125; inline void insert(int v,int c)&#123; if(c!=c1)&#123; if(v&gt;v1) v2=v1,c2=c1,v1=v,c1=c; else if(v&gt;v2) v2=v,c2=c; &#125; else if(v&gt;v1) v1=v; &#125; int get(int c)&#123; return c==c1?max(v1-cv[c],v2):v1; &#125;&#125;s[N];int h[N],tot;struct Edge&#123;int v,c,next;&#125;e[N*2];inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;inline void addEdge(int u,int v,int c)&#123; e[++tot]=(Edge)&#123;v,c,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,c,h[v]&#125;; h[v]=tot;&#125;void getRt(int u,int fa,int sz)&#123; int maxsub=-1; size[u]=1; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;!cut[v])&#123; getRt(v,u,sz); size[u]+=size[v]; maxsub=max(maxsub,size[v]); &#125; maxsub=max(maxsub,sz-size[u]); if(maxsub&lt;bestval) bestval=maxsub,best=u;&#125;bool cmp(const int &amp;x,const int &amp;y)&#123;return udep[x]&lt;udep[y];&#125;void dfs(int u,int fa,int dep,int &amp;nowx)&#123; nowx=max(nowx,dep); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;!cut[v]) dfs(v,u,dep+1,nowx);&#125;void insert(int u,int fa,int dep,int topc,int fac,int val)&#123; vis[u]=false; if(l&lt;=dep&amp;&amp;dep&lt;=r) ans=max(ans,val); s[dep].insert(val,topc); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa&amp;&amp;!cut[v]) insert(v,u,dep+1,topc,e[i].c,fac==e[i].c?val:val+cv[e[i].c]);&#125;void collect(int x,int topc)&#123; int head=1,tail=1; lis[1]=x; info[x][0]=1; info[x][1]=cv[topc]; info[x][2]=topc; vis[x]=true; while(head&lt;=tail)&#123; int u=lis[head++]; for(int i=h[u],v;i;i=e[i].next) if(!cut[v=e[i].v]&amp;&amp;!vis[v])&#123; lis[++tail]=v; vis[v]=true; info[v][0]=info[u][0]+1; info[v][1]=info[u][1]+(e[i].c==info[u][2]?0:cv[e[i].c]); info[v][2]=e[i].c; &#125; &#125; lcnt=tail;&#125;void solve(int x,int sz)&#123; best=-1; bestval=INF; getRt(x,0,sz); int u=best; cut[u]=true; static int son[N],cnt; cnt=0; int curr=-1; for(int i=h[u],v;i;i=e[i].next) if(!cut[v=e[i].v])&#123; son[++cnt]=v; cc[v]=e[i].c; dfs(v,0,1,udep[v]); curr=max(curr,udep[son[cnt]]); &#125; curr=min(r,curr); for(int i=1;i&lt;=curr;i++) s[i]=Data(); vis[u]=true; for(int i=1,v;i&lt;=cnt;i++)&#123; v=son[i]; collect(v,cc[v]); while(!q.empty()) q.pop_back(); int nowl,nowr,qr=0; bool first=true; for(int j=lcnt;j&gt;=1;j--) if(info[lis[j]][0]&lt;r)&#123; int x=lis[j]; nowl=max(1,l-info[x][0]); nowr=r-info[x][0]; if(first)&#123; first=false; qr=nowl-1; while(qr&lt;nowr&amp;&amp;qr&lt;curr&amp;&amp;s[qr+1].v1&gt;-INF)&#123; int newval=s[++qr].get(cc[v]); if(newval&gt;-INF)&#123; while(!q.empty()&amp;&amp;qv[q.back()]&lt;=newval) q.pop_back(); q.push_back(qr); qv[qr]=newval; &#125; &#125; &#125; while(!q.empty()&amp;&amp;q.front()&lt;nowl) q.pop_front(); while(qr&lt;nowr&amp;&amp;qr&lt;curr&amp;&amp;s[qr+1].v1&gt;-INF)&#123; int newval=s[++qr].get(cc[v]); if(newval&gt;-INF)&#123; while(!q.empty()&amp;&amp;qv[q.back()]&lt;=newval) q.pop_back(); q.push_back(qr); qv[qr]=newval; &#125; &#125; if(!q.empty()) ans=max(ans,info[x][1]+qv[q.front()]); &#125; insert(v,0,1,cc[v],cc[v],cv[cc[v]]); &#125; for(int i=h[u],v;i;i=e[i].next) if(!cut[v=e[i].v]) solve(v,size[v]&gt;size[u]?(sz-size[u]):size[v]);&#125;int main()&#123; scanf("%d%d%d%d",&amp;n,&amp;m,&amp;l,&amp;r); for(int i=1;i&lt;=m;i++) scanf("%d",cv+i); for(int i=1,u,v,c;i&lt;n;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); addEdge(u,v,c); &#125; ans=-INF; solve(1,n); printf("%d\n",ans); return 0;&#125; ​]]></content>
      <tags>
        <tag>点分治</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络流24题]]></title>
    <url>%2F2018%2F07%2F09%2F%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.搭配飞行员​ 裸的匹配问题，不再详述。 2.太空飞行计划​ 要求选定一些实验，每个实验都有一定的收益，但也需要一些仪器。准备每一个仪器需要一定的花费，不同实验可以共用仪器。求最大收益。 ​ 将实验看做一个正权点，将仪器看做一个负权点，绝对值分别为它们的收益或者花费。 ​ 每个实验向所需要的仪器连一条有向边，形成一个图。 ​ 最大权闭合子图：一个点权最大的子图$A$，使得$A$中所有点的出边的到达点也属于$A$。 ​ 选定一个实验，就必须选择所有所需的仪器。我们发现，这个问题就是求原图的最大权闭合子图。 ​ ​ 最大权闭合子图问题可以用网络流建模来解决。 ​ 源点向正权点连流量为权值的边。 ​ 负权点向汇点连流量为权值绝对值的边。 ​ 原图中的边照连，流量为$+\infty$。 ​ 最大权闭合子图权值$Ans=sum-f$。其中$sum$为正权点权值之和，$f$为最大流。 ​ 要输出最大权闭合子图的方案的话，在最后一次BFS增广（即BFS增广失败）中，被标号的点即是参与点。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;namespace IO&#123; const int S=10000000; char inp[S]; int pos; void load()&#123; fread(inp,1,S,stdin); pos=0; &#125; char getChar()&#123;return inp[pos++];&#125; int getInt()&#123; int x=0; char c=getChar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='\n'||c=='\r'||c==EOF) return -1;c=getChar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getChar();&#125; pos--; return x; &#125;&#125;const int N=55,SZ=N*2,INF=1e9;int n,m,sum,val[SZ];char str[300];int pos;int S,T;int dis[SZ],cur[SZ];bool vis[SZ];queue&lt;int&gt; q;int h[SZ],tot=1;struct Edge&#123;int v,f,next;&#125;e[(N*N+N*2)*2];inline void addEdge(int u,int v,int f)&#123; //printf("%d %d %d\n",u,v,f); e[++tot]=(Edge)&#123;v,f,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,h[v]&#125;; h[v]=tot;&#125;bool bfs()&#123; while(!q.empty()) q.pop(); q.push(S); for(int i=1;i&lt;=T;i++) dis[i]=-1,cur[i]=h[i],vis[i]=false; dis[S]=0; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1)&#123; dis[v]=dis[u]+1; vis[v]=true; if(v==T) return true; q.push(v); &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int flow)&#123; if(u==T) return flow; int res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1)&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; if(!res) dis[u]=-1; return res;&#125;int dinic()&#123; int res=0; while(bfs()) res+=dfs(S,INF); return res;&#125;using IO::getInt;using IO::getChar;int main()&#123; IO::load(); n=getInt(); m=getInt(); S=n+m+1; T=S+1; for(int i=1;i&lt;=n;i++)&#123; for(val[i]=getInt();val[i]==-1;val[i]=getInt()); sum+=val[i]; addEdge(S,i,val[i]); for(int z=getInt();z!=-1;z=getInt()) addEdge(i,n+z,INF); &#125; for(int i=1;i&lt;=m;i++)&#123; for(val[n+i]=getInt();val[n+i]==-1;val[n+i]=getInt()); addEdge(n+i,T,val[n+i]); &#125; int ans=sum-dinic(); for(int u=1;u&lt;=n;u++) if(vis[u]) printf("%d ",u); puts(""); for(int u=n+1;u&lt;=n+m;u++) if(vis[u]) printf("%d ",u-n); printf("\n%d\n",ans); return 0;&#125; 3.最小路径覆盖​ 求一张图的最小不相交路径覆盖。 ### 概念 ​ 最小不相交路径覆盖：使用最少的简单路径，覆盖一张图的所有顶点，路径不可以相交。 ​ 最小可相交路径覆盖：使用最少的简单路径，覆盖一张图的所有顶点，路径可以相交。 ​ 一个点可以自成一条路径，长度为0. 解法​ 先看最小不相交路径覆盖。 ​ 将原图每个点$u$拆成$u_x,u_y$两个点，转化成一个二分图。 ​ 对于原图的每一条边$(u,v)$，在二分图中连接$(u_x,v_y)$。 ​ 则答案中所需路径条数=原图节点数-二分图最大匹配。 ​ 证明： ​ 一开始，每一个节点自成一条路径，总路径条数为总节点数$n$。每找到一个匹配，相当于首尾相接两条路径，路径数比原来少了1条。故最优方案下，减少的路径数就是最大匹配。 ​ 路径不可以有公共点，则对于一个点$u$，入边不能超过一条，出边不能超过一条边。那么在二分图中$u_x$和$u_y$都不能被多于以上的边连接，这恰好符合匹配的定义。 ​ 如果要输出每一条路径，那么如果对于$u_x,u_y$如果连一条$(u_y,u_x)$，那么每一条路径对应着在二分图的一条路径（匹配边看成从左往右），从每个路径头深搜出来即可。 ​ ​ 然后是最小可相交路径覆盖。 ​ 对于原图求出传递闭包。如果$u$可以到达$v$，则连有向边$(u,v)$。对于新图，按上述方法转二分图求解即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=205,M=6005,SZ=N*2,INF=1e9;int n,m;int S,T,dis[SZ],cur[SZ];bool head[SZ];int go[SZ];queue&lt;int&gt; q;int h1[SZ],tot=1;struct Edge&#123;int v,f,next;&#125;e[(M+SZ)*2];inline void addEdge(int u,int v,int f,int *h)&#123; e[++tot]=(Edge)&#123;v,f,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,h[v]&#125;; h[v]=tot;&#125;bool bfs()&#123; for(int i=1;i&lt;=T;i++) dis[i]=-1,cur[i]=h1[i]; while(!q.empty()) q.pop(); q.push(S); dis[S]=0; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h1[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1)&#123; dis[v]=dis[u]+1; if(v==T) return true; q.push(v); &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int flow)&#123; if(u==T) return flow; int res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1)&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; if(!res) dis[u]=-1; return res;&#125;int dinic()&#123; int res=0; while(bfs()) res+=dfs(S,INF); return res;&#125;void print(int u)&#123; if(u&gt;n)&#123; printf("%d ",u-n); print(u-n); &#125; else if(go[u]) print(go[u]);&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); S=n*2+1; T=S+1; for(int i=1;i&lt;=n;i++) addEdge(S,i,1,h1),addEdge(n+i,T,1,h1); for(int i=1,u,v;i&lt;=m;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,n+v,1,h1); &#125; int ans=n-dinic(); for(int u=1;u&lt;=n;u++) head[u]=true; for(int u=1;u&lt;=n;u++)&#123; for(int i=h1[u],v;i;i=e[i].next) if(e[i].v!=S&amp;&amp;e[i].v!=T&amp;&amp;e[i].f==0)&#123; go[u]=e[i].v; head[e[i].v-n]=false; &#125; &#125; for(int u=1;u&lt;=n;u++) if(head[u])&#123; print(n+u); puts(""); &#125; printf("%d\n",ans); return 0;&#125; 4.魔术球​ 给你编号从1到无穷大的许多球，任意两个能作为相邻球当且仅当两球编号之和为完全平方数。 ​ 现在有$n$个封底的管子，球从上面丢进管子里会叠成一列。求最多能放多少个球。 ​ 把每个球$x$看做一个点，如果该球$x$和另一个球$y$能够相邻，则连一条有向边$(x,y)$。 ​ 那么每一个管子对应的就是一条路径。考虑枚举答案$sum$，显然，$sum$个球最少所需的管道随$sum$递增而单调不减。我们看看编号为$1…sum$的球的最小不相交路径覆盖的路径条数有没有大过$n$。考虑找到最大的$sum$使得所需管道数恰好不超过$n$。 ​ 二分答案其实非常慢，这里只需要从小到大一步步加入一个点、连接相应的边，在原图上增广即可。当所需管道数大于$n$时，$sum-1$就是答案。可以直接重新按照$sum-1$构一次图。 ​ 但是这个图是一个有向带环图，不能直接用最小路径覆盖。好像有结论是存在一种最优方案使得每个管道内的球是递增的。所以当且仅当$x+y$是完全平方数且$x&lt;y$时，我们从$x$向$y$连边。这样就可以做了。 ​ 极限数据不开O2耗时600ms，开了O2耗时60ms，看到这玩意的时候我惊呆了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std;const int N=3005,M=N*N,SZ=N*2,INF=1e9;int n,m;int S,T,dis[SZ],cur[SZ];bool head[SZ],vis[SZ];int go[SZ];queue&lt;int&gt; q;int h[SZ],tot=1;struct Edge&#123;int v,f,next;&#125;e[(M+SZ)*2];inline void addEdge(int u,int v,int f,int *h)&#123; e[++tot]=(Edge)&#123;v,f,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,h[v]&#125;; h[v]=tot;&#125;bool bfs()&#123; for(int i=1;i&lt;=T;i++) dis[i]=-1,cur[i]=h[i]; while(!q.empty()) q.pop(); q.push(S); dis[S]=0; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1)&#123; dis[v]=dis[u]+1; if(v==T) return true; q.push(v); &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int flow)&#123; if(u==T) return flow; int res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1)&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; if(!res) dis[u]=-1; return res;&#125;int dinic()&#123; int res=0; while(bfs()) res+=dfs(S,INF); return res;&#125;void print(int u)&#123; if(vis[u]) return; vis[u]=true; if(u&gt;n)&#123; printf("%d ",u-n); print(u-n); &#125; else if(go[u]) print(go[u]);&#125;bool check(int x)&#123; int z=(int)(sqrt(x)+1e-6); return z*z==x;&#125;void reset()&#123; for(int i=1;i&lt;=T;i++) h[i]=0; tot=1;&#125;int main()&#123; scanf("%d",&amp;n); S=6001; T=6002; int tn,now=0; for(tn=1;;tn++)&#123; addEdge(S,tn,1,h); addEdge(3000+tn,T,1,h); for(int i=1;i&lt;tn;i++) if(check(i+tn)) addEdge(i,3000+tn,1,h); now+=dinic(); if(tn-now&gt;n) break; &#125; tn--; n=tn; reset(); for(int i=1;i&lt;=n;i++) addEdge(S,i,1,h),addEdge(n+i,T,1,h); for(int u=1;u&lt;n;u++) for(int v=u+1;v&lt;=n;v++) if(u!=v&amp;&amp;check(u+v)) addEdge(u,n+v,1,h); dinic(); printf("%d\n",n); for(int u=1;u&lt;=n;u++) head[u]=true; for(int u=1;u&lt;=n;u++)&#123; for(int i=h[u];i;i=e[i].next) if(e[i].v!=S&amp;&amp;e[i].v!=T&amp;&amp;e[i].f==0)&#123; go[u]=e[i].v; head[e[i].v-n]=false; &#125; &#125; for(int u=1;u&lt;=n;u++) if(head[u])&#123; print(n+u); puts(""); &#125; for(int u=1;u&lt;=n;u++) if(!vis[n+u])&#123; print(n+u); puts(""); &#125; return 0;&#125; 5.圆桌聚餐​ 普通最大流问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=300,SZ=N*2,INF=1e9;int n,m,sum;int S,T;int dis[SZ],cur[SZ];queue&lt;int&gt; q;int h[SZ],tot=1;struct Edge&#123;int v,f,next;&#125;e[(N*N+N+N)*2];inline void addEdge(int u,int v,int f)&#123; e[++tot]=(Edge)&#123;v,f,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,h[v]&#125;; h[v]=tot;&#125;bool bfs()&#123; for(int i=1;i&lt;=T;i++) dis[i]=-1,cur[i]=h[i]; dis[S]=0; while(!q.empty()) q.pop(); q.push(S); while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1)&#123; dis[v]=dis[u]+1; if(v==T) return true; q.push(v); &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int flow)&#123; if(u==T) return flow; int res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1)&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; if(!res) dis[u]=-1; return res;&#125;int dinic()&#123; int res=0; while(bfs()) res+=dfs(S,INF); return res;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); S=n+m+1; T=S+1; for(int i=1,x;i&lt;=n;i++)&#123; scanf("%d",&amp;x); sum+=x; addEdge(S,i,x); for(int j=1;j&lt;=m;j++) addEdge(i,n+j,1); &#125; for(int i=1,x;i&lt;=m;i++)&#123; scanf("%d",&amp;x); addEdge(n+i,T,x); &#125; int flow=dinic(); if(flow&lt;sum) puts("0"); else&#123; puts("1"); for(int u=1;u&lt;=n;u++)&#123; for(int i=h[u],v;i;i=e[i].next) if(e[i].v!=S&amp;&amp;e[i].f==0) printf("%d ",e[i].v-n); puts(""); &#125; &#125; return 0;&#125; 6.最长递增子序列​ 给一个长度为$n$的序列$a$（$n\le500$），求： ​ （1）最长非严格上升子序列长度$len$ ​ （2）从序列中最多提取多少长度为$len$的非严格上升子序列（用一个少一个） ​ （3）如果$a_1$和$a_n$能多次使用，那么（2）的答案是多少。 ​ 第一问很好做，$f_i$表示以$i$结尾的子序列最长是多少，$n^2$DP一下就完事，$len=\max{f_i}$。 ​ 对于第二问，既然每个元素只能使用一次，那么我们对每一个元素使用网络流的套路拆点，拆成两个点，从左到右连一条流量为1的边。 ​ 我们尝试构建一个模型使得最大流为第二问答案。对于内部如何连边看起来是比较显然的，但是如何限制每次增广的长度必须是$len$呢？ ​ 这点很难从网络流内部限制。但我们可以考虑哪一些点可以拥有源点流入的流量、哪一些点可以向汇点输送流量。考虑到$f_i=1$的点$i$才有权限引发一条新的序列、且$f_i=len$的点$i$才有权结束一条序列，否则如果其他点有权限引发或结束，都会使得某一些子序列的长度不为$len$。所以我们从源点向每个$f$值为1的点连一条流量为1的边，每个$f$值为$len$的点向汇点连一条流量为1的边。 ​ 实际上，对于中间的点的连边，当$i&lt;j$且$a_i\le a_j$时就从$i$向$j$连边依然会出现增广长度不为$len$的情况。我们必须另附一个条件：$f_i+1=f_j$。因为若一个点要想参与一个长度为$len$的最长子序列，它必须处在该子序列的第$f_i$个位置。 ​ 证明：若$i$在某一个最长子序列中的位置大于$f_i$，则说明有更长的以$i$结尾的子序列出现，$f_i$显然不是这个值；若$i$在某一个最长子序列$A$中的位置小于$f_i$，显然$f_i$本身在原序列中代表的某个以$i$结尾的子序列，和在$A$中$i$后方的序列拼在一起，比$A$更长，不符合$A$是最长子序列的定义。 ​ 这样，我们就保证了每一个点都只会出现在它相应的层数（序列位置）上。只有加上$f$的层数限制，转移出来才是正确的，因为这样才能保证每一次增广的长度都为$len$。 ​ 对于第三问，很简单，将源点连向1的边、1的拆点连接边的流量设为$+\infty$。如果$f_n=len$，那么将$n$连向汇点的边、$n$的拆点边的流量设为$+\infty$。再次增广即可。 Code```c++ include include include using namespace std;const int N=505,SZ=N2,INF=1e9;int n,a[N],f[N],s;int S,T,dis[SZ],cur[SZ];queue q;int h[SZ],tot=1;struct Edge{int v,f,next;}e[(NN+N3)2];inline void addEdge(int u,int v,int f){ //printf(“%d %d %d\n”,u,v,f); e[++tot]=(Edge){v,f,h[u]}; h[u]=tot; e[++tot]=(Edge){u,0,h[v]}; h[v]=tot;}inline int max(int x,int y){return x&gt;y?x:y;}bool bfs(){ while(!q.empty()) q.pop(); q.push(S); for(int i=1;i&lt;=T;i++) dis[i]=-1,cur[i]=h[i]; dis[S]=0; while(!q.empty()){ int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1){ dis[v]=dis[u]+1; if(v==T) return true; q.push(v); } } return dis[T]!=-1;}int dfs(int u,int flow){ if(u==T) return flow; int res=0,get; for(int i=cur[u],v;i&amp;&flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1){ get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; } if(!res) dis[u]=-1; return res;}int dinic(){ int res=0; while(bfs()) res+=dfs(S,INF); return res;}int main(){ scanf(“%d”,&amp;n); for(int i=1;i&lt;=n;i++) scanf(“%d”,a+i); for(int i=1;i&lt;=n;i++) f[i]=1; for(int i=2;i&lt;=n;i++) for(int j=1;j]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4205】卡牌配对]]></title>
    <url>%2F2018%2F07%2F08%2F%5BBZOJ4205%5D%E5%8D%A1%E7%89%8C%E9%85%8D%E5%AF%B9%2F</url>
    <content type="text"><![CDATA[Description 现在有一种卡牌游戏，每张卡牌上有三个属性值：A,B,C。把卡牌分为X,Y两类，分别有n1,n2张。 ​ 两张卡牌能够配对，当且仅当，存在至多一项属性值使得两张卡牌该项属性值互质，且两张卡牌类别不同。 ​ 比如一张X类卡牌属性值分别是225,233,101，一张Y类卡牌属性值分别为115,466,99。那么这两张牌是可以配对的，因为只有101和99一组属性互质。 ​ 游戏的目的是最大化匹配上的卡牌组数，当然每张卡牌只能用一次。 HINT​ 对于100%的数据，n1,n2≤ 30000，属性值为不超过200的正整数 Solution​ 又一道场上想不出来的题。 ​ 首先考虑普通网络流匹配：左边是一类卡牌，右边是另一类卡牌，两两之间看能否配对连一条容量为1的边，做一次Dinic出解。 ​ 但是完整数据中两边点数都是3万，肯定无法两两连边。这时候我们想到优化建图：我们肯定是要构造一些特殊信息点，将符合信息的卡牌分别连向它们，以此减少边数、完成匹配。 ​ 照例从源点向每一个X卡牌连一条容量为1的边，每一个Y卡牌向汇点连一条容量为1的边，限制匹配次数。 ​ 考虑中间辅助匹配的信息点是什么：至多一组数互质等价于至少两组数不互质。不互质，意味着有公约数；而至少两组数的话，我们可以分拆成三种情况：一对卡牌的AB满足条件、AC满足条件、BC满足条件。 ​ 公约数怎么处理？我们可以把所有公约数二元组看成一个信息点。以12为例，我们在中间建一列信息点$(x,y)$，所有满足$x|A$且$y|B$的X卡牌向这个点连一条容量为1的边，相应地从这个点向满足条件的Y卡牌连一条容量为1的边。我们发现，这样恰好可以使得满足AB都不互质的卡牌们进行配对过程。 ​ 同理建出其他两组信息点。三组信息点同时存在时，我们发现不论如何，一张X卡牌最多通过一种方式也就是一组信息点和另一边的某一张Y卡牌配对，同样地Y卡牌不论如何也只会通过一种方式配对。即使是ABC都满足的一对卡牌，也会选择从某一组信息点流过。 ​ 建模完成，过程优美。 ​ 但是$(x,y)$的点数足足有$3200200$个，太多了。其实有公约数不就是有公质因子吗？200以内的素数仅仅有46个，所以现在我们只需要把信息点的$(x,y)$变更成质数的组合$(p_i,p_j)$，按上述连边即可。信息点点数仅仅有$34646=6348$个。 ​ Dinic是跑得过的，有极大的速度优势。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=30005,INF=1000000000,SZ=68000,M=6000000;int p[N],pcnt,minp[N],id[N];bool vis[N];int n1,n2,a[N*2][3];int h[SZ],tot=1;int S,T,dis[SZ],cur[SZ];queue&lt;int&gt; q;struct Edge&#123;int v,f,next;&#125;e[M*2];inline void addEdge(int u,int v,int f)&#123; e[++tot]=(Edge)&#123;v,f,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,h[v]&#125;; h[v]=tot;&#125;void sieve()&#123; minp[1]=1; for(int i=2;i&lt;=200;i++)&#123; if(!vis[i])&#123; p[++pcnt]=i; minp[i]=i; id[i]=pcnt; &#125; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;=200;j++)&#123; int x=i*p[j]; vis[x]=true; if(i%p[j]==0)&#123; minp[x]=p[j]; break; &#125; minp[x]=p[j]; &#125; &#125;&#125;bool bfs()&#123; for(int i=1;i&lt;=T;i++) dis[i]=-1,cur[i]=h[i]; while(!q.empty()) q.pop(); q.push(S); dis[S]=0; while(!q.empty())&#123; int u=q.front(); q.pop(); for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==-1)&#123; dis[v]=dis[u]+1; if(v==T) return true; q.push(v); &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int flow)&#123; if(u==T) return flow; int res=0,get; for(int i=cur[u],v;i&amp;&amp;flow;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]==dis[u]+1)&#123; get=dfs(v,min(flow,e[i].f)); e[i].f-=get; e[i^1].f+=get; if(e[i].f) cur[u]=i; flow-=get; res+=get; &#125; if(!res) dis[u]=-1; return res;&#125;int dinic()&#123; int res=0; while(bfs()) res+=dfs(S,INF); return res;&#125;void deal(int x,int *l,int &amp;cnt)&#123; cnt=0; while(x!=1)&#123; l[++cnt]=id[minp[x]]; int p=minp[x]; while(x%p==0) x/=p; &#125;&#125;int main()&#123; sieve(); scanf("%d%d",&amp;n1,&amp;n2); for(int i=1;i&lt;=n1+n2;i++) scanf("%d%d%d",&amp;a[i][0],&amp;a[i][1],&amp;a[i][2]); S=n1+n2+46*46*3+1; T=S+1; for(int i=1;i&lt;=n1;i++) addEdge(S,i,1); for(int i=1;i&lt;=n2;i++) addEdge(n1+i,T,1); int l1[5],l2[5],l3[5],t1,t2,t3; for(int u=1;u&lt;=n1+n2;u++)&#123; deal(a[u][0],l1,t1); deal(a[u][1],l2,t2); deal(a[u][2],l3,t3); for(int i=1;i&lt;=t1;i++) for(int j=1;j&lt;=t2;j++)&#123; int id=46*(l1[i]-1)+(l2[j]-1)+1; u&lt;=n1?addEdge(u,n1+n2+id,1):addEdge(n1+n2+id,u,1); &#125; for(int i=1;i&lt;=t1;i++) for(int j=1;j&lt;=t3;j++)&#123; int id=46*(l1[i]-1)+(l3[j]-1)+1; u&lt;=n1?addEdge(u,n1+n2+46*46+id,1):addEdge(n1+n2+46*46+id,u,1); &#125; for(int i=1;i&lt;=t2;i++) for(int j=1;j&lt;=t3;j++)&#123; int id=46*(l2[i]-1)+(l3[j]-1)+1; u&lt;=n1?addEdge(u,n1+n2+2*46*46+id,1):addEdge(n1+n2+2*46*46+id,u,1); &#125; &#125; printf("%d\n",dinic()); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>优化建图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插头DP]]></title>
    <url>%2F2018%2F07%2F05%2F%E6%8F%92%E5%A4%B4DP%2F</url>
    <content type="text"><![CDATA[简介 插头DP（轮廓线DP）是用来解决网格图回路问题的一种算法。 插头DP解决的经典问题就是统计经过所有格子的哈密顿回路条数，某些格子有障碍。 如果问题稍微进阶一点的话，不一定要求路径是回路、路径带权等等情况都可能出现。 它的时间复杂度比较高，但是已经属于比较高效的算法了。 基本概念 首先看经典问题：统计一个带障碍的$n*m$网格中$(n,m\le 12)$，经过所有格子的哈密顿回路的条数。 插头DP的状态围绕轮廓线进行转移。 我们的状态是$f(i,j,state)$，表示$(i,j)$格子转移完成后、轮廓线状态为$state$时的情况数。 轮廓线的形状相对于每一个$(i,j)$是确定的。$(i,j)$转移之前到转移之后，轮廓线的形状、变化如图所示： 即转移的格子$(i,j)$原来是轮廓线上的一个凸出点，转移后把轮廓线“从左上往右下拉”，使得$(i,j)$变成一个凹格。 轮廓线的长度为$m+1$，我们需要记录轮廓线的每一条边的上方（对于轮廓线中打竖的那条边，则是左方），是否有边作为接口，即是否有插头。这个信息，我们存在$state$中。 轮廓线所体现的，一是轮廓线上的插头状态，告诉你每一个地方是否应该用一条路径“接上”；二是所有路径的连通性：显然，路径是两两相连，两两成对的，我们分组标号来记录。下面用几幅图来表达一下轮廓线的记录方式： 括号的每个数代表对应轮廓线边的状态，”0”表示没有路径连接，其他数表示一对路径，每对路径的标号一样。 考虑到标号的大小没有保证，会导致状态的储存十分困难。 我们另寻他法：注意到每对路径在轮廓线上的接口不会相交，即不会出现$(…,x,…,y,…x,…y,…)$的这种诡异情况。所以我们可以用括号序列来表示路径信息。还是上述三个例子： 这样一来，状态$state$可以看做一个$m+1$位的3进制数：0表示无接口，1表示一对路径的左端，2表示一对路径的右端。 转移 $f(i,j,state)​$的转移来源，是$f(i,j-1,state’)​$，但这样不好考虑和枚举。我们用$f(i,j,state)​$，转移到$f(i,j+1,state’)​$。 我们将$f(i,j,\forall state)$转移到$f(i,j+1,\forall state’)$称作大转移。 显然，我们只需要关注轮廓线上唯一变动的两条边：我们把轮廓线从左上拉到右下，这两条边的状态会更改，更改后是什么呢？取决于新的一格内路径怎么走： 我们现在关注转移的位点： 大转移的整体步骤是：枚举每一个状态$state$，得到$p_a$和$p_b$，根据$p_a$和$p_b$的取值，枚举$(i,j)$的路径走法，对于选择的$(i,j)$的走法，由$state$修改$p_a$和$p_b$分别变成$p_a’$和$p_b’$而得到新状态$state’$，执行$f(i,j+1,state’)+=f(i,j,state)$。 根据$p_a,p_b$枚举走法分三大类情况： $p_a=0\;,p_b=0$： 这表明$(i,j)$的左方和上方没有路径连接，则当前格只能选取1号走法。 令$p_a’=1,p_b’=2$得到新状态。（转移前提：$i&lt;n且j&lt;m$，否则将出现连向网格边界的路径） $p_a$和$p_b$恰好有一个是0： 这表明$(i,j)$的左方或者上方有一条路径连接。 由于这种走法只是将连进来的路径延长，所以这条路径在原轮廓线和新轮廓线上的性质是一样的，括号表示相同，其值也相同。 令$p_a’=p_a+p_b,\;p_b’=0$代表3号（$p_a\neq0$）或5号（$p_b\neq0$）走法。（转移前提：$i&lt;n$） 令$p_a’=0,\;p_b’=p_a+p_b$代表2号（$p_a\neq0$）或4号（$p_b\neq 0$）走法。（转移前提：$j&lt;m$） $p_a$和$p_b$皆不为0： 这表明$(i,j)$的左方和上方都有路径连接，所以$(i,j)$能填的只有6号走法，令$p_a’=0,\;p_b’=0$。可是我们将两条路径连接起来后，其他位置的状态也需要改变，因为括号序列发生了变动。 $p_a=1,\;p_b=1$：两条左端路径此刻相连，对于$b$对应的右端路径位置$c$，应该令$p_c’=1$，此时$c$和$a$对应的右端路径$d$是一对路径。 $p_a=2,\;p_b=2$：两条右端路径此刻相连，同上，对于$a$的左端路径位置$c$，令$p_c’=2$。 以上寻找对应括号路径，用括号序列配对的方式实现，复杂度$\mathcal O(m)​$ $p_a=1\;,p_b=2$：一条回路此时形成。注意！这个转移只能在最后一个非障碍的位置发生，在其他任意位置连成回路都是不合法的方案。而且，答案就是被这种方式转移的量之和。这种情况我们不需要转移了，你可以姑且理解为这已经是最后一步大转移；但是对于进阶问题，如回路不一定要经过所有点，则是因为这种转移不应该被后续过程所利用（因为路径已经形成），并且答案统计可以在任意位置进行。 $p_a=2,\;p_b=1$：相当于从中间拼接两条路径，这种情况最舒服，因为其他位置都不会有任何变化。 转移种类较多，但是写起来其实是很好实现的。 实现 你可以将$f(i,j,state)$设成一个数组，但是这样非常不便，且大转移时要枚举所有状态，非常的缓慢，而在实际中，许多状态是不合法的。 我们用两个哈希表$s_0,s_1$来分别模拟$f(i,j)$和$f(i,j+1)$：所有有效的$f(i,j,state)$存在$s_0$中，大转移开始前，我们可以从$s_0$里提取所有有效状态，逐一转移至$s_1$中，也就是有效的$f(i,j+1,state)$。下一步大转移开始前，交换两个哈希表，并清空$s_1$即可。 对于一个轮廓线状态$x$，为了操作方便，需要实现两个函数：提取某一位的值、改变某一位的值。上述括号配对表达方式中状态仅有012三种，但我们可以用四进制来表示，因为位运算的效率相对来说会比较高。 总结&amp;&amp;代码​ 插头DP看起来十分难写，但只要自己动手实现一遍，就能理清楚插头DP的基本架构，就会发现它的实现方式其实挺简明的。建议读者还是自我摸索比较好。不过这里还是贴上模板题BZOJ1814的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#define Push(x,y) s[hv].insert((x),(y));using namespace std;typedef long long ll;const int N=13,BAS[13]=&#123;1,4,16,64,256,1024,4096,16384,65536,262144,1048576,4194304,16777216&#125;;const int HASH_MOD=4001,S=50000;int n,m,mp[N][N],ln,lm;int qcnt,q1[S],hu,hv;ll q2[S];ll ans;char str[N];inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;inline int get(int st,int x)&#123; st&gt;&gt;=(x-1)&lt;&lt;1; return st-((st&gt;&gt;2)&lt;&lt;2);&#125;inline void mdf(int &amp;st,int x,int y)&#123; st+=(y-get(st,x))*BAS[x-1];&#125;int match(int st,int x,int d)&#123; int top=1,stdcol=get(st,x); for(x+=d;top;x+=d)&#123; int v=get(st,x); if(v==0) continue; (v==stdcol)?top++:top--; &#125; return x-d;&#125;struct Hash&#123; int head[S],tot,id[S],nex[S]; ll val[S]; void reset()&#123; tot=0; for(int i=0;i&lt;HASH_MOD;i++) head[i]=0; &#125; inline int get_hash(int x)&#123;return x%HASH_MOD;&#125; void insert(int x,ll value)&#123; int hs=get_hash(x),u; for(u=head[hs];u&amp;&amp;id[u]!=x;u=nex[u]); if(!u)&#123; id[++tot]=x; val[tot]=value; nex[tot]=head[hs]; head[hs]=tot; &#125; else val[u]+=value; &#125; void layout(int &amp;n,int *lis1,ll *lis2)&#123; n=0; for(int i=0;i&lt;HASH_MOD;i++) for(int u=head[i];u;u=nex[u]) n++,lis1[n]=id[u],lis2[n]=val[u]; &#125;&#125;s[2];void draw(int i,int j)&#123; int a=j,b=j+1,pa,pb; s[hu].layout(qcnt,q1,q2); int x; ll y; while(qcnt)&#123; x=q1[qcnt]; y=q2[qcnt--]; if(!y) continue; if(j==1) x=(x-get(x,m+1)*BAS[m])&lt;&lt;2; pa=get(x,a); pb=get(x,b); if(mp[i][j]==1)&#123; if(!pa&amp;&amp;!pb) Push(x,y); continue; &#125; if(!pa&amp;&amp;!pb)&#123; if(i&lt;n&amp;&amp;j&lt;m)&#123; mdf(x,a,1); mdf(x,b,2); Push(x,y); &#125; &#125; else if(pa&amp;&amp;pb)&#123; if(pa==1&amp;&amp;pb==1)&#123; int pos=match(x,b,1); mdf(x,pos,1); mdf(x,a,0); mdf(x,b,0); Push(x,y); &#125; else if(pa==2&amp;&amp;pb==2)&#123; int pos=match(x,a,-1); mdf(x,pos,2); mdf(x,a,0); mdf(x,b,0); Push(x,y); &#125; else if(pa==1&amp;&amp;pb==2)&#123; if(i==ln&amp;&amp;j==lm)&#123; bool flag=true; for(int k=1;k&lt;=m+1&amp;&amp;flag;k++) if(k!=a&amp;&amp;k!=b&amp;&amp;get(x,k)) flag=false; if(flag) ans+=y; &#125; &#125; else&#123;//pa==2&amp;&amp;pb==1 mdf(x,a,0); mdf(x,b,0); Push(x,y); &#125; &#125; else&#123; int u=pa,v=pb; if(i&lt;n)&#123; mdf(x,a,u+v); mdf(x,b,0); Push(x,y); &#125; if(j&lt;m)&#123; mdf(x,a,0); mdf(x,b,u+v); Push(x,y); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",str+1); for(int j=1;j&lt;=m;j++)&#123; if(str[j]=='.') mp[i][j]=0; else mp[i][j]=1; if(mp[i][j]!=1) ln=i,lm=j; &#125; &#125; hu=0; hv=1; s[hu].insert(0,1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)&#123; draw(i,j); swap(hu,hv); s[hv].reset(); &#125; printf("%lld\n",ans); return 0;&#125; ​ ​]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>DP---插头DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4709】]]></title>
    <url>%2F2018%2F07%2F01%2F%5BBZOJ4709%5D%2F</url>
    <content type="text"><![CDATA[Description 传送门 ​ 将一个长度为$n$的序列划分成任意多段，从每一段选出一个数$x$，获得$x*(x在这一段出现的次数)^2$的贡献。求总贡献最大值。 $n \le 10^5$ Solution​ 首先，要发现一个很重要的性质：如果某一段选了$x$，那么这一段一定是以$x$开头、以$x$结尾的一段。否则，可以将此段缩减至以$x$开头、以$x$结尾的更小的一段，虽然贡献没有变，但留给其他段的机会更多。 ​ 设$fi$表示$1…i$的贡献最大值。记$a_i$表示$i$的数值，$b_i$表示$a_i$在相同的值中是第几个出现的。显然如果要从别的$f_j$转移到$f_i$，必须满足$a{j+1}==a_i$。我们有转移方程： f_i=\max \{f_{j-1}+a_i(b_i-b_j+1)^2\}\;\;\;j\le i,a_j=a_i​ 设$j$为最优转移点： \begin{aligned} f_i&=f_{j-1}+a_i(b_i-(b_j-1))^2\\ f_i&=f_{j-1}+a_i(b_i^2-2b_i(b_j-1)+(b_j-1)^2)\\ f_i&=f_{j-1}+a_ib_i^2-2a_ib_i(b_j-1)+a_i(b_j-1)^2\\ f_{j-1}+a_i(b_j-1)^2&=2a_ib_i(b_j-1)+f_i-a_ib_i^2 \end{aligned}​ 这其实是一个直线的式子：$k=2aib_i$，$x=(b_j-1)$，$b=(f_i-a_ib_i^2)$，$y=f{j-1}+a_i(b_j-1)^2$. ​ 在$y$的式子中，$a_i$看似和$j$无关，无法继续推理。但由于转移的$j$满足$a_j=a_i$，所以每一个位置的数在参与上述DP时，相关联的$a$其实就是每一个元素自己的数值，是一个定值。 ​ 把每一个元素看成二维平面的一个点$(x,y)$。由于最优转移相当于最大化截距，即最大化$f_i$所处的元素$b$的值，那么最优转移点$j$可以看做在斜率为$k$的时候上凸包碰到的第一个点。 ​ 那么我们扫描序列时，维护每一个数值对应的上凸包，每次查询时在上面二分即可。 ​ 时间复杂度$\mathcal O(n \lg n)$。 ​ 当然，也可以用斜率优化直接做。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;vector&gt;#define k(i) (2LL*a[i]*b[i])#define x(i) (b[i]-1LL)#define y(i) (f[i-1]+1LL*a[i]*(b[i]-1)*(b[i]-1))#define b(i) (f[i]-1LL*a[i]*b[i]*b[i])#define pb push_back#define db pop_backusing namespace std;typedef long long ll;const int N=100005,S=10005;const double EPS=1e-6;int n,a[N],ecnt[S],b[N];ll f[N];vector&lt;int&gt; s[S];int slen[S];double slope(int u,int v)&#123;return 1.0*(y(v)-y(u))/(x(v)-x(u));&#125;int query(int col,int k)&#123; k=2*col*k; int l=0,r=slen[col]-2,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(slope(s[col][mid],s[col][mid+1])-EPS&lt;=k) r=mid-1; else l=mid+1; &#125; return s[col][l];&#125;void insert(int col,int i)&#123; int sz=slen[col]; while(sz&gt;1&amp;&amp;slope(s[col][sz-2],s[col][sz-1])&lt;slope(s[col][sz-1],i)) sz--,slen[col]--,s[col].db(); s[col].pb(i); slen[col]++;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%d",a+i); b[i]=++ecnt[a[i]]; &#125; for(int i=1;i&lt;=n;i++)&#123; insert(a[i],i); int j=query(a[i],b[i]); f[i]=(j?f[j-1]:f[i-1])+1LL*a[i]*(b[i]-b[j]+1)*(b[i]-b[j]+1); &#125; printf("%lld\n",f[n]); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>DP---斜率优化</tag>
        <tag>凸包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4197】]]></title>
    <url>%2F2018%2F06%2F30%2F%5BBZOJ4197%5D%2F</url>
    <content type="text"><![CDATA[Description​ 为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。 ​ 在晚宴上,主办方为大家提供了 n−1 种不同的寿司，编号 1,2,3,…,n−1，其中第 i 种寿司的美味度为 i+1 （即寿司的美味度为从 2 到 n）。 ​ 现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 x 的寿司，小 W 品尝的寿司中存在一种美味度为 y 的寿司，而 x 与 y 不互质。 ​ 现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 p 取模）。注意一个人可以不吃任何寿司。 Input​ 输入文件的第 1 行包含 2 个正整数 n,p，中间用单个空格隔开，表示共有 n 种寿司，最终和谐的方案数要对 p 取模。 Output​ 输出一行包含 1 个整数，表示所求的方案模 p 的结果。 Sample Input​ 3 10000 Sample Output​ 9 Hint​ $2\le n\le 500$，$0&lt;p\le 10^9$。 Solution​ 首先考虑最直接的状压DP：两个人的选择方案合法，当且仅当两人各自所选编号的质因子无交集。 ​ 记$f[i][s_A][s_B]$表示当前选到$i$号数，一个人选择的数质因子状态为$s_A$，A另一人为$s_B$的总方案数。其中第一维可以省去。 ​ 但是500以内的质数还是很多，$s_A$和$s_B$压不起来，怎么做呢？ ​ 考虑每一个数都是由若干个小于等于$\sqrt {500}$的质数乘起来，再乘上一个剩余部分$l$：一个大于$\sqrt{500}$的质数或者1得到。我们发现小于等于$\sqrt{500}$也就是22.36的质数恰好只有8个，此时$s$的大小为256，是可以开得下上述数组的。 ​ 处理出所有数包含小于根号质数的状态，并按剩余部分$l$从小到大排序。剩余部分为1的数显然可以按上述基础方法直接DP。 ​ 接下来，对于剩余部分$l$不为1的每一段数，我们发现，两人不可能同时取这一段中的数 ——要么A不要动，让B自己选择；要么B不要动，让A自己选择。 ​ 所以把每一段$l$相同的数拉出来DP一次。记$g_A[s_A][s_B]$表示只让A取这一段的方案数，$g_B[s_A][s_B]$同理。两个DP是独立分开的。枚举该段中每一个数，看某人选了是否不会和另一人冲突，并决定选还是不选。 ​ DP开始前$g_A[s_A][s_B]=g_B[s_A][s_B]=f[s_A][s_B]$。该段DP完成后，反过来把走过这一段后的数据更新回$f$： $f[s_A][s_B]=g_A[s_A][s_B]+g_B[s_A][s_B]-f[s_A][s_B]$。注意后面要减去一个未DP前的方案数，因为两个$g$加起来时，两人都不选的情况总共被算了2次。 ​ 从此题我们可以得到一些启发：如果状态压不下，那就应该考虑能否减少状态规模，如找到特殊的元素单独考虑。 ​ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N=505,p[9]=&#123;0,2,3,5,7,11,13,17,19&#125;;int n,MOD;int f[260][260],g[2][260][260];inline int plu(int x,int y)&#123;return (x+y)%MOD;&#125;inline int mul(int x,int y)&#123;return 1LL*x*y%MOD;&#125;inline void upd(int &amp;x,int y)&#123;x=plu(x,y);&#125;inline bool in(int st,int i)&#123;return (st&gt;&gt;(i-1))&amp;1;&#125;inline int bit(int i)&#123;return 1&lt;&lt;(i-1);&#125;struct Data&#123;int x,state,bigp;&#125;d[N];bool cmp(const Data &amp;a,const Data &amp;b)&#123;return a.bigp&lt;b.bigp;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;MOD); for(int i=2;i&lt;=n;i++)&#123; int x=i,y=0; for(int i=1;i&lt;=8;i++) if(x%p[i]==0)&#123; y|=bit(i); while(x%p[i]==0) x/=p[i]; &#125; d[i-1]=(Data)&#123;i,y,x&#125;; &#125; sort(d+1,d+1+(n-1),cmp); f[0][0]=1; int i,j,all=1&lt;&lt;8; for(i=1;d[i].bigp==1;i++)&#123; for(int x=all-1;x&gt;=0;x--) for(int y=all-1;y&gt;=0;y--)&#123; if(!(d[i].state&amp;y)) upd(f[x|d[i].state][y],f[x][y]); if(!(d[i].state&amp;x)) upd(f[x][y|d[i].state],f[x][y]); &#125; &#125; for(j=i;i&lt;n;)&#123; for(int x=0;x&lt;all;x++) for(int y=0;y&lt;all;y++) g[0][x][y]=g[1][x][y]=f[x][y]; for(;j&lt;n&amp;&amp;d[i].bigp==d[j].bigp;j++); for(;i&lt;j;i++)&#123; for(int x=all-1;x&gt;=0;x--) for(int y=all-1;y&gt;=0;y--)&#123; if(!(d[i].state&amp;y)) upd(g[0][x|d[i].state][y],g[0][x][y]); if(!(d[i].state&amp;x)) upd(g[1][x][y|d[i].state],g[1][x][y]); &#125; &#125; for(int x=0;x&lt;all;x++) for(int y=0;y&lt;all;y++) f[x][y]=plu(plu(g[0][x][y],g[1][x][y]),-f[x][y]); &#125; int ans=0; for(int x=0;x&lt;all;x++) for(int y=0;y&lt;all;y++) upd(ans,f[x][y]); printf("%d\n",plu(ans,MOD)); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>DP---状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4903】]]></title>
    <url>%2F2018%2F06%2F30%2F%5BBZOJ4903%5D%2F</url>
    <content type="text"><![CDATA[Description​ 传送门 ​ 简述题意：给一个序列，询问有多少子序列满足其中不会出现$a\choose b$是偶数的情况，其中$a$在$b$前面。 Solution​ 首先探究组合数的奇偶性问题。我们用Lucas定理展开组合数，可以发现一些有趣的性质： {a\choose b}={\lfloor\frac a 2 \rfloor\choose \lfloor \frac b2\rfloor}{a\mod2 \choose b\mod 2}​ 后一个括号的值可以直接算：${0\choose 0}={1\choose 0}={1\choose 1}=1,\;\;{0\choose 1}=0$。这相当于$a$和$b$的二进制最末位的某种计算。 ​ 而想象一下第一个括号递归计算的过程，实际上是移除了$a$和$b$的二进制最后一位继续计算。到底层时，其值必定是1。 ​ 所以决定总体奇偶的地方在于第二个括号会不会取0。也就是会不会出现$a$末位为0，$b$末位为1的情况。 ​ 这整一个过程的实质是什么？相当于比较$a$和$b$的每一位对应二进制。一旦出现$a$某一位为0，$b$对应位为1，则整体为偶数。否则整体为奇数。 ​ 再进一步考虑，这种条件，相当于判断$b$的1位集合是否是$a$的1位集合的子集，则整体奇数，否则整体偶数。 ​ 这种关系具有传递性：如果$a$包含$b$，那么$a$包含以$b$开头的合法子序列的每个元素。问题变得非常简单，只需要考虑从哪一个子序列的开头转移：设$f[a]$表示以$a$为开头的子序列个数。枚举$a$的子集$b$，如果$b$在$a$后面，则$f[a]+=f[b]$。 ​ 总时间复杂度为$\mathcal O(3^{\log_2n})$。 ​ Code1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=211990,S=233335,MOD=1e9+7;int n,a[N],p[S],f[S];inline int plu(int x,int y)&#123;return (x+y)%MOD;&#125;inline void upd(int &amp;x,int y)&#123;x=plu(x,y);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); int ans=-n; for(int i=n;i&gt;=1;i--)&#123; f[a[i]]=1; for(int j=(a[i]-1)&amp;a[i];j;j=(j-1)&amp;a[i]) upd(f[a[i]],f[j]); upd(ans,f[a[i]]); &#125; printf("%d\n",plu(ans,MOD)); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>数论---Lucas定理</tag>
        <tag>数论---组合数学</tag>
        <tag>分类讨论</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4006】]]></title>
    <url>%2F2018%2F06%2F30%2F%5BBZOJ4006%5D%2F</url>
    <content type="text"><![CDATA[Description​ 传送门 Solution​ 题目要求相同颜色的点必须在一个连通块中，但会有多个颜色同属一个连通块使得解更优的情况。 ​ 想一想DP能否行得通：设$g_i$表示已考虑颜色状态为$i$时，最小合法方案的代价。 ​ 首先，$g_i$可以有一个直观的初值：由颜色属于$i$的点构建的一棵最小生成树的边权和。（初始化） ​ 接下来，如何考虑两部分颜色各自的连通块合起来作为最优解的情况？（两子集合并更新） ​ 更新$gi$时，我们枚举$i$的两个不相交子集$s_1,s_2$且$s_1\cup s_2=i$，并用$g{s1}+g{s_2}$来更新$g_i$，即直接尝试将两个连通块取交。不需要担心两部分会有重复计算某一条边的情况，因为这是子集枚举DP，有边重复计算的转移自然不会成为最优转移，最优的转移一定会被枚举到（或者就是初值最优）。 ​ 以上两种方法并用，就可以顺利DP出$g$。 ​ 答案就是$g_{all}$。$all$是包含所有颜色的集合。 ​ 对于$g$的初值，直接用斯坦纳树计算所有关键点的不同组合的最小生成树即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N=1005,M=3005,C=10,INF=1e9;int n,m,p,col[N],tin[N][2],colst[C+1];int idcnt,id[N],rep[C+1];int clis[C+1],ccnt;int f[N][1&lt;&lt;C],g[1&lt;&lt;C];queue&lt;int&gt; q;bool inq[N];int h[N],tot;struct Edge&#123;int v,w,next;&#125;e[M*2];inline int bit(int i)&#123;return !i?0:(1&lt;&lt;(i-1));&#125;inline bool in(int st,int i)&#123;return (st&gt;&gt;(i-1))&amp;1;&#125;inline void addEdge(int u,int v,int w)&#123; e[++tot]=(Edge)&#123;v,w,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,w,h[v]&#125;; h[v]=tot;&#125;void read()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;p); for(int i=1,u,v,w;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;w); addEdge(u,v,w); &#125; for(int i=1,c,u;i&lt;=p;i++)&#123; scanf("%d%d",&amp;c,&amp;u);// c ? tin[i][0]=c; tin[i][1]=u; clis[++ccnt]=c; &#125; sort(clis+1,clis+1+ccnt); ccnt=unique(clis+1,clis+1+ccnt)-clis-1; for(int i=1,u,c;i&lt;=p;i++)&#123; c=lower_bound(clis+1,clis+1+ccnt,tin[i][0])-clis; u=tin[i][1]; col[u]=c; id[u]=++idcnt; rep[c]=u; colst[c]|=bit(id[u]); &#125;&#125;void spfa(int st)&#123; while(!q.empty())&#123; int u=q.front(); q.pop(); inq[u]=false; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; int ns=st|bit(id[v]); if(f[u][st]+e[i].w&lt;f[v][ns])&#123; f[v][ns]=f[u][st]+e[i].w; if(!inq[v])&#123; inq[v]=true; q.push(v); &#125; &#125; &#125; &#125;&#125;void steinerTree()&#123; int all=1&lt;&lt;p; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;all;j++) f[i][j]=INF; f[i][bit(id[i])]=0; &#125; for(int j=1;j&lt;all;j++)&#123; for(int i=1;i&lt;=n;i++) if(!(id[i]&amp;&amp;!in(j,id[i])))&#123; for(int sub=(j-1)&amp;j;sub;sub=(sub-1)&amp;j)&#123; int x=sub|bit(id[i]),y=(j^sub)|bit(id[i]); if(f[i][x]+f[i][y]&lt;f[i][j]) f[i][j]=f[i][x]+f[i][y]; &#125; if(f[i][j]!=INF) q.push(i),inq[i]=true; &#125; spfa(j); &#125;&#125;void solve()&#123; int all=1&lt;&lt;ccnt; for(int i=1;i&lt;all;i++)&#123; int st=0,rt=0; for(int j=1;j&lt;=ccnt;j++) if(in(i,j)) st|=colst[j],rt=rep[j]; g[i]=f[rt][st]; for(int sub=(i-1)&amp;i;sub;sub=(sub-1)&amp;i) g[i]=min(g[i],g[sub]+g[i^sub]); &#125; printf("%d\n",g[all-1]);&#125;int main()&#123; read(); steinerTree(); solve(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>斯坦纳树</tag>
        <tag>DP---状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3675】]]></title>
    <url>%2F2018%2F06%2F30%2F%5BBZOJ3675%5D%2F</url>
    <content type="text"><![CDATA[Description​ 传送门 Solution​ 之前我也遇到过一次这种“两段之和乘积作为贡献“的问题：考虑把这一种$(\sum) *(\sum)$的形式拆括号，就可以发现贡献其实就是分别处于左右的两两元素乘积之和。 ​ 题目的分割$k$次，其实就是要你把序列分成$k+1$段。 ​ 再考虑在题目中如此的分割方法下，贡献是怎么产生的。对于每一个元素$a_i$，每次分割时，若涉及到自己，则会贡献一定的乘积$a_i(\sum)$。细心想一想就会发现，这个$\sum$的总值就是在最终方案下不处于$a_i$所在段的元素之和。 ​ 单向考虑每一项乘积，（这里有点跳）总的来算，每一段$[l,r]$的贡献就是$(\sum{i=l}^ra_i)(\sum{i=1}^{l-1}ai)$。记$a$的前缀和为$s$，则贡献是$(s_r-s{l-1})s_{l-1}$. ​ 我们可以写出DP式，$f_{i,j}$表示前$i$个数恰好分成$j$段的贡献最大值： f_{i,j}=\max\{f_{k,j-1}+(s_i-s_k)s_k\}\;\;(kf_{k}+(s_i-s_k)s_k\\ f_j+s_is_j-s_j^2&>f_k+s_is_k-s_k^2\\ s_i(s_j-s_k)&>(s_j^2-f_j)-(s_k^2-f_k)\\ \frac{(s_j^2-f_j)-(s_k^2-f_k)}{(s_j-s_k)}&]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>DP---斜率优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分数规划]]></title>
    <url>%2F2018%2F06%2F28%2F%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[分数规划​ 分数规划是一类决策性问题。一般地，题目会要求你针对问题规划一种方案，使得其代价函数最小或最大。其中，代价函数一般是分数形式，且分子分母的构成元素一般呈现一一对应关系。 ​ 直接上例题观察：BZOJ2402 ​ ​ 分数规划的重要思路是二分答案。我们记答案为$c$，则问题转变为判断是否存在$(i,j)$使得 \frac{y_i+q_j}{x_i+p_j}\ge c\\ y_i+q_j\ge c(x_i+p_j)\\ (y_i-c*x_i)+(q_j-c*p_j)\ge0​ 化简后我们发现，原本分别处于分子和分母的元素有了一一对应的关系，使得每一类元素之间在表达式上互不干扰。只要知道此式有没有可能成立，就能判断$c$是否合法。这也是分数规划的一个重要突破点。 ​ 所以显然是要分别找到$a$到$b$的路径上两个点$i,j$，使得$(y_i-cx_i)$和$(q_j-cp_j)$分别取最大值。如果两者加起来大于等于0，说明$c$这个答案合法，因此我们提升二分下界；否则$c$答案不合法，我们降低二分上界。 ​ 取最大值的这些操作，可以用树剖+上凸包回答。 ​ 总的时间复杂度是$O(n\log^4n)$，但是能过！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define mp make_pair#define pb push_backusing namespace std;typedef pair&lt;double,double&gt; pdd;const int N=30005;const double EPS=1e-6;int n;double a[N][4];int h[N],tot,dep[N],pre[N][16],size[N],son[N];struct Edge&#123;int v,next;&#125;e[N*2];int who[N],loc[N],locnt,top[N];inline void addEdge(int u,int v)&#123; e[++tot]=(Edge)&#123;v,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,h[v]&#125;; h[v]=tot;&#125;void dfs1(int u,int fa)&#123; size[u]=1; son[u]=0; dep[u]=dep[fa]+1; pre[u][0]=fa; for(int i=1;i&lt;=15;i++) pre[u][i]=pre[pre[u][i-1]][i-1]; for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; dfs1(v,u); size[u]+=size[v]; if(!son[u]||size[v]&gt;size[son[u]]) son[u]=v; &#125;&#125;void dfs2(int u,int _top)&#123; top[u]=_top; who[loc[u]=++locnt]=u; if(!son[u]) return; dfs2(son[u],_top); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=pre[u][0]&amp;&amp;v!=son[u]) dfs2(v,v);&#125;inline void merge(pdd &amp;u,pdd v)&#123; if(v.first&gt;u.first) u.first=v.first; if(v.second&gt;u.second) u.second=v.second;&#125;inline double getk(pdd u,pdd v)&#123;return (v.second-u.second)/(v.first-u.first);&#125;struct Hull&#123; vector&lt;pdd&gt; a; void insert(double x,double y)&#123;a.pb(mp(x,y));&#125; void build()&#123; sort(a.begin(),a.end()); int top=0; vector&lt;pdd&gt; st; for(int i=0,sz=a.size();i&lt;sz;i++)&#123; while(top&gt;1&amp;&amp;getk(st[top-2],st[top-1])&lt;getk(st[top-1],a[i])) top--,st.pop_back(); st.pb(a[i]); top++; &#125; a=st; a.resize(top); &#125; double query(double k)&#123; int l=0,r=a.size()-2,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(getk(a[mid],a[mid+1])-EPS&lt;=k) r=mid-1; else l=mid+1; &#125; return a[l].second-k*a[l].first; &#125;&#125;;namespace SEG&#123; int rt,sz,ch[N*2][2]; Hull s[N*2][2]; void build(int &amp;u,int l,int r)&#123; u=++sz; for(int i=l;i&lt;=r;i++)&#123; int x=who[i]; s[u][0].insert(a[x][0],a[x][1]); s[u][1].insert(a[x][2],a[x][3]); &#125; s[u][0].build(); s[u][1].build(); if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; pdd query(int u,int l,int r,int L,int R,double k)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return mp(s[u][0].query(k),s[u][1].query(k)); pdd res=mp(-1e10,-1e10); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) merge(res,query(ch[u][0],l,mid,L,R,k)); if(mid&lt;R) merge(res,query(ch[u][1],mid+1,r,L,R,k)); return res; &#125;&#125;int getLCA(int u,int v)&#123; if(dep[u]&lt;dep[v]) swap(u,v); for(int i=15;i&gt;=0;i--) if(dep[pre[u][i]]&gt;=dep[v]) u=pre[u][i]; if(u==v) return u; for(int i=15;i&gt;=0;i--) if(pre[u][i]!=pre[v][i]) u=pre[u][i],v=pre[v][i]; return pre[u][0];&#125;bool judge(int u,int v,double k)&#123; pdd res=mp(-1e10,-1e10); int lca=getLCA(u,v); for(;dep[top[u]]&gt;=dep[lca];u=pre[top[u]][0]) merge(res,SEG::query(SEG::rt,1,n,loc[top[u]],loc[u],k)); if(dep[u]&gt;=dep[lca]) merge(res,SEG::query(SEG::rt,1,n,loc[lca],loc[u],k)); for(;dep[top[v]]&gt;=dep[lca];v=pre[top[v]][0]) merge(res,SEG::query(SEG::rt,1,n,loc[top[v]],loc[v],k)); if(dep[v]&gt;=dep[lca]) merge(res,SEG::query(SEG::rt,1,n,loc[lca],loc[v],k)); return res.first+res.second+EPS&gt;=0; &#125;int main()&#123; scanf("%d",&amp;n); for(int i=0;i&lt;4;i++) for(int j=1;j&lt;=n;j++) scanf("%lf",&amp;a[j][i]); for(int i=1,u,v;i&lt;n;i++)&#123; scanf("%d%d",&amp;u,&amp;v); addEdge(u,v); &#125; dfs1(1,0); dfs2(1,1); SEG::build(SEG::rt,1,n); int m,u,v; scanf("%d",&amp;m); while(m--)&#123; scanf("%d%d",&amp;u,&amp;v); double l=0,r=100001,mid,eps=5e-4; while(l+eps&lt;r)&#123; mid=(l+r)*0.5; if(judge(u,v,mid)) l=mid; else r=mid; &#125; printf("%.5lf\n",l); &#125; return 0;&#125; ​ 例题【BZOJ4819】【SDOI2017】新生舞会​ 传送门 ​ 按照分数规划的基本思想，我们二分答案$c$，化简题目中的代价函数式，转化成一个判定问题： \frac{x_1+x_2+...+x_n}{y_1+y_2+...+y_n}\ge c\\ (x_1-c*y_1)+(x_2-c*y_2)+...+(x_n-c*y_n)\ge 0​ 其中$x_i$表示第$i$个男生和他所选女生的喜悦程度，$y_i$表示对应的不协调程度。 ​ 我们发现虽然各个括号在表达式上互不相关，但是从题意的角度来看：不能有多个男生同时选定一个女生。 ​ 但是我们的目的还是要将这$n$个括号的和最大化，并和0比较，从而判定答案$c$是否合法。 ​ 匹配，带权，最大化——我们想到了最大带权匹配模型。可以从最大费用最大流的角度来建图：源点向所有男生连$(1,0)$的边；所有男生向所有女生连边，边权为相应的括号，流量为1；所有女生向汇点连$(1,0)$的边。 ​ 那么我们跑一次费用流就可以得出一种方案，使得括号之和最大。此时和0判断即可。当然用KM会快很多。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=105,INF=1e9;const double EPS=1e-6;int n,a[N][N],b[N][N];int h[N*2],tot;struct Edge&#123;int v,f;double c;int next;&#125;e[(N*N+2*N)*2];int S,T;double dis[N*2];int pree[N*2],preu[N*2];bool inq[N*2];queue&lt;int&gt; q;inline void addEdge(int u,int v,int f,double c)&#123; e[++tot]=(Edge)&#123;v,f,c,h[u]&#125;; h[u]=tot; e[++tot]=(Edge)&#123;u,0,-c,h[v]&#125;; h[v]=tot;&#125;bool spfa()&#123; for(int i=1;i&lt;=T;i++) dis[i]=-INF,inq[i]=false; while(!q.empty()) q.pop(); q.push(S); dis[S]=0; inq[S]=true; while(!q.empty())&#123; int u=q.front(); q.pop(); inq[u]=false; for(int i=h[u],v;i;i=e[i].next) if(e[i].f&amp;&amp;dis[v=e[i].v]&lt;dis[u]+e[i].c)&#123; dis[v]=dis[u]+e[i].c; preu[v]=u; pree[v]=i; if(!inq[v])&#123; inq[v]=true; q.push(v); &#125; &#125; &#125; return dis[T]&gt;-INF;&#125;double maxcostflow()&#123; double res=0; while(spfa())&#123; int flow=INF; for(int u=T;u!=S;u=preu[u]) flow=min(flow,e[pree[u]].f); res+=dis[T]*flow; for(int u=T;u!=S;u=preu[u])&#123; e[pree[u]].f-=flow; e[pree[u]^1].f+=flow; &#125; &#125; return res;&#125;bool judge(double c)&#123; S=n*2+1; T=S+1; for(int i=1;i&lt;=T;i++) h[i]=0; tot=1; for(int i=1;i&lt;=n;i++) addEdge(S,i,1,0),addEdge(n+i,T,1,0); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) addEdge(i,n+j,1,a[i][j]-c*b[i][j]); return maxcostflow()+EPS&gt;=0;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;a[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) scanf("%d",&amp;b[i][j]); double l=0,r=10000,mid; while(l+(5e-8)&lt;r)&#123; mid=(l+r)*0.5; if(judge(mid)) l=mid; else r=mid; &#125; printf("%.6lf\n",l); return 0;&#125; ​ ​ 【BZOJ1690】【Usaco2007 Dec】奶牛的旅行​ 传送门（权限题） ​ 按照套路二分答案展开化简，得到一个用于判定$c$是否合法的式子： (a_1-c*b_1)+(a_2-c*b_2)+...+(a_{m-1}-c*b_{m-1})\ge 0​ 其中选择的路径有$m$个点，$a_i$表示第$i$个点的乐趣值，$b_i$表示第$i$个点走到第$i+1$个点的距离。由于第$m$个点和第1个点相同，价值又不重复计算，所以$a_m$不需要算进答案，式子变得十分规律好看。 ​ 那么我们把每一条边$(u,v,w)$的边权设置为$a_u-c*w$。如果图中存在正环，那么选择这一个环游览就能满足上述式子。 ​ 所以用spfa来判断每次二分判定时构建的图是否存在正环即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;const int N=1005,M=5005,INF=1e9;const double EPS=1e-6;int n,m,a[N],inp[M][3];int h[N],tot;struct Edge&#123;int v;double w;int next;&#125;e[M];inline void addEdge(int u,int v,double w)&#123;e[++tot]=(Edge)&#123;v,w,h[u]&#125;; h[u]=tot;&#125;double dis[N];bool inq[N];int qt[N];queue&lt;int&gt; q;bool spfa()&#123; while(!q.empty()) q.pop(); for(int i=1;i&lt;=n;i++) dis[i]=0,inq[i]=true,qt[i]=1,q.push(i); while(!q.empty())&#123; int u=q.front(); q.pop(); inq[u]=false; for(int i=h[u],v;i;i=e[i].next) if(dis[v=e[i].v]+EPS&gt;dis[u]+e[i].w)&#123; dis[v]=dis[u]+e[i].w; if(!inq[v])&#123; inq[v]=true; qt[v]++; if(qt[v]&gt;n) return true; q.push(v); &#125; &#125; &#125; return false;&#125;bool judge(double c)&#123; tot=0; for(int i=1;i&lt;=n;i++) h[i]=0; for(int i=1;i&lt;=m;i++) addEdge(inp[i][0],inp[i][1],-(a[inp[i][0]]-c*inp[i][2])); return spfa();&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); for(int i=1;i&lt;=m;i++) scanf("%d%d%d",inp[i],inp[i]+1,inp[i]+2); double l=0,r=1000,mid; while(l+(1e-3)&lt;r)&#123; mid=(l+r)*0.5; if(judge(mid)) l=mid; else r=mid; &#125; printf("%.2lf\n",l); return 0;&#125; 【BZOJ4898】【Apio2017】商旅​ 传送门 ​ 此题和上题非常类似。但是题目的“环”好像没有强调是简单环，只需要走一圈回到出发点即可。 ​ 首先用Floyd计算出原图上两两点之间的距离$w_{u,v}$。 ​ 再考虑购买商品的过程。题目所谓的“从A地买一个商品，拿着走向B地卖掉，利润为x”，可以简化为从A向B连一条权值为x的边。显然从A走向B总是应该选利润最大的那个商品走，所以A向B只需要连一条边。 ​ 当然，为了满足题目意思，对于原图的每一条边我们应该相应地连一条两端一样，边权为0的边，以适应空手旅行的情况。 ​ 原问题变成：在新构建的图上，找到一个环，使得代价函数最大。 ​ 惯例化简代价函数，得到判定式 (x_1-c*w_1)+(x_2-c*w_2)+...+(x_{m-1}-c*w_{m-1})\ge 0​ $x_i$表示第$i$个点走向第$i+1$个点的边权（也就是这么走的利润），$w_i$表示从$i$走到$i+1$的距离（和上一题几乎一模一样）。 ​ 所以再次用spfa判正环是否存在即可。 ​ 注意题目要求输出整数，我们用整数进行二分，可以提高效率。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;using namespace std;const int N=105,M=9905,K=1005,INF=1e9;const double EPS=1e-6;int n,m,kk,a[N],w[N][N];int sell[N][K],buy[N][K];int cnt,inp[N*N*2][3];int h[N],tot;struct Edge&#123;int v;double w;int next;&#125;e[N*N*2];inline void addEdge(int u,int v,double w)&#123;e[++tot]=(Edge)&#123;v,w,h[u]&#125;; h[u]=tot;&#125;double dis[N];bool inq[N];inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;bool dfs(int u)&#123; inq[u]=true; for(int i=h[u],v;i;i=e[i].next)&#123; v=e[i].v; if(dis[u]+e[i].w&lt;dis[v]+EPS)&#123; dis[v]=dis[u]+e[i].w; if(inq[v]) return true; else if(dfs(v)) return true; &#125; &#125; inq[u]=false; return false;&#125;bool judge(double c)&#123; tot=0; for(int i=1;i&lt;=n;i++) h[i]=0; for(int i=1;i&lt;=cnt;i++) addEdge(inp[i][0],inp[i][1],-(inp[i][2]-c*w[inp[i][0]][inp[i][1]])); for(int i=1;i&lt;=n;i++) dis[i]=0,inq[i]=false; for(int i=1;i&lt;=n;i++) if(dfs(i)) return true; return false;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;kk); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=kk;j++) scanf("%d%d",&amp;buy[i][j],&amp;sell[i][j]); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) w[i][j]=INF; for(int i=1,u,v,c;i&lt;=m;i++)&#123; scanf("%d%d%d",&amp;u,&amp;v,&amp;c); w[u][v]=min(w[u][v],c); cnt++; inp[cnt][0]=u; inp[cnt][1]=v; inp[cnt][2]=0; &#125; for(int k=1;k&lt;=n;k++) for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) w[i][j]=min(w[i][j],w[i][k]+w[k][j]); for(int u=1;u&lt;=n;u++) for(int v=1;v&lt;=n;v++) if(w[u][v]!=INF)&#123; int best=0; for(int i=1;i&lt;=kk;i++) if(buy[u][i]!=-1&amp;&amp;sell[v][i]!=-1) best=max(best,sell[v][i]-buy[u][i]); if(best)&#123; cnt++; inp[cnt][0]=u; inp[cnt][1]=v; inp[cnt][2]=best; &#125; &#125; int l=0,r=1e9,mid; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; if(judge(mid)) l=mid+1; else r=mid-1; &#125; printf("%d\n",r); return 0;&#125; 细节注意​ 题目要求的精度非常关键，不要因为二分的控制部分不精确，使得答案出现偏差。 ​ 一定要记得使用$eps$！比如在spfa判定是否要松弛的地方要加上eps。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4591】]]></title>
    <url>%2F2018%2F06%2F26%2F%5BBZOJ4591%5D%2F</url>
    <content type="text"><![CDATA[Description​ 传送门 Solution​ 记$a=\lfloor\frac n p\rfloor$，$b=n\%p$。我们尝试使用Lucas定理展开这些组合数，寻找公共部分。以下除法都作整数下取整除法： \begin{aligned} f(n,k)&=\sum_{i=0}^kC_n^i\mod p\\ &=\sum_{i=0}^{ap-1}C_{n/p}^{i/p}*C_{n\%p}^{i\%p}+\sum_{i=ap}^{n}C_{n/p}^{i/p}*C_{n\%p}^{i\%p}\\ &=(\sum_{i=0}^{a-1}C_{n/p}^i*\sum_{j=0}^{p-1}C_{n\%p}^j)+C_{n/p}^{a}*\sum_{i=0}^bC_{n\%p}^i\\ &=f(n/p,a-1)*f(n\%p,p-1)+C_{n/p}^{k/p}f(n\%p,k\%p) \end{aligned}​ ​ 由于模数较小，我们只需要预处理$f(0…p-1,0…p-1)$的值就可以直接计算了。 ​ 注意判断k&lt;0的情况，此时$f$为0。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int MOD=2333,N=2351;int c[N][N],f[N][N];inline int plus(int x,int y)&#123;return (x+y)%MOD;&#125;inline int mul(int x,int y)&#123;return 1LL*x*y%MOD;&#125;inline int C(ll n,ll m)&#123; if(n&lt;m) return 0; if(n&lt;MOD&amp;&amp;m&lt;MOD) return c[n][m]; return mul(C(n/MOD,m/MOD),C(n%MOD,m%MOD));&#125;int solve(ll n,ll k)&#123; if(k&lt;0) return 0; if(n&lt;N&amp;&amp;k&lt;N) return f[n][k]; return plus(mul(solve(n/MOD,k/MOD-1),f[n%MOD][MOD-1]),mul(C(n/MOD,k/MOD),f[n%MOD][k%MOD]));&#125;void init()&#123; c[0][0]=1; for(int i=1;i&lt;N;i++)&#123; c[i][0]=1; for(int j=1;j&lt;N;j++) c[i][j]=plus(c[i-1][j],c[i-1][j-1]); &#125; for(int i=0;i&lt;N;i++)&#123; f[i][0]=1; for(int j=1;j&lt;N;j++) f[i][j]=plus(f[i][j-1],c[i][j]); &#125;&#125;int main()&#123; init(); ll T,n,k; scanf("%lld",&amp;T); while(T--)&#123; scanf("%lld%lld",&amp;n,&amp;k); printf("%lld\n",solve(n,k)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---Lucas定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵树定理]]></title>
    <url>%2F2018%2F06%2F25%2F%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[矩阵树定理 Matrix Tree​ 矩阵树定理主要用于图的生成树计数。 ​ 看到给出图求生成树的这类问题就大概要往这方面想了。 ​ 算法会根据图构造出一个特殊的基尔霍夫矩阵$A$，接着根据矩阵树定理，用$A$计算出生成树个数。 1.无向图的生成树计数​ 对于给定的可含重边的连通无向图$G$，求其生成树的个数。求法如下： ​ 定义度数矩阵$D​$：该矩阵仅在对角线上有值，$D{i,i}​$表示$i​$号点的度数。对于图中每一条无向边$(u,v)​$，$D{u,u}​$++，$D_{v,v}​$++。 ​ 定义邻接矩阵$C$：$C{i,j}$表示$i$到$j$的边数。对于图中每一条无向边$(u,v)$，$C{u,v}$++，$C_{v,u}$++。 ​ 定义图$G$的基尔霍夫矩阵$A=D-C$。 ​ 矩阵树定理：将$A$去掉第$i$行和第$i$列（$i\in[1,n]$），将它当做一个行列式求解，则$\det(A)$就是生成树个数。 2.有向图的树形图计数​ 对于有向图，不存在“生成树”的概念，但存在“树形图”的概念。有向图中，若选定一个点作为树根，能构造出一棵“树”（包含$n-1$条边）使得根能到达任意节点，则这是一棵外向树；若能构造出一棵“树”使得任意节点能到达根，则这是一棵内向树。 ​ 定义度数矩阵$D$：该矩阵仅在对角线上有值，$D_{i,i}$表示$i$号点的度数。 对于图中每一条有向边$(u,v)$，若构造外向树则$D{v,v}$++；若构造内向树则$D{u,u}$++。 ​ 定义邻接矩阵$C$：$C{i,j}$表示$i$到$j$的边数。对于图中每一条有向边$(u,v)$，$C{u,v}$++。 ​ 定义图$G$的基尔霍夫矩阵$A=D-C$。 ​ 矩阵树定理：将$A$去掉第$i$行和第$i$列（$i\in[1,n]$），将它当做一个行列式求解，则$\det(A)$就是以$i$为根的外向/内向树形图个数。很多时候我们会发现$A$的对角线上某数为$A_{i,i}=0$，删去第$i$行和第$i$列可以干掉0。只有这样行列式才不等于0，其实也就是说只能从$i$出发有解了。 ​ 3.细节​ 求行列式的方法是：将行列式通过行列式初等变换消成上三角。此时对角线乘积即为行列式的值。 ​ 注意，矩阵树定理这一套算法会考虑如何把所有的参与点构建成生成树，所以编号不要跳跃。如果说有障碍之类的元素，千万不要在矩阵中给它留一行一列，因为这一行一列都一定是0，算法会尝试将“障碍”构建进生成树，最后只能得到无解。 一些例题BZOJ 4031​ 传送门在此 ​ 这是一道无向图生成树计数的裸题，直接上基础算法即可。 ​ 这里就要注意障碍的处理了。我们应该对非障碍格子重新标号使得它们的编号连续，保证算法正常进行。 ​ 这题的模数真的恶心，不是质数，没法用逆元。所以使用类辗转相除法来消元，每行的消元从$O(n)$变成$O(n\lg )$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;using namespace std;const int N=10,MOD=1e9;int n,m,id[N][N],idcnt,a[N*N][N*N];char map[N][N];inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;inline int plus(int x,int y)&#123;return (x+y)%MOD;&#125;inline int mul(int x,int y)&#123;return 1LL*x*y%MOD;&#125;inline bool ok(int x,int y)&#123;return 1&lt;=x&amp;&amp;x&lt;=n&amp;&amp;1&lt;=y&amp;&amp;y&lt;=m&amp;&amp;map[x][y]=='.';&#125;void addEdge(int u,int v)&#123; a[u][u]++; a[v][v]++; a[u][v]--; a[v][u]--;&#125;int solve()&#123; if(idcnt==1) return 1; int all=idcnt-1,res=1; for(int i=1;i&lt;=all;i++) for(int j=i+1;j&lt;=all;j++) while(a[j][i])&#123; int t=a[i][i]/a[j][i]; for(int k=i;k&lt;=all;k++)&#123; int q=plus(a[i][k],-mul(a[j][k],t)); a[i][k]=a[j][k]; a[j][k]=q; &#125; res=-res; &#125; for(int i=1;i&lt;=all;i++) res=mul(res,a[i][i]); return (res+MOD)%MOD;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) scanf("%s",map[i]+1); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(map[i][j]=='.') id[i][j]=++idcnt; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(ok(i,j))&#123; if(ok(i+1,j)) addEdge(id[i][j],id[i+1][j]); if(ok(i,j+1)) addEdge(id[i][j],id[i][j+1]); &#125; printf("%d\n",solve()); return 0;&#125; BZOJ 4894​ 传送门 ​ 这是一道有向图树形图计数。要求以1号点为根的外向树形图个数。 ​ 按照上述做法直接写即可。删去$A$的第1行第1列，因为1号点没有入边，若不删第一行第一列行列式值为0，无法计算。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;using namespace std;const int N=305,MOD=1e9+7;int n,a[N][N];char str[N];inline int mul(int x,int y)&#123;return 1LL*x*y%MOD;&#125;inline int plus(int x,int y)&#123;return (x+y)%MOD;&#125;inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;int ksm(int x,int y)&#123; int res=1; for(;y;x=mul(x,x),y&gt;&gt;=1) if(y&amp;1) res=mul(res,x); return res;&#125;int gaussian()&#123; int res=1,size=n-1; for(int i=1;i&lt;size;i++)&#123; if(!a[i][i])&#123; int l; for(l=i+1;l&lt;=size;l++) if(a[l][i]) break; if(l&lt;=size&amp;&amp;a[l][i])&#123; for(int j=i;j&lt;=size;j++) swap(a[l][j],a[i][j]); res=-res; &#125; else return 0; &#125; for(int j=i+1;j&lt;=size;j++)&#123; int t=mul(a[j][i],ksm(a[i][i],MOD-2)); for(int k=i;k&lt;=size;k++) a[j][k]=plus(a[j][k],-mul(a[i][k],t)); &#125; &#125; for(int i=1;i&lt;=size;i++) res=mul(res,a[i][i]); return plus(res,MOD);&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf("%s",str+1); for(int j=1;j&lt;=n;j++) if(str[j]=='1') a[j][j]++,a[i][j]--; &#125; for(int i=1;i&lt;n;i++) for(int j=1;j&lt;n;j++) a[i][j]=a[i+1][j+1]; printf("%d\n",gaussian()); return 0;&#125; BZOJ 4596​ 传送门 ​ 我开始不会做了。 ​ 我们发现如果将所有公司提供的边都加进图中，然后求生成树个数，是无法限制“每个公司至少要建一条”这个条件的。有的生成树可能只有一部分公司参与，比如说某一种生成树只含有$S$集合的公司。 ​ 如果仅加入$S$集合所含公司的边，我们发现这些答案也会被统计到。既然有重复统计，可以考虑消除吗？ ​ 于是容斥的思想就体现出来了！ ​ 我们枚举加入哪一些公司，分别求生成树个数。记参与公司集合为$S$时生成树个数为$f(S)$，记有$x$个公司参与时的生成树总方案为$Ax=\sum{S中有x个}f(S)$，则 Ans=A_n-A_{n-1}+A_{n-2}-A_{n-3}......​ 复杂度为$O(2^nn^3)$，其实是可以跑的过的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;vector&gt;#define mp make_pair#define pb push_backusing namespace std;typedef pair&lt;int,int&gt; pii;const int N=18,MOD=1e9+7;int n;int a[N][N];vector&lt;pii&gt; l[N];vector&lt;int&gt; b[N];inline bool in(int i,int j)&#123;return (i&gt;&gt;(j-1))&amp;1;&#125;inline int plus(int x,int y)&#123;return (x+y)%MOD;&#125;inline int mul(int x,int y)&#123;return 1LL*x*y%MOD;&#125;inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;void clear_mat()&#123; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) a[i][j]=0;&#125;void add_company(int id)&#123; for(int i=0,sz=l[id].size();i&lt;sz;i++)&#123; int u=l[id][i].first,v=l[id][i].second; a[u][u]++; a[v][v]++; a[u][v]--; a[v][u]--; &#125;&#125;int ksm(int x,int y)&#123; int res=1; for(;y;x=mul(x,x),y&gt;&gt;=1) if(y&amp;1) res=mul(res,x); return res;&#125;int gaussian()&#123; int s=n-1,res=1; for(int i=1;i&lt;=s;i++)&#123; if(!a[i][i])&#123; int t; for(t=i+1;t&lt;=s&amp;&amp;!a[t][i];t++); if(t&gt;s) return 0; for(int j=i;j&lt;=s;j++) swap(a[i][j],a[t][j]); res=-res; &#125; int inv=ksm(a[i][i],MOD-2); for(int j=i+1;j&lt;=s;j++)&#123; int t=mul(a[j][i],inv); for(int k=i;k&lt;=s;k++) a[j][k]=plus(a[j][k],-mul(a[i][k],t)); &#125; &#125; for(int i=1;i&lt;=s;i++) res=mul(res,a[i][i]); return res;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1,m;i&lt;n;i++)&#123; scanf("%d",&amp;m); for(int j=1,u,v;j&lt;=m;j++)&#123; scanf("%d%d",&amp;u,&amp;v); l[i].pb(mp(u,v)); &#125; &#125; int all=1&lt;&lt;(n-1); for(int i=1;i&lt;all;i++)&#123; int cnt=0; for(int j=1;j&lt;=n;j++) cnt+=in(i,j); b[cnt].pb(i); &#125; int ans=0; for(int i=n-1,r=1;i&gt;=1;i--,r=-r) for(int j=0,sz=b[i].size();j&lt;sz;j++)&#123; clear_mat(); int st=b[i][j]; for(int c=1;c&lt;n;c++) if(in(st,c)) add_company(c); ans=plus(ans,gaussian()*r); &#125; ans=plus(ans,MOD); printf("%d\n",ans); return 0;&#125; ​ 总结​ 矩阵树定理本身还是挺简单的，但愿自己不要忘得太快…… ​ 但是要灵活运用（废话）。 ​ 如果要深入透彻，我还是得研究一下矩阵树定理的证明。不过就当一个大坑先留着吧。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>矩阵树定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[辛普森积分]]></title>
    <url>%2F2018%2F06%2F24%2F%E8%BE%9B%E6%99%AE%E6%A3%AE%E7%A7%AF%E5%88%86%2F</url>
    <content type="text"><![CDATA[辛普森积分​ 这种积分法很暴力：只要求你实现出函数求值$f(x)$。 ​ 使用辛普森积分，我们可以求出函数一段区间$[l,r]$的近似积分。记$mid=\frac{l+r}2$，有： \int_l^rf(x)\;dx\approx\ simpson(l,r)=\frac{f(l)+4f(mid)+f(r)}6*(r-l)​ 其中1,4,1称作科特斯系数。 ​ 如果 simpson(l,r)\approx simpson(l,mid)+simpson(mid,r)​ 那么我们认为函数在$[l,r]$的近似积分已经足够精确，可以直接返回$simpson(l,r)$。 ​ 否则，我们需要递归计算$[l,mid]$和$[mid,r]$的积分，相加并返回。 ​ 伪代码如下： 12345678910double simpson(double l,double r)&#123; double mid=(l+r)*0.5; return (f(l)+4*f(mid)+f(r))*(r-l)/6;&#125;double solve(double l,double r)&#123; double mid=(l+r)*0.5,midl=(l+mid)*0.5,midr=(mid+r)*0.5; if(fabs(simpson(l,r)-simpson(l,mid)+simpson(mid,r))&lt;EPS) return simpson(l,r); return solve(l,mid)+solve(mid+1,r);&#125; ​ 整体算法的耗时，一在于$f(x)$的求值，应实现得尽量够快；二在于$EPS$的设置，这决定了程序递归的深度，因为$EPS$是程序判断当前计算精度是否足够高的决策标准。$EPS$越小，精度越大，但耗时也相应越高。 ​ 总体的时间复杂度是非常玄学。辛普森积分在应用到某一些十分平滑的函数上时效率一般非常高，可是不排除有丧心病狂出题人专门卡哦。]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>辛普森积分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ1502】]]></title>
    <url>%2F2018%2F06%2F24%2F%5BBZOJ1502%5D%2F</url>
    <content type="text"><![CDATA[Description​ 传送门 Solution​ 显然的是，每一个圆的影子，就是从树上的圆按光线方向平移至地面的圆。至于两个圆之间的连接部分，则是每两个在树上相邻的圆的，对应的影子圆的，公切线围起来的部分，如下图所示 ​ 所以我们现在要求每两个在原树上相邻的圆的影子圆构成的图形的并。只看$x$轴上半部分，可以把它想象成一个函数，求单点值是$O(n)$的，我们不妨用辛普森积分来解决…… ​ 相邻圆的公切线和x轴的夹角是可以求出来的，然后就能解出公切线的解析式，以及有效范围。注意这些东西要预处理！千万不要放在求值函数里面。$EPS$大约设置到$10^{-7}$才不会出错，效率也相对比较高。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;const int N=505;const double EPS=1e-7,INF=1e10,PI=3.14159265358979323846;int n,sum;double alpha,h[N],p[N],r[N];double k[N],b[N],lx[N],rx[N];bool exist[N];inline double max(double x,double y)&#123;return x&gt;y?x:y;&#125;inline double min(double x,double y)&#123;return x&lt;y?x:y;&#125;inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;inline bool in(int a,int b)&#123; if(r[a]&gt;r[b]) swap(a,b); return p[a]+r[a]-EPS&lt;=p[b]+r[b]&amp;&amp;p[a]-r[a]+EPS&gt;=p[b]-r[b];&#125;double calc(int a,int b,double &amp;k,double &amp;bb,double &amp;xl,double &amp;xr)&#123; if(p[a]&gt;p[b]) swap(a,b); double beta=asin((r[b]-r[a])/(p[b]-p[a])); k=tan(beta); double tx; if(r[a]&gt;=r[b])&#123; beta=-beta; tx=p[b]+r[b]/sin(beta); bb=-k*tx; xr=tx-(cos(beta)*(r[b]/tan(beta))); xl=tx-(cos(beta)*(r[a]/tan(beta))); &#125; else&#123; tx=p[a]-r[a]/sin(beta); bb=-k*tx; xl=tx+(cos(beta)*(r[a]/tan(beta))); xr=tx+(cos(beta)*(r[b]/tan(beta))); &#125;&#125;double f(double x)&#123; double res=0; for(int i=1;i&lt;=n;i++) if(fabs(x-p[i])&lt;=r[i]) res=max(res,sqrt(r[i]*r[i]-fabs(x-p[i])*fabs(x-p[i]))); for(int i=1;i&lt;n;i++) if(exist[i]) if(lx[i]&lt;=x+EPS&amp;&amp;x-EPS&lt;=rx[i]) res=max(res,k[i]*x+b[i]); return res;&#125;double simpson(double l,double r)&#123; double mid=(l+r)*0.5; return (f(l)+4*f(mid)+f(r))*(r-l)/6;&#125;double solve(double l,double r)&#123; double mid=(l+r)/2,lmid=(l+mid)/2,rmid=(mid+r)/2; double val=simpson(l,r); if(fabs(val-(simpson(l,mid)+simpson(mid,r)))&lt;EPS) return val; return solve(l,mid)+solve(mid,r);&#125;int main()&#123; scanf("%d%lf",&amp;n,&amp;alpha); n++; for(int i=1;i&lt;=n;i++)&#123; scanf("%lf",h+i); h[i]+=h[i-1]; p[i]=h[i]/tan(alpha); &#125; for(int i=1;i&lt;n;i++) scanf("%lf",r+i); double xl=INF,xr=-INF; for(int i=1;i&lt;=n;i++)&#123; xl=min(xl,p[i]-r[i]); xr=max(xr,p[i]+r[i]); &#125; for(int i=1;i&lt;n;i++)&#123; exist[i]=!in(i,i+1); if(exist[i]) calc(i,i+1,k[i],b[i],lx[i],rx[i]); &#125; printf("%.2lf\n",solve(xl,xr)*2); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>辛普森积分</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高斯消元]]></title>
    <url>%2F2018%2F06%2F24%2F%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[前言 虽然道理我都懂，但是我总是写混……隔三差五地打高斯消元，与当时记不清Tarjan的各个分支的感觉是一样迷茫。 定义和概念 矩阵：一个$n*n$的矩阵。 扩展矩阵：一个$n*(n+1)$的矩阵。矩阵的最右端多了一列系数，常用于表示解方程组时的常数项。 主元：用于逐步消元的未知数$x$，一般有$n$个。枚举每一个主元时，为了保证精度，我们从所有方程中挑选该主元系数绝对值最大的一条方程作为当前方程，用来消去其他方程中的该主元。如果是取模意义下，挑选主元系数非0的一条方程即可。 自由元：如果枚举到某个未知数时，余下的所有方程中该未知数的系数都为0，那么此变量是一个自由元。自由元的存在，说明有一些方程是线性相关的（无用的）。自由元的个数，等于消元完成后全0方程的条数。只要枚举自由元的取值，就能确定其他所有未知数的取值。 线性方程组求解 我们使用扩展矩阵表示线性方程组。 我们的目的是使用高斯消元将矩阵消成上三角矩阵。此时，最后一个未知数可由最后一条方程直接得出，然后一直回代到倒数第二条方程，解出倒数第二个未知数……一直回代即可解出所有未知数。 伪代码： 123456789101112void gaussian()&#123; for(int i=1;i&lt;=n;i++)&#123; int best=满足a[best][i]在第i列的绝对值最大（实数）或满足a[best][i]!=0（模意义下）; 交换a[i],a[best]; for(int j=i+1;j&lt;=n;j++) 用第i行消去第j行的a[j][i]; &#125; for(int i=n;i&gt;=1;i--)&#123; for(int j=i+1;j&lt;=n;j++) a[i][n+1]-=a[i][j]*x[j]; x[i]=a[i][n+1]; &#125;&#125; 无解仅可能在方程条数大于未知数个数时出现。消元完成时，矩阵下方会有一部分系数全0方程，如果此时这些方程的常数项不为0，则整体无解。否则说明出现了线性相关方程，方程依然不相互冲突。 ​ 咕咕咕]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4869】]]></title>
    <url>%2F2018%2F06%2F23%2F%5BBZOJ4869%5D%2F</url>
    <content type="text"><![CDATA[Description BZOJ传送门 Solution​ 这题涉及到指数嵌套堆叠，可能可以用欧拉函数解决。 ​ 试想一个数$a_i$经过$k$次操作后会变成什么？ k个c\;\; \begin{cases} {c^{c^{a_i}}} \end{cases}​ 我们有扩展欧拉定理，$a,x,p$为任意正整数： a^x \equiv \begin{cases} a^{x\;mod\;\varphi(p)+\varphi(p)}&x\ge\varphi(p)\\ a^x&x]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---欧拉函数</tag>
        <tag>数据结构---线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ2813】]]></title>
    <url>%2F2018%2F06%2F23%2F%5BBZOJ2813%5D%2F</url>
    <content type="text"><![CDATA[Description​ Fibonacci数列是这样一个数列： ​ F1 = 1， F2 = 1， F3 = 2 . . . ​ Fi = Fi-1 + Fi-2 (当 i &gt;= 3) ​ pty忽然对这个古老的数列产生了浓厚的兴趣，他想知道：对于某一个Fibonacci数Fi， ​ 有多少个Fj能够整除Fi (i可以等于j)，他还想知道所有j的平方之和是多少。 Input​ 第一行一个整数Q,表示Q个询问。 ​ 第二行四个整数:Q1, A, B, C ​ 第i个询问Qi = (Qi-1 * A + B) mod C + 1(当i &gt;= 2) Output​ Ai代表第i个询问有多少个Fj能够整除FQi。 ​ Bi代表第i个询问所有j的平方之和。 ​ 输出包括两行： ​ 第一行是所有的Ai之和。 ​ 第二行是所有的Bi之和。 ​ 由于答案过大，只需要输出除以1000000007得到的余数即可。 HINT​ 对于100%的数据保证：$Q \le 3*10^6，C \le10^7，A \le10^7，B \le10^7，1 \le Q1\le C $ Solution​ 首先还是要找规律。发现$f_j\mid f_i\Leftrightarrow j\mid i$。 ​ 对于任意一个质数$p$，我们在模$f_p$的意义下观察一些斐波那契数列： \begin{bmatrix} f_1&f_2&f_3&...&f_{p-1}&0&f_{p-1}&f_{p-1}&2f_{p-1}&...&f_{p-1}f_{p-1}&0&f^2_{p-1}\\ f_1&f_2&f_3&...&f_{p-1}&0&f_{p-1}f_1&f_{p-1}f_2&f_{p-1}f_3&...&f_{p-1}f_{p-1}&0&f_{p-1}^2f_1... \end{bmatrix} 斐波那契数列会每$p$项分成一段，其中第$i$段是$f{p-1}^{i-1}f{1..p}$。 ​ 由于$f{p-1}$与$f_p$互质，因此$f{p-1}^{i-1}$都与$f_p$互质。既然第一段只能在第$p$项，也就是该段最后一项取0，那么之后的每一段都只能在最后一项取0. ​ 也就是说$f_p$整除哪一些$f_i$呢？恰好是那些$p\mid i$的$f_i$。 ​ 那么对于任意整数$j$，$fj$整除哪一些$f_i$呢？把$j$质因数分解$j=p_1^{q_1}p_2^{q_2}…p_m^{q_m}$，可知$f{pk}\mid f_j$（$k\in[1,m]$）。当且仅当$f{p_k}\mid f_i$（$k\in[1,m]$）时，有$f_j\mid f_i$，而此时$p_k\mid i$（$k\in[1,m]$）。 ​ 故证毕：对于任意正整数$i$和$j$，有$f_j\mid f_i\Leftrightarrow j\mid i$。 ​ 所以本题相当于询问$q$的因数个数、因数平方和，是线性筛的基本应用。因数平方和的表达式是 \sigma(x)^2=\prod_{i=1}^m(\sum_{j=0}^{q_i}p_i^{2j})​ 记录每个数的最小质因子的幂、除尽最小质因子的数$nop$就可以计算了。我第一次写的代码使用了快速幂计算$i\%p==0$时的累加，然而不必要，对$\sigma^2(i)$乘上$p^2$就可以把最小质因子处的$\sum$整体偏移，括号里需要加上的1，対整体加上$\sigma^2(nop[i])$即可。 ​ 注意回答询问时，不可直接输出上述统计的东西。$f_2=1$非常特殊，当询问$q$为偶数时，因为$2\mid q$，所以2会被统计到，且2本来就需要统计，因为$f_2\mid f_q$是合法的的。但是当询问$q$为奇数时，$2\nmid q$，所以2未被统计，但从原题意义上看，依然有$f_2\mid f_q$，2应该被统计。所以$q$是奇数时，第一问要加上1，第二问要加上4（$2^2=4$）。 ​ 我脑残，都加上了1，居然还有50……说明那些数据模数神奇，询问都是偶数。 ​ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=10000001,MOD=1e9+7;bool vis[N];int p[N],pcnt,sigma0[N],minpq[N];ll nop[N],sigma2[N];ll ans1,ans2;void sieve()&#123; sigma0[1]=1; sigma2[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!vis[i])&#123; p[++pcnt]=i; sigma0[i]=2; sigma2[i]=(1LL*i*i+1)%MOD; minpq[i]=1; nop[i]=1; &#125; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;N;j++)&#123; int x=i*p[j]; vis[x]=true; if(i%p[j]==0)&#123; minpq[x]=minpq[i]+1; nop[x]=nop[i]; sigma0[x]=sigma0[i]/(minpq[i]+1)*(minpq[x]+1); sigma2[x]=(sigma2[i]*(1LL*p[j]*p[j]%MOD)%MOD+sigma2[nop[i]])%MOD; break; &#125; sigma0[x]=sigma0[i]*sigma0[p[j]]; sigma2[x]=sigma2[i]*sigma2[p[j]]%MOD; minpq[x]=1; nop[x]=i; &#125; &#125; &#125;int main()&#123; sieve(); int n,q,qlast=0,a,b,c; scanf("%d%d%d%d%d",&amp;n,&amp;q,&amp;a,&amp;b,&amp;c); for(int i=1;i&lt;=n;i++)&#123; if(i&gt;1) q=(1LL*qlast*a+b)%c+1; qlast=q; ans1+=sigma0[q]+(q&amp;1); (ans2+=sigma2[q]+4*(q&amp;1))%=MOD; &#125; printf("%lld\n%lld\n",ans1,ans2); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>斐波那契数列</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4004】]]></title>
    <url>%2F2018%2F06%2F22%2F%5BBZOJ4004%5D%2F</url>
    <content type="text"><![CDATA[Description​ 脸哥最近在玩一款神奇的游戏，这个游戏里有 n 件装备，每件装备有 m 个属性，用向量zi(aj ,…..,am) 表示 (1 &lt;= i &lt;= n; 1 &lt;= j &lt;= m)，每个装备需要花费 ci，现在脸哥想买一些装备，但是脸哥很穷，所以总是盘算着怎样才能花尽量少的钱买尽量多的装备 对于脸哥来说，如果一件装备的属性能用购买的其他装备组合出（也就是说脸哥可以利用手上的这些装备组合出这件装备的效果），那么这件装备就没有买的必要了。严格的定义是，如果脸哥买了 zi1,…..zip这 p 件装备，那么对于任意待决定的 zh，不存在 b1,….,bp 使得 b1zi1 + … + bpzip = zh（b 是实数），那么脸哥就会买 zh，否则 zh 对脸哥就是无用的了，自然不必购买 举个例子,z1 =(1; 2; 3);z2 =(3; 4; 5);zh =(2; 3; 4)，b1 =1/2，b2 =1/2，就有 b1z1 + b2z2 = zh，那么如果脸哥买了 z1 和 z2 就不会再买 zh 了 脸哥想要在买下最多数量的装备的情况下花最少的钱，你能帮他算一下吗？ Solution​ 还是有关那个带权线性基的问题，但是我还未膜拜拟阵证明，所以就先写着吧。 ​ 我们发现，这个新物品购买与否的判定机制，是看用已购买的物品能否线性表示出新物品。这不就是线性基的那一套插入、判定能否线性表示的做法吗？ ​ 再考虑到那个贪心的方法——我们要使选中的物品价值尽可能小，那么依照套路我们按物品价值从小到大依次考虑，尝试加入线性基：能，那就买；中途消成0，就说明它可以被线性表示，不买。 ​ 这题的实现不再能直接套用异或线性基的写法了，而是要用实数来模拟线性基。记线性基的向量为$b_1,b_2,…,b_m$，其实每一个$b_i$类比于异或线性基中的每一个数，只不过异或线性基还把向量状压了。线性基用矩阵表示就长这样： \begin{bmatrix} b_{m,1}&b_{m,2} &b_{m,3} &... &b_{m,m}\\ ...&...&...&...&...\\ b_{3,1}&b_{3,2} &b_{3,3} &... &b_{3,m}\\ b_{2,1}&b_{2,2} &b_{2,3} &... &b_{2,m}\\ b_{1,1}&b_{1,2} &b_{1,3} &... &b_{1,m}\\ \end{bmatrix} 尝试加入一个向量$a=[a1,a_2,…,a_m]$时，我们从$b_m$开始，一行一行地循环到$b_1$。考虑$b_i$时，如果$a_i=0$，continue；如果$b{i,i}=0$，我们把整个$bi$赋值为$a$；如果$b{i,i}\ne0$，我们用$bi$消去$a{i,i}$，继续往下走。类比异或线性基的插入方法，就能很好地理解普通线性基的插入方法。 ​ 由于BZOJ新加了三组毒瘤数据，因此实数要用long double保证精度。 ​ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;typedef long double ld;const int N=505;const ld EPS=1e-8;int n,m;ld lb[N][N];struct Equip&#123; ld a[N]; int cost;&#125;s[N];int use,sum;inline bool cmp(const Equip &amp;x,const Equip &amp;y)&#123;return x.cost&lt;y.cost;&#125;int main()&#123; scanf("%d%d",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++) for(int j=1,x;j&lt;=m;j++) scanf("%llf",&amp;s[i].a[j]); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;s[i].cost); sort(s+1,s+1+n,cmp); for(int x=1;x&lt;=n;x++) for(int i=1;i&lt;=m;i++) if(fabs(s[x].a[i])&gt;=EPS)&#123; if(fabs(lb[i][i])&lt;EPS)&#123; for(int j=i;j&lt;=m;j++) lb[i][j]=s[x].a[j]; use++; sum+=s[x].cost; break; &#125; for(int j=m;j&gt;=i;j--) s[x].a[j]-=lb[i][j]*(s[x].a[i]/lb[i][i]); &#125; printf("%d %d\n",use,sum); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>线性基</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3105】]]></title>
    <url>%2F2018%2F06%2F22%2F%5BBZOJ3105%5D%2F</url>
    <content type="text"><![CDATA[Description 传统的Nim游戏是这样的：有一些火柴堆，每堆都有若干根火柴（不同堆的火柴数量可以不同）。两个游戏者轮流操作，每次可以选一个火柴堆拿走若干根火柴。可以只拿一根，也可以拿走整堆火柴，但不能同时从超过一堆火柴中拿。拿走最后一根火柴的游戏者胜利。 ​ 本题的游戏稍微有些不同：在第一个回合中，第一个游戏者可以直接拿走若干个整堆的火柴。可以一堆都不拿，但不可以全部拿走。第二回合也一样，第二个游戏者也有这样一次机会。从第三个回合（又轮到第一个游戏者）开始，规则和Nim游戏一样。 ​ 如果你先拿，怎样才能保证获胜？如果可以获胜的话，还要让第一回合拿的火柴总数尽量小。 Input​ 第一行为整数$k（k\le1000)$。即火柴堆数。第二行包含$k$个不超过$10^9$的正整数，即各堆的火柴个数。 Output​ 输出第一回合拿的火柴数目的最小值。如果不能保证取胜，输出-1。 Sample Input​ 6 ​ 5 5 6 6 5 5 Sample Output​ 21 Solution​ Nim游戏先手必胜的条件是所有每一堆的数量异或和不为0。那么我们现在所要做的，是保留一个集合$S$，使得这个集合的每一个子集异或和都不为0。这样，不论对手从这个集合中删去哪些子集，剩余的元素异或和都不为0。同时，我们要使得删去的元素尽可能小，即选择保留的元素尽可能大。所以，我们的目的其实是构造一组权值最大的线性基。 ​ 我们按照每一堆的火柴数$a_i$从大到小来贪心，尝试将它加入一个线性基中。如果成功加入，则视之为$S$中的元素；否则，则视为被舍弃的元素，统计入答案中。 ​ 这样，我们就可以构造出一组权值最大的线性基。 ​ 至于为什么贪心是正确的，不会出现舍弃权值较大的元素来让某些权值较小的元素顺利加入线性基这种决策，可能要用到拟阵证明，这个坑慢慢补吧。但是貌似如此的线性基的带权问题，大概都可以套用贪心的方法，应该是得益于拟阵的相似证明。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=105;int n,a[N]; long long ans;namespace LB&#123; const int B=30; int a[B]; bool insert(int x)&#123; for(int i=B-1;i&gt;=0;i--) if(x&amp;(1&lt;&lt;i))&#123; if(a[i]) x^=a[i]; else&#123;a[i]=x;break;&#125; &#125; return x; &#125;&#125;int main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",a+i); sort(a+1,a+1+n); for(int i=n;i&gt;=1;i--) if(!LB::insert(a[i])) ans+=a[i]; printf("%lld\n",ans); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>博弈论</tag>
        <tag>线性基</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3518】]]></title>
    <url>%2F2018%2F06%2F21%2F%5BBZOJ3518%5D%2F</url>
    <content type="text"><![CDATA[Description​ 平面上摆放着一个$n m$的点阵（下图所示是一个34的点阵）。Curimit想知道有多少三点组(a，b，c)满足以a，b，c三点共线。这里a，b，c是不同的3个点，其顺序无关紧要。(即(a，b，c)和(b，c，a)被认为是相同的）。由于答案很大，故你只需要输出答案对$10^9+7$的余数就可以了。 ​ $1\le n,m\le50000$ ​ Solution​ 首先是横着的和竖着的点组，总共有$m{n \choose 3}+n{m\choose 3}$种方案。 ​ 接下来是斜着的点组，怎么统计？ ​ 我想复杂了，想枚举A点和B点，然后作一条射线，统计射线上有多少个点…… ​ 更加简洁的做法是：枚举A点和C点，然后看两点的连线经过多少个点。现在只考虑A在C的左上角的情况，A在C右上角的情况同理，只需要对答案乘2。 ​ 我们枚举$C$相对$A$偏移值$x$和$y$，若$A(i,j)$，则$C(i+x,j+y)$。这样的$AC$组合会出现$(n-x)(m-y)$次。我们发现，$AC$连线经过的点数恰好是$\gcd(x,y)-1$，因此左上往右下斜的答案就是： \begin{aligned} S&=\sum_{x=1}^{n-1}\sum_{y=1}^{m-1}(n-x)(m-y)(\gcd(x,y)-1)\\ S+\sum_{x=1}^{n-1}\sum_{y=1}^{m-1}(n-x)(m-y)&=\sum_{x=1}^{n-1}\sum_{y=1}^{m-1}(n-x)(m-y)\gcd(x,y)\\ \end{aligned}​ 左边的和式可以直接算，我们关心右边：这里用到了欧拉函数的性质$\sum_{d\mid n}\varphi(d)=n$： \begin{aligned} 右边&=\sum_{x=1}^{n-1}\sum_{y=1}^{m-1}(n-x)(m-y)\sum_{d|\gcd(x,y)}\varphi(d)\\ &=\sum_{d=1}^{\min(n-1,m-1)}\varphi(d)\sum_{i=1}^{\lfloor\frac{n-1}d\rfloor}(n-i*d)\sum_{j=1}^{\lfloor\frac{m-1}d\rfloor}(m-j*d) \end{aligned}​ 枚举$d$，用等差数列求和$O(1)$算出后面的部分，于是这一段部分也就计算完了！那么总答案就是： Ans=m{n \choose 3}+n{m\choose 3}+SCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;using namespace std;const int N=50005,MOD=1e9+7,INV2=500000004;int n,m;bool vis[N];int p[N],pcnt,phi[N];int fact[N],invfact[N];inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;inline int ksm(int x,int y)&#123; int res=1; for(;y;x=1LL*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%MOD; return res;&#125;void sieve()&#123; phi[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!vis[i])&#123; p[++pcnt]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;N;j++)&#123; int x=i*p[j]; vis[x]=true; if(i%p[j]==0)&#123; phi[x]=phi[i]*p[j]; break; &#125; phi[x]=phi[i]*(p[j]-1); &#125; &#125;&#125;inline int C(int n,int m)&#123; if(m&lt;0||m&gt;n) return 0; return 1LL*fact[n]*invfact[m]%MOD*invfact[n-m]%MOD;&#125;inline int calc(int a,int d)&#123; return (1LL*((a-1)/d)*a%MOD-1LL*INV2*d%MOD*((a-1)/d+1)%MOD*((a-1)/d)%MOD)%MOD;&#125;int main()&#123; sieve(); scanf("%d%d",&amp;n,&amp;m); int maxs=max(n,m),mins=min(n-1,m-1); fact[0]=1; for(int i=1;i&lt;=maxs;i++) fact[i]=1LL*fact[i-1]*i%MOD; invfact[maxs]=ksm(fact[maxs],MOD-2); for(int i=maxs-1;i&gt;=0;i--) invfact[i]=1LL*invfact[i+1]*(i+1)%MOD; int ans=0; for(int d=1;d&lt;=mins;d++) (ans+=1LL*phi[d]*calc(n,d)%MOD*calc(m,d)%MOD)%=MOD; for(int i=1;i&lt;n;i++) (ans-=1LL*(n-i)*(1LL*m*(m-1)%MOD*INV2%MOD)%MOD)%=MOD; ans=2LL*ans%MOD; (ans+=(1LL*n*C(m,3)%MOD+1LL*m*C(n,3)%MOD)%MOD)%MOD; printf("%d\n",ans&lt;0?ans+MOD:ans); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4059】]]></title>
    <url>%2F2018%2F06%2F21%2F%5BBZOJ4059%5D%2F</url>
    <content type="text"><![CDATA[​ Description 题目链接 Solution 记序列为$a$，计算出与$a_i$相等的前一个元素的位置$pre_i$，以及后一个元素的位置$nex_i$，显然，对于那些左端点处于$(pre_i,i]$以及右端点处于$[i,nex_i)$的区间都可以认为是合法的。 ​ 那么我们可以将每个区间$[l,r]$抽象成一个二维平面的点$(l,r)$，每一个元素可以使得一部分区间合法，可以抽象为一个横坐标范围为$[pre_i+1,i]$且纵坐标范围为$[i,nex_i-1]$的矩形。对所有矩形进行求交，如果矩形覆盖了所有的合法点（也就是一个上三角形），那么序列就是合法的，否则不合法。 ​ 但是这样跑的非常慢！在BZOJ上AC的扫描线代码在我们OJ上是完全被卡常的…..有没有更加简便的做法？ ​ 考虑$check(l,r)$表示所有左右端点处于$[l,r]$的区间是否合法。则答案就是$check(1,n)$。 ​ 枚举$i\in[l,r]$，一旦找到一个$i$使得$pre_ir$，就停下。如果找不到，显然序列$[l,r]$本身就不合法，直接返回$false$。此时我们直接可以得知，左端点处于$[l,i]$且右端点处于$[i,r]$的区间全部是合法的！还剩下左右端点都处于$[l,i)$或$(i,r]$的区间未检查，返回$check(l,i-1)\&amp;\&amp;check(i+1,r)$即可。 ​ 但是枚举这一步的复杂度我们没有保证，最坏总复杂度会达到$O(n^2)$。我们需要一个思想：从两头向中间同时推进枚举，直到遇到第一个所需点为止。 ​ 时间复杂度是$T(n)=\max{T(i)+T(n-i)+\min(n,n-i)}=O(n\lg n)$。 ​ 为什么呢？感性地讲，如果把递归步骤倒过来看，就是一个启发式合并！关键就在$min(n,n-i)$这里，每一层递归贡献的复杂度恰好是关键点与边缘的距离，而我们每次都找最靠近边缘的一个关键点，相当于启发式里面的对较小的部分进行操作的思想一样。 ​ 然后就做完了，这种两端向中间枚举的思想很值得学习和思考。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;const int N=200005;int n,a[N];int dizlis[N],dizcnt;int pre[N],nex[N],mark[N];void Diz()&#123; dizcnt=n; memcpy(dizlis,a,(dizcnt+1)*sizeof(int)); sort(dizlis+1,dizlis+1+dizcnt); dizcnt=unique(dizlis+1,dizlis+1+dizcnt)-dizlis-1; for(int i=1;i&lt;=n;i++) a[i]=lower_bound(dizlis+1,dizlis+1+dizcnt,a[i])-dizlis;&#125;bool check(int l,int r)&#123; if(l&gt;r) return true; int p1=l,p2=r; while(p1&lt;=p2)&#123; if(pre[p1]&lt;l&amp;&amp;nex[p1]&gt;r) return check(l,p1-1)&amp;&amp;check(p1+1,r); p1++; if(pre[p2]&lt;l&amp;&amp;nex[p2]&gt;r) return check(l,p2-1)&amp;&amp;check(p2+1,r); p2--; &#125; return false;&#125;int Main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); Diz(); for(int i=1;i&lt;=dizcnt;i++) mark[i]=0; for(int i=1;i&lt;=n;i++) pre[i]=mark[a[i]],mark[a[i]]=i; for(int i=1;i&lt;=dizcnt;i++) mark[i]=n+1; for(int i=n;i&gt;=1;i--) nex[i]=mark[a[i]],mark[a[i]]=i; puts(check(1,n)?"non-boring":"boring"); return 0;&#125;int main()&#123; int T; scanf("%d",&amp;T); while(T--) Main(); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>扫描线</tag>
        <tag>分治</tag>
        <tag>启发式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4804】]]></title>
    <url>%2F2018%2F06%2F21%2F%5BBZOJ4804%5D%2F</url>
    <content type="text"><![CDATA[Description​ 给定数字$n$（$n\le 10^7$)，求： \sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j))​ 多组数据输入，数据组数$T\le5000$。 Solution 简单的一题，直接推导： \begin{aligned} \sum_{i=1}^n\sum_{j=1}^n\varphi(\gcd(i,j))&=\sum_{d=1}^n\varphi(d)\sum_{i=1}^{\lfloor \frac n d\rfloor}\sum_{j=1}^{\lfloor \frac n d\rfloor}[\gcd(i,j)==1]\\ &=\sum_{d=1}^n\varphi(d)(2*\sum_{i=1}^{\lfloor \frac n d\rfloor}\varphi(i)-1) \end{aligned} 发现后面一个括号带下取整，直接求出$\varphi$的前缀和，数论根号分块即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=10000001;bool vis[N];int p[N],pcnt;ll phi[N];void sieve()&#123; phi[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!vis[i])&#123; p[++pcnt]=i; phi[i]=i-1; &#125; for(int j=1;j&lt;=pcnt&amp;&amp;i*p[j]&lt;N;j++)&#123; int x=i*p[j]; vis[x]=true; if(i%p[j]==0)&#123; phi[x]=phi[i]*p[j]; break; &#125; phi[x]=phi[i]*(p[j]-1); &#125; &#125; for(int i=2;i&lt;N;i++) phi[i]+=phi[i-1];&#125;int main()&#123; sieve(); int T,n; ll ans; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;n); ans=0; for(int i=1,j;i&lt;=n;i=j+1)&#123; j=n/(n/i); ans+=(2LL*phi[n/i]-1)*(phi[j]-phi[i-1]); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3844】]]></title>
    <url>%2F2018%2F06%2F21%2F%5BBZOJ3844%5D%2F</url>
    <content type="text"><![CDATA[Description​ 一句话题意，给定$p$作为模数： ​ $p\le 10^7$，数据组数$T\le1000$。 Solution​ 看到就弃疗了，再见…… ​ 将模数$p$拆分成$p=q2^k$，其中$q$为一个奇数。那么： \begin{aligned} 2^{2^{2...}}\;\text{mod}\;p&=2^k(2^{2^{2..}-k}\;\text{mod}\;q)\\ &=2^k(2^{((2^{2..}-k)\;\text{mod}\;\varphi(q)+\varphi(q))\;\text{mod}\;\varphi(q)}\;\text{mod}\;q) \end{aligned}​ 考虑递归$(2^{2…}-k)$的$2^{2…}$，只不过每次递归的时候，模数由$p$变成$\varphi(q)$。当模数$p$变成1的时候，我们就遇到了边界——不管里面式子如何，模1都是0，直接返回0即可。考虑递归的层数：除了第一次调用的$p$可能是奇数之外，往下递归的$p$一定是偶数（$\varphi(x),x\ge3$都是偶数），$\varphi(q)$相对于$p$至少会减少一倍。直到$p=1$时，层数不会太多，dalao说是$O(log^2p$)。 ​ 所以就直接递归计算了。实现上，如果先用线性筛筛出所有的$\varphi$，反而太慢。每次调用$\varphi$时直接$O(\sqrt n)​$计算反而更加快。这两种方法，是稳定300ms和6ms的差距…… Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;using namespace std;const int S=10000001;inline int ksm(int x,int y,int MOD)&#123; int res=1; for(;y;x=1LL*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%MOD; return res;&#125;int getPhi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;i++)&#123; if(!(x%i)) res-=res/i; while(!(x%i)) x/=i; &#125; if(x!=1) res-=res/x; return res;&#125;int calc(int p)&#123; if(p==1) return 0; int k=0,q=p; while(!(q&amp;1)) k++,q&gt;&gt;=1; int phiq=getPhi(q); int mi=(calc(phiq)-k)%phiq; if(mi&lt;0) mi+=phiq; return 1LL*ksm(2,mi,q)*ksm(2,k,p)%p;&#125;int main()&#123; int T,p; scanf("%d",&amp;T); while(T--)&#123; scanf("%d",&amp;p); printf("%d\n",calc(p)); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[counting]]></title>
    <url>%2F2018%2F04%2F22%2Fcounting%2F</url>
    <content type="text"><![CDATA[Description​ 数学老师走啦，英语老师来上课啦​ 他的性格与众不同，又因为大家都是理科班的学生​ 他希望大家在数字母的过程中领悟英语的快乐​ 他用m种字母进行排列组合，​ 得到了所有不同的，长度为n的字符串​ （不需要所有字母都出现在字符串中）​ 对于每个字符串s​ 定义C(s)为s中出现次数最多的字母的出现次数​ 那么问题来了​ 所有的这些字符集大小为m，长度为n的字符串中​ C(s)=k的有多少个呢 Input​ 一行三个整数n,m,k，分别表示长度，字符集和要求的C(s) Output​ 输出一行表示结果​ 答案对998244353取模 Sample Input​ 3 2 2 Sample Output​ 6 HINT​ 数据保证k≤n​ 对于10%的数据，1≤n,m≤8​ 对于30%的数据，1≤n,m≤200​ 对于50%的数据，1≤n,m≤1000​ 对于100%的数据，1≤n,m≤50000 ​ 样例解释： ​ 假设样例中的两个字母为a,b​ 则满足条件的有aab,aba,abb,baa,bab,bba六个 Solution​ 首先把最直观的DP方程列出来。 ​ 记$f[i][j][k]$为当前考虑到第$i$个字母，已经使用了串中的$j$个位置，出现最多的字母次数不超过$k$的方案数。答案就是$f[m][n][k]-f[m][n][k-1]$。 ​ 转移方程显然是枚举当前字母使用多少次： f[i][j][k]=\sum_{x=0}^k {j\choose x}f[i-1][j-x][k]​ 然后可以发现$k$十分的冗余，并没有参与转移。也就是说$k$仅仅作用于循环范围控制上。 ​ 我们尝试把最后一维省掉：$f[i][j]$。$k$仍然发挥作用，也就是现在的$f[i][j]$对应着原来的$f[i][j][k]$。 ​ 现在看看方程： \begin{aligned} f[i][j]&=\sum_{x=0}^k{j\choose x}f[i-1][j-x]\\ &=\sum_{x=0}^k\frac{j!}{x!(j-x)!}f[i-1][j-x]\\ \frac{f[i][j]}{j!}&=\sum_{x=0}^k\;x!\;\frac{f[i-1][j-x]}{(j-x)!} \end{aligned}​ 后面显然是一个卷积的形式，并且等号左边的形式和卷积右半边的形式一样。所以可以把每个$f[i]$看做一个多项式 f[i]=\frac{f[i][0]}{0!}+\frac{f[i][1]}{1!}x+\frac{f[i][2]}{2!}x^2+...+\frac{f[i][n]}{n!}x^n​ 转移就是这个多项式和 T(x)=\frac1{0!}+\frac1{1!}x+\frac1{2!}x^2...+\frac1{k!}x^k​ 的卷积。即$f[n]=f[0]*T^{n}(x)$ ​ 而$T(x)$是独立的存在不受其他东西影响，所以将$T(x)$用快速幂自卷积一下，再用$f[0]$卷积一下就好了。根据定义，$f[0]=1$，所以相当于直接求$T(x)$的$n$次方。答案别忘了乘上$n$的阶乘。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N=50005,MOD=998244353,G=3,B17=131100;int fact[N],iact[N];inline void swap(int &amp;x,int &amp;y)&#123;x^=y^=x^=y;&#125;inline int pow(int x,int y)&#123; int res=1; for(;y;x=1LL*x*x%MOD,y&gt;&gt;=1) if(y&amp;1) res=1LL*res*x%MOD; return res;&#125;namespace NTT&#123; int n,invn,bit,rev[B17],W[B17][2]; void build()&#123; int b=pow(G,MOD-2); for(int i=0;i&lt;=17;i++)&#123; W[1&lt;&lt;i][0]=pow(G,(MOD-1)/(1&lt;&lt;i)); W[1&lt;&lt;i][1]=pow(b,(MOD-1)/(1&lt;&lt;i)); &#125; &#125; void init(int _n)&#123; for(n=1,bit=0;n&lt;_n;n&lt;&lt;=1,bit++); invn=pow(n,MOD-2); for(int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); &#125; void clear(int *a)&#123;for(int i=0;i&lt;n;i++)a[i]=0;&#125; void ntt(int *a,int f)&#123; for(int i=0;i&lt;n;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); int u,v,w_n,w; for(int i=2;i&lt;=n;i&lt;&lt;=1)&#123; w_n=W[i][f==-1]; for(int j=0;j&lt;n;j+=i)&#123; w=1; for(int k=0;k&lt;i/2;k++)&#123; u=a[j+k]; v=1LL*w*a[j+i/2+k]%MOD; a[j+k]=(u+v)%MOD; a[j+i/2+k]=(u-v)%MOD; w=1LL*w*w_n%MOD; &#125; &#125; &#125; if(f==-1) for(int i=0;i&lt;n;i++) a[i]=1LL*a[i]*invn%MOD; &#125;&#125;void ksm(int *x,int y,int n,int *res)&#123; NTT::init((n+1)*2); NTT::clear(res); res[0]=1; for(;y;y&gt;&gt;=1)&#123; NTT::ntt(x,1); if(y&amp;1)&#123; NTT::ntt(res,1); for(int i=0;i&lt;NTT::n;i++) res[i]=1LL*res[i]*x[i]%MOD; NTT::ntt(res,-1); for(int i=n+1;i&lt;NTT::n;i++) res[i]=0; &#125; for(int i=0;i&lt;NTT::n;i++) x[i]=1LL*x[i]*x[i]%MOD; NTT::ntt(x,-1); for(int i=n+1;i&lt;NTT::n;i++) x[i]=0; &#125;&#125;int solve(int n,int m,int k)&#123; static int a[B17],b[B17]; memset(a,0,sizeof a); for(int i=0;i&lt;=k;i++) a[i]=iact[i]; ksm(a,m,n,b); return 1LL*fact[n]*b[n]%MOD;&#125;int main()&#123; freopen("input.in","r",stdin); NTT::build(); int n,m,k; scanf("%d%d%d",&amp;n,&amp;m,&amp;k); fact[0]=1; for(int i=1;i&lt;=n;i++) fact[i]=1LL*fact[i-1]*i%MOD; iact[n]=pow(fact[n],MOD-2); for(int i=n-1;i&gt;=0;i--) iact[i]=1LL*iact[i+1]*(i+1)%MOD; int ans=(solve(n,m,k)-solve(n,m,k-1))%MOD; printf("%d\n",ans&lt;0?ans+MOD:ans); return 0;&#125; ​ ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[最近公共祖先]]></title>
    <url>%2F2018%2F04%2F22%2F%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%2F</url>
    <content type="text"><![CDATA[Description Sample Input​ 15 5​ 1 2 3 4 5 6 7 8 9 10 11 12 13 14​ 1 1 2 2 3 3 4 4 5 5 6 6 7 7​ 1 2​ 8 11​ 5 8​ 8 15​ 4 6 Sample Output​ 1​ 5​ 4​ 7​ 3 HINT​ Solution​ 题目求的”最近公共祖先“，实际上是所有公共祖先中编号最大的那一个…… ​ 看看怎么把两棵树联系起来。 ​ 要同时维护询问的两个点的祖先的并集比较困难，考虑能不能离线简化一下问题。 ​ 我们dfs遍历A树，每走到A树的一个点$u$，回答所有形如$(u,v)$的询问，其中$v$是$B$树上的点。 ​ 注意到遍历到$u$时，根节点到$u$的路径构成了$u$的祖先集合$F_u$。于是我们就可以转化一下问题，对于每个询问，相当于询问在$F_u$中，是$v$在B树中的祖先的最大值。 ​ 预处理出A树中每一个点在B树中的dfn出序和入序，以此刻画出A树的每一个点在B树中对应哪一棵子树。在A树中每遍历到一个点，就给B树中的相应子树中的所有点更新最大值。这些操作用线段树维护B树的dfn序实现。此时问题变得非常简单，此时只需要回答$v$在线段树中相应位置的值即可。 ​ 注意到A树的dfs有回溯操作，所以用主席树解决就可以了。主席树是区间修改、单点查询，注意标记永久化。 ​ 这题的关键就在于如何转化询问，使得问题变得易于维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;cstdio&gt;#include &lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;typedef pair&lt;int,int&gt; pii;const int N=200005;int n,m,out[N];int ha[N],hb[N],tot;int dfnb[N][2],dfntm;vector&lt;pii&gt; q[N];struct Edge&#123;int v,next;&#125;e[N*2];inline void addEdge(int u,int v,int *h)&#123;e[++tot]=(Edge)&#123;v,h[u]&#125;;h[u]=tot;&#125;namespace CEG&#123; const int S=N*2*18; int rt[N],sz,ch[S][2],maxs[S]; inline int copy(int u)&#123; int v=++sz; ch[v][0]=ch[u][0]; ch[v][1]=ch[u][1]; maxs[v]=maxs[u]; return v; &#125; void insert(int u,int &amp;v,int l,int r,int L,int R,int x)&#123; v=copy(u); if(L&lt;=l&amp;&amp;r&lt;=R)&#123; maxs[v]=max(maxs[v],x); return; &#125; int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) insert(ch[u][0],ch[v][0],l,mid,L,R,x); else if(mid&lt;L) insert(ch[u][1],ch[v][1],mid+1,r,L,R,x); else&#123; insert(ch[u][0],ch[v][0],l,mid,L,mid,x); insert(ch[u][1],ch[v][1],mid+1,r,mid+1,R,x); &#125; &#125; int query(int u,int l,int r,int pos,int now)&#123; now=max(now,maxs[u]); if(l==r) return now; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) return query(ch[u][0],l,mid,pos,now); else return query(ch[u][1],mid+1,r,pos,now); &#125;&#125;void dfsB(int u,int fa)&#123; dfnb[u][0]=++dfntm; for(int i=hb[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) dfsB(v,u); dfnb[u][1]=dfntm;&#125;void dfsA(int u,int fa)&#123; CEG::insert(CEG::rt[fa],CEG::rt[u],1,n,dfnb[u][0],dfnb[u][1],u); for(int i=0,sz=q[u].size();i&lt;sz;i++)&#123; int v=q[u][i].first,qid=q[u][i].second; out[qid]=CEG::query(CEG::rt[u],1,n,dfnb[v][0],0); &#125; for(int i=ha[u],v;i;i=e[i].next) if((v=e[i].v)!=fa) dfsA(v,u);&#125;int main()&#123; freopen("input.in","r",stdin); scanf("%d%d",&amp;n,&amp;m); for(int v=2;v&lt;=n;v++)&#123; int u; scanf("%d",&amp;u); addEdge(u,v,ha); &#125; for(int v=2;v&lt;=n;v++)&#123; int u; scanf("%d",&amp;u); addEdge(u,v,hb); &#125; for(int i=1;i&lt;=m;i++)&#123; int x,y; scanf("%d%d",&amp;x,&amp;y); q[x].pb(mp(y,i)); &#125; dfsB(1,0); dfsA(1,0); for(int i=1;i&lt;=m;i++) printf("%d\n",out[i]); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ2654】]]></title>
    <url>%2F2018%2F04%2F19%2F%5BBZOJ2654%5D%2F</url>
    <content type="text"><![CDATA[Description 给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有need条白色边的生成树。 题目保证有解。 Input 第一行V,E,need分别表示点数，边数和需要的白色边数。 接下来E行,每行s,t,c,col表示这边的端点(点从0开始标号)，边权，颜色(0白色1黑色)。 Output 一行表示所求生成树的边权和。 V&lt;=50000,E&lt;=100000,所有数据边权为[1,100]中的正整数。 Solution 乍一看无从下手。可是我完全没有想到那道强化版的题目。 ​ 若直接求生成树，我们没办法保证白边的数量符合要求。 ​ 如何影响白边的选择？我们尝试对所有白边的权值加上一个偏移值$d$。令$f(d)$为偏移值为$d$被选择的白边数量，可以发现$f(d)$随着$d$的增长单调不增。这个函数可二分。 ​ 于是我们可以二分出当$f(d)=need$时$d$的值。最小生成树对边进行排序时，对于相同权值的边，我们优先选择白边。令$g(d)$为偏移值为$d$时最小生成树的权值，则$ans=g(d)-d*use$，其中$use$是最小生成树中白边的数量。 ​ 可是$f(d)$有可能在$need$处不连续，我们会二分到形如$f(d)&gt;need$且$f(d+1)&lt;need$的情况，二分值夹着答案，怎么办？ ​ 注意到我们的对于边的排序方法是若权值相同，白边优先。上述情况可以仔细讨论一下：偏移值为$d$时，存在若干条权值相同的黑边和白边，我们优先选择了白边，因而导致$f(d)&gt;need$，当偏移值为$d+1$时，原来的这些黑边和白边被强行分开了，因为白边权值大了一些，排到了后面去，因此我们优先选完了前面的这些黑边，导致了$f(d)&lt;need$。 ​ (注意这里讨论的边不会涉及到其他权值的边，因为根据我们的排序，当偏移值+1时只会影响到这些边) ​ 所以如今我们只能强行将偏移值为$d$时的一些白边用同权值的黑边来替代。 ​ 即$ans=g(d)-d f(d)+d(f(d)-need)=g(d)-dneed$。 ​ 所以二分得到$d$为$f(d)&gt;=need$的最大值，按上述式子计算即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N=50005,M=100005,INF=1000000000;int n,m,need;int bl[N];struct Edge&#123;int u,v,w,c;&#125;e[M];inline bool cmp(const Edge &amp;a,const Edge &amp;b)&#123; if(a.w!=b.w) return a.w&lt;b.w; return a.c&lt;b.c;&#125;inline int find(int x)&#123;return bl[x]==x?x:(bl[x]=find(bl[x]));&#125;int MST(int &amp;res)&#123; sort(e+1,e+1+m,cmp); for(int i=1;i&lt;=n;i++) bl[i]=i; int sum=0,wsum=0; res=0; for(int i=1;i&lt;=m&amp;&amp;sum&lt;n-1;i++)&#123; int u=find(e[i].u),v=find(e[i].v); if(u==v) continue; sum++; wsum+=e[i].w; bl[u]=v; res+=e[i].c==0; &#125; return wsum;&#125;int calc(int delta,int &amp;use)&#123; int tot=0; for(int i=1;i&lt;=m;i++) if(e[i].c==0) e[i].w+=delta,tot++; int res=MST(use); for(int i=1;i&lt;=m;i++) if(e[i].c==0) e[i].w-=delta; return res;&#125;int main()&#123; scanf("%d%d%d",&amp;n,&amp;m,&amp;need); n++; for(int i=1;i&lt;=m;i++)&#123; int u,v,w,c; scanf("%d%d%d%d",&amp;u,&amp;v,&amp;w,&amp;c); u++; v++; e[i]=(Edge)&#123;u,v,w,c&#125;; &#125; int l=-110,r=110,mid,use; while(l&lt;=r)&#123; mid=(l+r)&gt;&gt;1; calc(mid,use); if(use&gt;=need) l=mid+1; else r=mid-1; &#125; int ans=calc(r,use); printf("%d\n",ans-r*need); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ4872】]]></title>
    <url>%2F2018%2F04%2F19%2F%5BBZOJ4872%5D%2F</url>
    <content type="text"><![CDATA[Description​ Zeit und Raum trennen dich und mich. ​ 时空将你我分开。B 君在玩一个游戏，这个游戏由 n 个灯和 n 个开关组成，给定这 n 个灯的初始状态，下标为从 1 到 n 的正整数。每个灯有两个状态亮和灭，我们用 1 来表示这个灯是亮的，用 0 表示这个灯是灭的，游戏的目标是使所有灯都灭掉。但是当操作第 i 个开关时，所有编号为 i 的约数（包括 1 和 i）的灯的状态都会被改变，即从亮变成灭，或者是从灭变成亮。B 君发现这个游戏很难，于是想到了这样的一个策略，每次等概率随机操作一个开关，直到所有灯都灭掉。这个策略需要的操作次数很多， B 君想到这样的一个优化。如果当前局面，可以通过操作小于等于 k 个开关使所有灯都灭掉，那么他将不再随机，直接选择操作次数最小的操作方法（这个策略显然小于等于 k 步）操作这些开关 B 君想知道按照这个策略（也就是先随机操作，最后小于等于 k 步，使用操作次数最小的操作方法）的操作次数的期望。这个期望可能很大，但是 B 君发现这个期望乘以 n 的阶乘一定是整数，所以他只需要知道这个整数对 100003 取模之后的结果。 $1 ≤ n ≤ 100000\;\; 0 ≤ k ≤ n$ Solution​ 我开始想到生成函数什么的东西去了，然而这题隐藏得是在太深了…… ​ 首先考虑没有随机时的最优策略：由于一个开关只能影响到比它编号小的灯，所以我们从大到小考虑，如果当前灯是亮的，我们必须要动一次开关，并更新编号为其约数的电灯。显然这是唯一且最优策略。 ​ 考虑这个策略，记全部开关为$A$，按过的开关集合为$S$，我们发现每个$S$中的开关必须按且只按一次，而$A-S$中的开关一次不按。这样一来后面的问题就根本不涉及什么约数问题了，问题变为：按多少次才能将$S$中的开关按奇数次，将$A-S$中的开关按偶数次。 ​ 记$fi$表示还需要连续按对$i$次才能达到最终状态，转移到$f{i-1}$的期望步数。“按对”指的是将$S$中还是偶数次的开关按下，或者将$A-S$中还是奇数的开关按下。易得： \begin{aligned} f_i&=\frac in*1+\frac{n-i}n(1+f_{i+1}+f_i)\\ &=\frac{(n-i)f_{i+1}+n}i \end{aligned}​ 作为边界条件，$f_n=1$，因为随便按一个都是往正确方向走的（太差了）。 ​ 所以得到$ans=k+\sum_{i=k+1}^{need}f_i$，其中$need$是最优策略步数。复杂度$O(n\;log\;n)$ ​ 这题的关键在于化简题目，找到本质，然后就发现这是一道经典的简单的期望DP。=_= Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;vector&gt;#define pb push_backusing namespace std;const int N=100005,MOD=100003;int n,K,a[N],need;int inv[N],factn;int f[N];vector&lt;int&gt; d[N];int main()&#123; freopen("input.in","r",stdin); scanf("%d%d",&amp;n,&amp;K); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); factn=1; for(int i=2;i&lt;=n;i++) factn=1LL*factn*i%MOD; inv[1]=1; for(int i=2;i&lt;=n;i++) inv[i]=-1LL*(MOD/i)*inv[MOD%i]%MOD; for(int i=1;i&lt;=n;i++) for(int j=i;j&lt;=n;j+=i) d[j].pb(i); need=0; for(int i=n;i&gt;=1;i--) if(a[i])&#123; need++; for(int j=0,sz=d[i].size();j&lt;sz;j++) a[d[i][j]]^=1; &#125; if(need&lt;=K)&#123;printf("%d\n",1LL*need*factn%MOD);return 0;&#125; f[n]=1; for(int i=n-1;i&gt;K;i--) f[i]=(1LL*(n-i)*f[i+1]%MOD+n)*inv[i]%MOD; int ans=K; for(int i=K+1;i&lt;=need;i++) (ans+=f[i])%=MOD; ans=1LL*ans*factn%MOD; printf("%d\n",ans&lt;0?ans+MOD:ans); return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>转化</tag>
        <tag>DP---期望概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学竞赛]]></title>
    <url>%2F2018%2F04%2F18%2F%E6%95%B0%E5%AD%A6%E7%AB%9E%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[Sample Input 111111000 1/2 Sample Output 63616161 Solution​ 前面两个子任务非常容易构造。 ​ 第三个子任务比较简单，而且非常关键。不断使用7、8操作，我们一定可以凑出任意一种分数$\frac pq$。反过来考虑怎么从$\frac pq$变为$\frac 01$：如果分子比分母大，则一直减去分母。随后若分子为0，则完成并退出，否则取一个倒数，重复上述步骤，即： 12345void work(int p,int q)&#123; while(p&gt;=q) p-=q; if(p==0) return; //Done work(q,p);&#125; ​ 然而我们发现后面的任务中7操作和8操作是禁用的，这个方法无法解决后面的问题。与其形成对比，前6个操作却是一直可用。考虑能否用前6个操作强行凑出7~9操作。 ​ 首先看对一个角度$x$取余变为$90^\circ-x$，等价于对$x$先取$sin$，再取$cos^{-1}$。 ​ 然后看回题目中的操作： ​ 8: 对一个长度$x$取倒数变为$\frac 1x$，等价于对$x$先取$tan^{-1}$，再取余，最后取$tan$。 ​ 9: $x\rightarrow\sqrt{x^2+1}$等价于对$x$依次取$tan^{-1}$，$cos$，最后取倒数。这一个操作用$tan$的三角函数线转换一下就可以得出。 ​ 但是7操作凑不出来，9操作又引入新的根号，很麻烦，不可以直接套用回子任务三的解法，怎么做？ ​ 发现9操作有个很神奇的变式：$\sqrt x \rightarrow\sqrt{(\sqrt x)^2+1}=\sqrt{x+1}$，如果我们在根号的意义下考虑，这就相当于7操作！ ​ 问题变为我有一个终止状态$\frac {\sqrt{p^2}}{\sqrt{q^2}}=\sqrt{\frac {p^2}{q^2}}$，并且可以使用两种操作：分子加上分母、分子与分母互换。这个做法和子任务三完全一致，直接套用即可。 ​ 所以还是脑洞能力和敏感度太差了。 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;char tmp233[10];inline int getInt()&#123; char c=getchar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void dfs(int p,int q)&#123; int t7=0; while(p&gt;=q) p-=q,t7++; if(p) dfs(q,p),printf("6145"); while(t7--) printf("636145");&#125;int main()&#123; freopen("input.in","r",stdin); scanf("%s",tmp233); int p=getInt(),q=getInt(); if(!p)&#123;return 0;&#125; dfs(p*p,q*q); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演]]></title>
    <url>%2F2018%2F04%2F11%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演​ 对于两个定义域为非负整数的函数$F(n)$和$f(n)$ ​ 若满足：$F(n)=\sum\limits{d|n}f(d)$，则反演得到$f(n)=\sum\limits{d|n}\mu(d)F(\frac n d)$； \sum_{d\mid n}\mu(d)F(\frac n d)= \sum_{d\mid n}\mu(d)\sum_{d'\mid (n/d)}f(d')= \sum_{d'\mid n}f(d')\sum_{d|(n/d')}\mu(d)\\ \because根据下文\mu的性质，当且仅当n/d'=1时式子有值，此时d'=n,d=1\\ \therefore原式=f(n)*\mu(1)=f(n)​ 常用变式：若满足：$F(n)=\sum\limits{n|d}f(d)$，则反演得到$f(n)=\sum\limits{n|d}\mu(\frac d n)F(d)$ 。 $\mu(i)$函数（莫比乌斯函数）​ 定义： \mu(d)=\begin{cases} 1& d=1\\ (-1)^k& d=p_1p_2...p_k&(p_i为互异素数)\\ 0& d=p_1p_2...p_k &(p_i为素数，但有重复，即存在平方因子) \end{cases} d\in\mathbb{N}^*​ 按照定义用线性筛来求解： ​ 循环$i$，判定$i$为素数时，令$\mu(i)=-1$； ​ 筛到$x$时($x=i*p$)，若$i|p$，则$x$有$p^2$这个因子，此时令$\mu(x)=0$； ​ 否则$i\nmid p$，则$x$的互异素数数量加1，则令$\mu(x)=-\mu(i)$ 123456789101112131415mu[1]=1;for(int i=2;i&lt;=n;i++)&#123; if(!vis[i])&#123; lis[++cnt]=i; mu[i]=-1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*lis[j]&lt;=n;j++)&#123; vis[i*lis[j]]=1; if(i%lis[j]==0)&#123; mu[i*lis[j]]=0; break; &#125; mu[i*lis[j]]=-mu[i]; &#125;&#125; ​ $\mu(i)$函数性质：（1）它是积性函数。 ​ （2）对于$n\in\mathbb{N}^*$： \sum_{d\mid n}\mu(d)=\begin{cases} 1& n=1\\ 0& else \end{cases} \sum_{d|n}\frac{\mu(d)}{d}=\frac{\phi(n)}{n}求解应用BZOJ2820 GCD​ 给定$n,m$，求满足$1\le x\le n,1\le y\le m$ 且 $gcd(x,y)$为质数的$(x,y)$有多少对. ​ 我们设出两个函数，使得它们满足反演变式的关系：$F(d)$表示$d\mid gcd(x,y)$ 的有多少对，$f(d)$ 表示$gcd(x,y)=d$的有多少对，其中$1\le x\le n,1\le y\le m$. ​ 它们确实满足$F(n)=\sum\limits{n|d}f(d)$ . 故$f(n)=\sum\limits{n|d}\mu(\frac d n)F(d)$. 方便的是F(d)=\lfloor \frac n d\rfloor\lfloor\frac m d \rfloor，即每个数对可以看成$(dx,dy)$，然后考虑$x$和$y$的取值各有多少种，乘起来便是$F(d)$ ，因此$f(n)=\sum\limits_{n\mid d }\mu(\frac d n)\lfloor \frac n d\rfloor\lfloor\frac m d \rfloor$. ​ \begin{aligned} ans&=\sum_{p}f(p)\\ &=\sum_{p}\sum_{p\mid d }\mu(\frac d p)\lfloor \frac n d\rfloor\lfloor\frac m d \rfloor\\ &=\sum_p\sum_{k=1}^{\lfloor min(n,m)/p\rfloor}\mu(\frac{kp}p)\lfloor\frac n {kp}\rfloor\lfloor\frac m {kp}\rfloor&枚举d的取值，用kp替代\\ &=\sum_{T=1}^{min(n,m)}\lfloor\frac n T\rfloor\lfloor\frac m T\rfloor\sum_{p\mid T}\mu(\frac T p) &令T=kp \end{aligned}​ 令$g(x)=\sum_\limits{p\mid x}\mu(\frac x p)$ ，那么现在的任务是求出所有的$g(x)$. 考虑用线性筛的方式来求: ​ 循环$i$， 判定$i$是质数时，令$g(i)=\mu(1)=1$ ​ 筛到$x$时($x=i*P$)，若$P\mid i$，则$x$有$P^2$这个因子，除非求值式中的$p$将$x$中的$P^2$除去，否则$\mu(\frac x p)=0$，唯一一个有值的是当$p=P$时$\mu(\frac x P)=\mu(i)$. 综合，$g(x)=\mu(i)$ ​ 若$P\nmid i$，则$P$与$i$互质。当$p=P$时，值是$\mu(\frac {iP}P)=\mu(i)$。 ​ 当$p\ne P$时，循环的$p$和g(i)中循环的$p$是一样的 ，则\sum_{p|x且p!=P}\mu(\frac xp)=\sum_{p|i}\mu(\frac i p*P)=\sum_{p|i}\mu(\frac i p)\mu(P)=\mu(P)\sum_{p|i}\mu(\frac ip)=-1*g(i)=-g(i) ​ 综合，$g(x)=\mu(i)-f(i)$ ​ 于是用线性筛求出了$g(x)$ ​ 回到答案的表达式$ans=\sum\limits{T=1}^{min(n,m)}\lfloor\frac n T\rfloor\lfloor\frac m T\rfloor\sum{p\mid T}\mu(\frac T p)$，如果循环$1…min(n,m)$显然不够快，考虑$\lfloor\frac n T\rfloor\lfloor\frac m T\rfloor$的取值是根号级别的，对于每一组$\lfloor\frac n T\rfloor\lfloor\frac m T\rfloor$相等的$l\leq T\leq r$，可以加快计算，将$\lfloor\frac n T\rfloor\lfloor\frac m T\rfloor$提取出来，那么这些$T$的贡献就是$\lfloor\frac n T\rfloor\lfloor\frac m T\rfloor\sum\limits_{i=l}^rg(i)$，预处理出$g(i)$的前缀和即可。 ​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;using namespace std;const int N=10000001;typedef long long ll;int T,n,m;int mu[N],g[N];int vis[N],lis[N],cnt;inline void swap(int &amp;x,int &amp;y)&#123;int t=x;x=y;y=t;&#125;inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;int main()&#123; freopen("input.in","r",stdin); mu[1]=1; for(int i=2;i&lt;N;i++)&#123; if(!vis[i])&#123; lis[++cnt]=i; mu[i]=-1; g[i]=1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*lis[j]&lt;N;j++)&#123; int p=lis[j],x=i*p; vis[x]=1; if(i%lis[j]==0)&#123; mu[x]=0; g[x]=mu[i]; break; &#125; else&#123; mu[x]=-mu[i]; g[x]=mu[i]-g[i]; &#125; &#125; &#125; for(int i=1;i&lt;N;i++) g[i]+=g[i-1]; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;n,&amp;m); if(n&gt;m) swap(n,m); ll ans=0; for(int i=1,j;i&lt;=n;i=j+1)&#123; j=min(n/(n/i),m/(m/i)); ans+=1LL*(n/i)*(m/i)*(g[j]-g[i-1]); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>数论---莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ants on tree]]></title>
    <url>%2F2018%2F04%2F08%2FAnts-on-tree%2F</url>
    <content type="text"><![CDATA[Description从前有一个策略游戏, 叫做 蚂蚁上树游戏中有一棵 nn 个节点, 以 11 为根的有根树初始始每个节点都为空, 游戏系统会进行两种操作 :1 x , 表示往 xx 节点放入一只睡眠状态中的蚂蚁2 x , 表示从 xx 节点取出一只睡眠状态中的蚂蚁(对于操作2, 保证取出前该点至少有一只蚂蚁)每次操作后, 玩家要进行一轮游戏 :游戏有无穷的时间, 每一时刻, 系统会 依次执行 下述五个操作1) 让玩家选择 任意多只(可以为 0 只) 睡眠状态中的蚂蚁2) 所有亢奋状态的蚂蚁朝根结点方向移动一步3) 若某一时刻 ≥2≥2只 亢奋状态 的蚂蚁处在同一节点, 游戏失败4) 到达根节点的蚂蚁进入睡眠状态.5) 当前时刻被玩家选择的蚂蚁进入亢奋状态6) 若所有蚂蚁都在根节点, 游戏结束游戏不允许失败, 玩家的游戏目的是 : 使游戏结束时, 最后一只到达根节点的蚂蚁到达时间最早.每轮游戏后, 系统会自动将树恢复成玩家该轮游戏前的局面, 然后进行下一次取/放蚂蚁的操作. Input第一行两个数 n,mn,m 表示树的点数和操作数第 2−n2−n 行, 第 ii 行一个数 fifi 表示 ii 节点的父亲接下来 mm 行, 每行两个数表示系统的操作若为 1 x , 表示往 xx 节点放入一只睡眠状态中的蚂蚁若为 2 x , 表示从 xx 节点取出一只睡眠状态中的蚂蚁 Output输出 mm 行, 表示每轮游戏在最优策略下最后一只到达根节点的蚂蚁到达的最早时间(特别的, 如果所有蚂蚁都在根节点, 或者没有蚂蚁, 输出 0) Sample Input1234567894 51221 11 31 41 22 3 Sample Output1234503443 HINT对于样例输出第四行的解释 :第一时刻触碰位于 2, 3 的那只蚂蚁, 他们进入亢奋状态但没有移动第二时刻触碰位于 4 的那只蚂蚁, 然后位于 2, 3 的蚂蚁分别爬到 1, 2, 然后爬到 1 的蚂蚁进入睡眠状态, 之后 4 进入亢奋状态.第三时刻不触碰蚂蚁, 当前位于 2, 4 的蚂蚁分别爬到 1, 2, 爬到 1 的这只蚂蚁进入睡眠状态第四时刻不触碰蚂蚁, 当前位于 2 的蚂蚁爬到 1 并进入睡眠状态, 然后游戏结束数据范围 :对于 30%的数据, $n,m≤3000$对于另外 30% 的数据, $n≤5000$对于另外 5% 的数据, 树的最大深度为 2对于另外 10% 的数据, 数据的生成方式如下 $fi=rand()%(i−1)+1$对于 100% 的数据 :$2≤n≤10^5$$1≤m≤10^5$$1≤fi&lt;i,i=2..n$ $1≤x≤n$ Solution​ 这题看起来很复杂，考场上我想了个反推的模拟，还写挂了，看起来并不对。 ​ 考虑每个蚂蚁往上走的过程，是一激活就停不下来的。那么如果两只蚂蚁到达根节点的时间相同，那么它们必定在某一处会相撞。 ​ 那么问题等价于为每一只蚂蚁挑一个至少为其深度的到达时间，使得每只蚂蚁的到达时间唯一，且最大时间最小。 ​ 我们应该按深度从小到大考虑每一个深度$i$的$sum_i$只蚂蚁，给同一深度的$sum_i$只蚂蚁挑连续一段的到达时间$[i,i+sum_i)$ ​ 可是我们发现，不同深度挑选的区间一旦有重复，就意味着有蚂蚁会同时刻到达终点，也就是早就会撞上，因此挑选的区间必须互相不重叠。 ​ 那么每个深度的区间开头位置往往取不到$i$，因为前面会顺延下来造成推移。 ​ 答案求的其实是最靠后的一个区间的结束位置，记每个深度为$i$的节点到达时间区间为$[start_i,start_i+sum_i)$，那么实际上$ans=max { start_i+sum_i-1}$。 ​ 然而维护$start$太难了，下面证明实际上$ans=max{i+a_i-1},i&gt;0$，其中$a_i$表示深度大于等于$i$的蚂蚁个数。 ​ 首先根节点的蚂蚁全部忽略掉不考虑。 ​ 设深度为$i$的蚂蚁们被分配到的区间是最后的。 ​ 如果开头位置取到了$i$，那么$i+a_i-1$可以贡献到答案，并且发现其他情况时都不可能贡献到比这个还大的位置。 ​ 如果开头位置没有取到$i$，说明这个区间被顺延了，根据贪心策略，这个区间一定紧挨着上一个区间，以此类推形成一个连通块。设连通块最前端的区间是给$j$取的，而且此区间的开始位置一定是最好情况：刚好取到$j$，所以$j+a_j-1$可以贡献到$i$的结尾位置。 ​ 所以用线段树维护一下$i+a_i-1$就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int N=100005,M=200005;namespace IO&#123; const int SIZE=10000000; char buffer[SIZE]; int pos; void init()&#123;fread(buffer,1,SIZE,stdin);&#125; char getch()&#123;return buffer[pos++];&#125; int getInt()&#123; char c=getch(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getch();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getch();&#125; return x*f; &#125;&#125;int n,m,antcnt,a[N];int h[N],tot,dep[N],maxdep;struct Edge&#123;int v,next;&#125;e[M];struct Data&#123; int x; Data()&#123;&#125; Data(int _x)&#123;x=_x;&#125; friend bool operator &lt; (const Data &amp;a,const Data &amp;b)&#123; if(dep[a.x]!=dep[b.x]) return dep[a.x]&lt;dep[b.x]; return a.x&lt;b.x; &#125;&#125;;set&lt;Data&gt; s;inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;inline void addEdge(int u,int v)&#123;e[++tot].v=v;e[tot].next=h[u];h[u]=tot;&#125;void dfs(int u,int fa)&#123; maxdep=max(maxdep,dep[u]); for(int i=h[u],v;i;i=e[i].next) if((v=e[i].v)!=fa)&#123; dep[v]=dep[u]+1; dfs(v,u); &#125;&#125;namespace SEG&#123; int rt,sz,ch[N*2][2],maxs[N*2],tag[N*2]; void addtag(int u,int x)&#123; maxs[u]+=x; tag[u]+=x; &#125; inline void pushup(int u)&#123;maxs[u]=max(maxs[ch[u][0]],maxs[ch[u][1]]);&#125; inline void pushdown(int u)&#123; if(tag[u])&#123; addtag(ch[u][0],tag[u]); addtag(ch[u][1],tag[u]); tag[u]=0; &#125; &#125; void build(int &amp;u,int l,int r)&#123; u=++sz; maxs[u]=r; if(l==r) return; int mid=(l+r)&gt;&gt;1; build(ch[u][0],l,mid); build(ch[u][1],mid+1,r); &#125; void modify(int u,int l,int r,int L,int R,int x)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123; addtag(u,x); return; &#125; pushdown(u); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid) modify(ch[u][0],l,mid,L,R,x); if(mid&lt;R) modify(ch[u][1],mid+1,r,L,R,x); pushup(u); &#125; int query(int u,int l,int r,int L,int R)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) return maxs[u]; pushdown(u); int mid=(l+r)&gt;&gt;1; if(R&lt;=mid) return query(ch[u][0],l,mid,L,R); else if(mid&lt;L) return query(ch[u][1],mid+1,r,L,R); else return max(query(ch[u][0],l,mid,L,mid),query(ch[u][1],mid+1,r,mid+1,R)); &#125;&#125;int main()&#123; freopen("input.in","r",stdin); IO::init(); n=IO::getInt(); m=IO::getInt(); for(int i=2;i&lt;=n;i++)&#123; int x=IO::getInt(); addEdge(x,i); &#125; dfs(1,0); int opt,x; SEG::build(SEG::rt,0,maxdep); for(int i=1;i&lt;=m;i++)&#123; opt=IO::getInt(); x=IO::getInt(); if(opt==1)&#123; a[x]++; antcnt++; if(a[x]==1) s.insert(Data(x)); &#125; else&#123; a[x]--; antcnt--; if(!a[x]) s.erase(s.find(Data(x))); &#125; if(x!=1) SEG::modify(SEG::rt,0,maxdep,0,dep[x],opt==1?1:-1); if(!antcnt||a[1]==antcnt) printf("0\n"); else&#123; set&lt;Data&gt;::iterator pos=s.end(); pos--; printf("%d\n",SEG::query(SEG::rt,0,maxdep,0,dep[(*pos).x])); &#125; &#125; return 0;&#125; ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[IT]]></title>
    <url>%2F2018%2F04%2F08%2FIT%2F</url>
    <content type="text"><![CDATA[Description​ IT = Inverse Transform ​ 两个长度为 $2n$ 的序列 $a,b$. ( 下标从 $0$ 到 $2n−1$ ) ​ 满足$ 0≤a_i≤10^9$ , 且 由 $a$ 变换而来, 变换如下: ​ $bi=∑\limits{0≤j&lt;2^n}f((i∨j)⊕i) a_j$ ​ 其中 $V$ 表示按位或, $⊕$ 表示按位异或. f(x)=[x的二进制中1的个数为偶数]f(x)=[x的二进制中1的个数为偶数] ​ (其中 [expression] 当 $expression$ 为真时为 1, 否则为 0) ​ 现在, $a$ 序列被玩丢了… ​ 请你通过 $b$ 序列还原出 $a$ 序列 Input​ 第一行一个数 $T$ 表示测试数据组数​ 接下来对于每组数据 :​ 第一行一个整数 $n$​ 第二行 $2n$ 个整数, 表示序列 $b$ Output​ 输出包括 $T$ 行​ 每行 $n$ 个整数, 表示序列 $a$ Sample Input​ 4​ 0​ 1​ 1​ 1 3​ 2​ 5 3 4 10​ 3​ 101 91 92 104 93 105 108 190 Sample Output​ 1​ 1 2​ 1 2 3 4​ 31 24 26 23 27 23 24 12 HINT​ 对于 10% 的数据 n≤5​ 对于另外 10% 的数据 n≤10​ 对于 100% 的数据 :​ T≤5​ 1≤n≤20​ 数据保证 b 序列 能 唯一地对应一个 a 序列​ 且保证对应的 a 序列满足 $0≤a_i≤10^9$ ​ ( 注意 : 但 不保证 读入的 $b$ 序列满足 $0≤bi≤10^9$ ) Solution​ 不得不说是道很好的题啊. ​ 题目中的$f((i∨j)⊕i)$，当且仅当$i=0$且$j=1$时为1，其余情况皆为0. ​ 正解用的是分治的方法，再向上合并，有点类似各大快速变换的思想. ​ 首先考虑若知$a$，如何$O(n log n)$求$b$. ​ 由于总长度是$2^n$，所以给分治带来了极大的便利。每次对$[l,r]$分治为$[l,mid]$与$(mid,r]$来解决。自底向上层层计算，对于分治区间$[l,r]$, 当下$b_i$的值表示： b_i=\sum_{j=l}^r f((i∨j)⊕i)*a_j \quad\quad\quad i\in[l,r]​ 那么分治完成后，$b_i$的值才是最终答案。 ​ 考虑最底层的情况$[l,l]$，此时$b_l=f((l∨l)⊕l)*a_l=a_l$. ​ 假设现在正在在分治$[l,r]$，记分治长度$len=(r-l+1)$，已经计算出$[l,mid]$和$(mid,r]$ 的$b$值，现在考虑如何将$b$合并。 ​ 分治区间的长度是2的整数次幂，这给了一个很棒的性质，记$k=log_2len$，若只看下标的后$k$位，我们会发现，对于左右区间，左边的最高位全是0，右边的最高位全是1。如果忽略最高位，对于$\forall i\in[l,mid]$都有$i==i+(r-l+1)/2$. 而随着分治的逐渐上推，$k$是不断加一加一的。 ​ 这意味着如果我们要求新的$b’_i$，我们只需要考虑当前$i$的最高位（第$k$位）带来的影响。 ​ 记$g_k(i,j)​$表示只考虑$i​$和$j​$的后$k​$位时，$f((i∨j)⊕i)​$的值。 ​ 首先看$i\in(mid,r]$, 它们的第$k$位都是1. 由于$(1,0)$和$(1,1)$计算出来都是$0$，所以我们可以直接令$b’i=b{i-len/2}+b_i$ ​ 为什么？因为$b{i-len/2}$对应着满足$g{k-1}(i-len/2,j)=1$的$a_j$的总和，而这些$j$同样满足$g_k(i,j)$，所以这些$a_j$可以加进来。 $bi$对应着满足$g{k-1}(i,j)=1$的$a_j$的总和，而这些$j$同样满足$g_k(i,j)$，所以这些$a_j$也可以加进来。 ​ 接着再看$i\in[l,mid]$，它们的第$k$位都是$0$. 我们令$b’i=b_i+(\sum{j=mid+1}^raj) -b{i+len/2}$。$bi$的部分同上很好理解，因为$(0,0)$计算出来是$0$，满足$g{k-1}(i,j)=0$的$j$同样满足$gk{i,j}$，这些$a_j$可以加进来；另一部分比较特殊，因为$(0,1)$计算出来是1，满足$g{k-1}(i+len/2,j)=1$的$j$必定不满足$gk(i,j)=1$，因为计算出来的1会使1的总数变为奇数，那么我们现在反而要变向使用“不合法的情况”，即满足$g{k-1}(i+len/2,j)=0$的情况，容易表达为$(\sum{j=mid+1}^ra_j) -b{i+len/2}$。 ​ 总结一下，我们有： \begin{aligned} b'_i&=b_i+(\sum_{j=mid+1}^ra_j)-b_{i+len/2} &i\in[l,mid]\\ b'_i&=b_{i-len/2}+b_i &i\in(mid,r] \end{aligned}​ 就可以自底向上$O(nlogn)​$上推得到$b​$了。 ​ 下面看如何知$a$反推$b$，把上述两个式子一加再化简就可以得到： \begin{aligned} b_i&=\frac{b'_i+b'_{i+len/2}+(\sum_{j=mid+1}^ra_j)}2 &i\in[l,mid]\\ b_i&=b'_i-b_{i-len/2} &i\in(mid+1,r] \end{aligned}​ 观察得到$b’r=\sum{j=l}^r aj$，且$b’{mid}=\sum{j=l}^{mid}a_j$，所以$\sum{j=mid+1}^r aj=b’_r-b’{mid}$ ​ 然后就神奇的反推下去了。代码奇短无比又简单。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;using namespace std;const int N=1100000;typedef long long ll;namespace IO&#123; const int SIZE=50000000; char buffer[SIZE]; int pos; void init()&#123;fread(buffer,1,SIZE,stdin);&#125; char getch()&#123;return buffer[pos++];&#125; ll getInt()&#123; char c=getch(); ll x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-f;c=getch();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getch();&#125; return x*f; &#125;&#125;int bn,n;ll a[N];void solve()&#123; for(int i=n;i&gt;1;i&gt;&gt;=1)&#123; for(int j=0;j&lt;n;j+=i)&#123; ll s=a[j+i-1]-a[j+i/2-1]; for(int k=0;k&lt;i/2;k++)&#123; a[j+k]=(a[j+k]+a[j+i/2+k]-s)/2; a[j+i/2+k]-=a[j+k]; &#125; &#125; &#125;&#125;void Main()&#123; bn=IO::getInt(); n=1&lt;&lt;bn; for(int i=0;i&lt;n;i++) a[i]=IO::getInt(); solve(); for(int i=0;i&lt;n;i++) printf("%lld ",a[i]); puts("");&#125;int main()&#123; freopen("input.in","r",stdin); IO::init(); int T=IO::getInt(); while(T--) Main(); return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[常系数线性齐次递推]]></title>
    <url>%2F2018%2F03%2F04%2F%E5%B8%B8%E7%B3%BB%E6%95%B0%E7%BA%BF%E6%80%A7%E9%BD%90%E6%AC%A1%E9%80%92%E6%8E%A8%2F</url>
    <content type="text"><![CDATA[问题 给定数列前k项$h0…h{k-1}$，其后的项满足：$hi=\sum{i=1}^kh_{i-j}a_i$，其中$a_1…a_k$是给定的系数，求$h_n$ 暴力 数据范围小的时候： 做法一：暴力$O(nk)$的DP 做法二：矩阵快速幂. 记$Hi=\begin{bmatrix}h_i&amp;h{i+1}&amp;…&amp;h{i+k-1}\end{bmatrix}$. 则$h_n$是$H{n-k+1}$的最后一项。 $H_{n-k+1}=H_0M^{n-k+1}$ 其中$M$是转移矩阵，如当$k=4$时是这么填的： M=\begin{bmatrix} 0&0&0&a_4\\ 1&0&0&a_3\\ 0&1&0&a_2\\ 0&0&1&a_1 \end{bmatrix} 时间复杂度$O(k^3lg n)$ 常系数线性齐次递推 数据范围大一些的时候： $k\leq2000,n\leq10^9$. 这时候矩阵快速幂也做不了了 特征多项式 还是拿$k=4$时举例，$M$的特征多项式$f(\lambda)$为： f(\lambda)=det(\lambda I-M)=\begin{bmatrix} \lambda&0&0&0\\ 0&\lambda&0&0\\ 0&0&\lambda&0\\ 0&0&0&\lambda \end{bmatrix} -\begin{bmatrix} 0&0&0&a_4\\ 1&0&0&a_3\\ 0&1&0&a_2\\ 0&0&1&a_1 \end{bmatrix}=\begin{bmatrix} \lambda&0&0&-a_4\\ -1&\lambda&0&-a_3\\ 0&-1&\lambda&-a_2\\ 0&0&-1&\lambda-a_1 \end{bmatrix} 用行列式的性质，将$f(\lambda)$按最后一列拉普拉斯展开，得到如下，其中$(-1)^{i+j}f(x)_{i,j}$即行列式定义里的代数余子式： \begin{aligned} f(\lambda)&=\sum_{i=1}^ka_{k-i+1}(-1)^{i+j}f(\lambda)_{i,j}\;\;\;\;\;\;&取j=k（按最后一列展开）\\ &=\sum_{i=1}^ka_{k-i+1}(-1)^{i+k}f(\lambda)_{i,k} \end{aligned} 化简得到如下式子（也可以按$k=4$带进去看看规律） f(\lambda)=\lambda^k-\sum_{i=1}^ka_i\lambda^{k-i} 现在明确一个定义，$f(x)$这个函数的自变量$x$可以是实数，也可以是矩阵等等。这个函数仅仅是表示如何将自变量组合起来。表达的意思也会多样化，比如多项式、矩阵的多项式…下文会随时切换自变量的种类，但是函数的本质不变。 Cayley-Hamilton定理带来的转换 $\lambda$是$M$的特征值，是一个数。但是根据Cayley-Hamilton定理，如果把$\lambda$替换成$M$代入，结果为一个零矩阵： f(M)=M^k-\sum_{i=1}^ka_iM^{k-i}=0 我们想要求$M$的$n$次方（这里的$n$只是代表$M$的$n$次方，题目中$n$应该用$n-k+1$替代），然而$M^n$直接快速幂求不现实，复杂度为$O(k^3lg n)$ 退一步考虑，要求一个数字的$n$次方$x^n$，如果我们把$x^n$对$f(x)$取模会发生什么？ 根据多项式取模的定义，$x^n\;\text{mod}\;f(x)=f(x)g(x)+r(x)$，其中$g(x)$和$r(x)$是两个多项式 将$x$看成$M$，那么$f(M)$为$0$ 故$M^n\;\text{mod}\;f(M)=r(M)$，且$M^n=M^n\;\text{mod}\;f(M)$，那么$M^n=r(M)$这个多项式 根据多项式取模的特性，$r(x)$的阶数严格小于模数$f(x)$的阶数$k$(最高次项是$x^k$) 那么$r(x)$所包含的$M$的指数一定小于$k$，到达了可以计算的范围。 要求$M^n$，就只需要求$M^n\;\text{mod}\;f(M)$的多项式$r(M)$ 如果两个多项式$A(x)$和$B(x)$对模数取模分别得到$C(x)$和$D(x)$，那么多项式$A(x)B(x)$对模数取模结果就是$C(x)D(x)$ 那么就可以用快速幂来求解$M^n\;\text{mod}\;f(M)$的结果了，也就是求出了$r(x)$的各项系数（记为$c_i$） 至此求出$r(x)=\sum\limits{i=0}^{k-1}c_ix^i$. 将它看成矩阵的多项式代入$M$，得$r(M)=\sum\limits{i=0}^{k-1}c_iM^i$ 所以$M^n=\sum\limits_{i=0}^{k-1}c_iM^i$ 把$n$替换成题目所需要的$n-k+1$，最终答案$h_n$为$H_0M^{n-k+1}$的最后一项。 H_0M^{n-k+1}=H_0\sum_{i=0}^{k-1}c_iM^i=\sum_{i=0}^{k-1}c_iH_0M_i=\sum_{i=0}^{k-1}c_iH_i 记$last(Hi)=h{k+i}$ ，那么 h_n=last(H_0M^{n-k+1})=\sum_{i=0}^{k-1}c_ilast(H_i)=\sum_{i=0}^{k-1}c_ih_{i+k} 发现$i+k\in[k,2k-1]$，所以暴力算出$hk…h{2k-1}$，代入求解得到$h_n$，至此全部求完。 分析复杂度：多项式乘法此处用暴力算会比FFT快，耗时最多的集快速幂求$r(x)$ ，复杂度为$O(k^2lgn)$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;using namespace std;const int K=4005,mod=1e9+7;int n,k;int a[K],h[K];int b[K],c[K],t[K],mo[K];inline void add(int &amp;x,int y)&#123; x+=y; if(x&gt;=mod) x-=mod;&#125;void mul(int *x,int *y,int *z)&#123; for(int i=0;i&lt;=2*k-2;i++) t[i]=0; for(int i=0;i&lt;k;i++) for(int j=0;j&lt;k;j++) add(t[i+j],1LL*x[i]*y[j]%mod); for(int i=2*k-2;i&gt;=k;i--)&#123; for(int j=k-1;j&gt;=0;j--) add(t[i-k+j],mod-1LL*t[i]*mo[j]%mod); t[i]=0; &#125; for(int i=0;i&lt;k;i++) z[i]=t[i];&#125;void ksm(int y)&#123; for(;y;mul(b,b,b),y&gt;&gt;=1) if(y&amp;1) mul(c,b,c);&#125;int main()&#123; freopen("input.in","r",stdin); scanf("%d%d",&amp;n,&amp;k); n++; for(int i=1;i&lt;=k;i++)&#123; scanf("%d",&amp;a[i]); if(a[i]&lt;0) a[i]+=mod; &#125; for(int i=1;i&lt;=k;i++)&#123; scanf("%d",&amp;h[i]); if(h[i]&lt;0) h[i]+=mod; &#125; mo[k]=1; for(int i=1;i&lt;=k;i++) mo[k-i]=mod-a[i]; if(n&lt;=k)&#123;printf("%d\n",h[n]);return 0;&#125; b[1]=1; c[0]=1; ksm(n-k); for(int i=k+1;i&lt;=2*k;i++) for(int j=1;j&lt;=k;j++) add(h[i],1LL*a[j]*h[i-j]%mod); int ans=0; for(int i=0;i&lt;k;i++) add(ans,1LL*c[i]*h[i+k]%mod); printf("%d\n",ans); return 0;&#125; FFT加速 如果$k$也比较大，那么要上多项式全家桶来优化多项式计算了！复杂度$O(k\log k\log n)$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vi;const int K=200005,mod=998244353,G=3;int n,k,a[K],h[K];inline void swap(int &amp;x,int &amp;y)&#123;int t=x;x=y;y=t;&#125;inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;inline void add(int &amp;x,int y)&#123; y=(y%mod+mod)%mod; (x+=y)%=mod;&#125;inline int pow(int x,int y)&#123; int ret=1; for(;y;x=1LL*x*x%mod,y&gt;&gt;=1) if(y&amp;1) ret=1LL*ret*x%mod; return ret;&#125;namespace NTT&#123; int n,invn,bit,rev[K*4],A[K*4],B[K*4],W[K*4][2]; void build()&#123; int bas=pow(G,mod-2); for(int i=0;i&lt;=18;i++)&#123; W[1&lt;&lt;i][0]=pow(G,(mod-1)/(1&lt;&lt;i)); W[1&lt;&lt;i][1]=pow(bas,(mod-1)/(1&lt;&lt;i)); &#125; &#125; void init(int na,int nb,vi &amp;a,vi &amp;b,int fn=0)&#123; if(!fn) fn=na+nb; for(n=1,bit=0;n&lt;fn;n&lt;&lt;=1,bit++); invn=pow(n,mod-2); for(int i=0;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); for(int i=0;i&lt;n;i++) A[i]=B[i]=0; for(int i=0;i&lt;na;i++) A[i]=a[i]; for(int i=0;i&lt;nb;i++) B[i]=b[i]; &#125; void ntt(int *a,int f)&#123; for(int i=0;i&lt;n;i++) if(i&lt;rev[i]) swap(a[i],a[rev[i]]); int w_n,w,u,v; for(int i=2;i&lt;=n;i&lt;&lt;=1)&#123; w_n=W[i][f==-1]; for(int j=0;j&lt;n;j+=i)&#123; w=1; for(int k=0;k&lt;i/2;k++)&#123; u=a[j+k]; v=1LL*a[j+i/2+k]*w%mod; a[j+k]=(u+v)%mod; a[j+i/2+k]=(u+mod-v)%mod; w=1LL*w*w_n%mod; &#125; &#125; &#125; if(f==1) return; for(int i=0;i&lt;n;i++) a[i]=1LL*a[i]*invn%mod; &#125; void calc()&#123; ntt(A,1); ntt(B,1); for(int i=0;i&lt;n;i++) A[i]=1LL*A[i]*B[i]%mod; ntt(A,-1); &#125; void calchh()&#123; ntt(A,1); ntt(B,1); for(int i=0;i&lt;n;i++) A[i]=(2LL*B[i]%mod+mod-1LL*A[i]*B[i]%mod*B[i]%mod)%mod; ntt(A,-1); &#125;&#125; vi mop,b,c,T;vi operator - (vi A,vi B)&#123; int n=A.size(),m=B.size(),fn=max(n,m); A.resize(fn); for(int i=0;i&lt;m;i++) add(A[i],-B[i]); return A;&#125;vi operator * (int a,vi A)&#123; int n=A.size(); a=(a+mod)%mod; for(int i=0;i&lt;n;i++) A[i]=1LL*a*A[i]%mod; return A;&#125;vi operator * (vi &amp;A,vi B)&#123; int n=A.size(),m=B.size(); NTT::init(n,m,A,B); NTT::calc(); A.resize(n+m-1); for(int i=0;i&lt;n+m-1;i++) A[i]=NTT::A[i]; return A;&#125;vi inverse(vi A)&#123; int n=A.size(); if(n==1)&#123; A[0]=pow(A[0],mod-2); return A; &#125; vi B=A; B.resize((n+1)/2); B=inverse(B); int m=B.size(); NTT::init(n,m,A,B,n+m-1+m-1); NTT::calchh(); B.resize(NTT::n); for(int i=0;i&lt;NTT::n;i++) B[i]=NTT::A[i]; //B=(2*B)-((A*B)*B); B.resize(n); return B;&#125;vi operator / (vi A,vi B)&#123; int n=A.size()-1,m=B.size()-1; vi C; if(n&lt;m)&#123; C.resize(1); C[0]=0; return C; &#125; reverse(A.begin(),A.end()); reverse(B.begin(),B.end()); B.resize(n-m+1); C=A*inverse(B); C.resize(n-m+1); reverse(C.begin(),C.end()); return C;&#125;void module(vi &amp;A,vi B)&#123; int n=A.size()-1,m=B.size()-1; if(n&lt;m) return; vi D=A/B; A=A-(B*D); A.resize(m);&#125;void ksm(int y)&#123; for(;y;y&gt;&gt;=1)&#123; if(y&amp;1)&#123; c=c*b; module(c,mop); &#125; b=b*b; module(b,mop); &#125;&#125;int main()&#123; NTT::build(); scanf("%d%d",&amp;n,&amp;k); n++; for(int i=1;i&lt;=k;i++) scanf("%d",&amp;h[i]),h[i]%=mod; for(int i=1;i&lt;=k;i++) scanf("%d",&amp;a[i]),a[i]%=mod; if(n&lt;=k)&#123;printf("%d\n",h[n]);return 0;&#125; mop.resize(k+1); mop[k]=1; for(int i=1;i&lt;=k;i++) mop[k-i]=(mod-a[i])%mod; b.resize(2); b[1]=1; c.resize(1); c[0]=1; ksm(n-1); int ans=0; c.resize(k); for(int i=0;i&lt;k;i++) add(ans,1LL*c[i]*h[i+1]%mod); printf("%d\n",ans); return 0;&#125; 参考资料]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Cayley-Hamilton定理</tag>
        <tag>常系数线性齐次递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[string]]></title>
    <url>%2F2018%2F01%2F19%2Fstring%2F</url>
    <content type="text"><![CDATA[Description 给你一个字符串S，你需要维护这个字符串S并支持两种操作： 1、在字符串S末尾插入一个字符。 2、记字符串T为字符串S从第 ll 个字符到第 rr 个字符所构成的子串。询问字符串T中最长的子串使得该子串在T中出现过至少两次（例如：T=”ababa”，最长的子串应为aba，长度为3），并输出它的长度。如果不存在这样的子串，则输出0。 Input 第一行为一个整数 online(0≤online≤1)online(0≤online≤1) ，在下文中用到该值。 第二行为一个字符串和一个整数m，分别表示原始的字符串（仅含小写字母）和操作个数。 记 lenlen 为字符串的长度（注意它会随时改变）。 记 lastanslastans 为上次询问的答案，初始为0。 接下来m行，每行一个操作： 若操作为”1 c”格式（c为字符），表示在字符串末尾新添一个字符。新增的字符为 (c−′a′+lastans×online) mod 26+′a′(c−′a′+lastans×online) mod 26+′a′ 若操作为”2 l r”格式，表示询问。记 l′=(l−1+lastans×online) mod len+1,r′=(r−1+lastans×online) mod len+1l′=(l−1+lastans×online) mod len+1,r′=(r−1+lastans×online) mod len+1 ，真正的询问区间为 [l′,r′][l′,r′] 。我们保证 1≤l′≤r′≤len1≤l′≤r′≤len （前提是你的lastans没有错）。 Solution 题目比较特殊，问的是出现至少两次，这样可以少考虑一点东西。 一个一个地加入字符，在加入到第$r$个字符的时候，回答$[l,r]$的询问。 用后缀自动机来维护字符串，对每一个状态，维护一个变量$right$表示该状态在字符串最后出现位置的右端点，每新加入一个字符$str_r$，设在后缀自动机上的新节点是$x$，那么在parent树上，$x$到根节点1的$right$都要更新为$r$。这个操作用LCT维护parent树实现。 我们发现，在更新$right$的时候，旧的$right$被赋值成了新的$r$，但其实$right$和$r$其实刚好代表了这个状态在字符串中最后出现的两个位置。记该状态的最长后缀长度是$len$（后缀自动机里面的$len$)，那么对于$r$时间点的所有询问，用$len$更新$l$在$[1,right-len+1)$的询问；用$right-l+1$更新$l$在$[right-len+1,right]$的询问，由于询问的时候$-l+1$是固定的，所以用$right$更新就好了，查询的时候$-l+1$。以上两个操作用两棵线段树记录。 我们发现这样更新好像忽略了很多情况，但为什么可以这样更新呢？对于同一个状态，虽然它们可能会相同地在字符串中重复很多次，但是如果我们用最右边的$right$更新，是可以覆盖到所有其他位置的更新操作的，所以用最右边的$right$来更新即可。 但是这样依然不够快，有可能$x$到根节点的路径比较长，这怎么办呢？ 这里有个巧合：lct中，在同一条重链里面的状态，它们的$right$是相同的，因为这是维护时候自然体现的嘛。 我们发现可以用一条重链里面$len$最大的状态来代表这条链中所有的状态，按照上面说的方法更新，因为它一定能覆盖其他状态的更新。 题目要求动态加入，那么把线段树可持久化。对于询问$[l,r]$，在$r$的时间点查询就好。 Tips LCT的access操作不可调用，因为这样会破坏”同一条链的$right$相同的性质”，恰好连边和删边比较好做，是树上的，特殊写一下，具体见代码，真的调了好久…… 对于更新操作，重写一个access操作来实现，大框架是一样的，但是注意要先断开，再更新，再连接；而不是像原版access直接换右儿子。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N=400005;int online,n,_n,m,ans;char str[N];inline void swap(int &amp;x,int &amp;y)&#123;int t=x;x=y;y=t;&#125;inline int max(int x,int y)&#123;return x&gt;y?x:y;&#125;inline int rd()&#123; char c=getchar(); int x=0,f=1; while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while('0'&lt;=c&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;inline void write(int x)&#123; if(x&gt;9) write(x/10); putchar('0'+(x%10));&#125;struct SegmentTree&#123; int rt[N*2*19],sz,ch[N*2*19][2],maxs[N*2*19],tm[N*2*19],tmcnt; void step()&#123;tmcnt++;&#125; void insert(int u1,int &amp;u2,int l,int r,int L,int R,int val)&#123; if(L&gt;R) return; if(!u2) u2=copy(u1); else if(tm[u2]!=tmcnt) u2=copy(u1); if(L&lt;=l&amp;&amp;r&lt;=R)&#123; maxs[u2]=max(maxs[u2],val); return; &#125; int mid=l+r&gt;&gt;1; if(L&lt;=mid) insert(ch[u1][0],ch[u2][0],l,mid,L,R,val); if(mid&lt;R) insert(ch[u1][1],ch[u2][1],mid+1,r,L,R,val); &#125; int query(int u,int l,int r,int pos,int ret)&#123; if(!u) return ret; ret=max(ret,maxs[u]); if(l==r) return ret; int mid=l+r&gt;&gt;1; if(pos&lt;=mid) return query(ch[u][0],l,mid,pos,ret); else return query(ch[u][1],mid+1,r,pos,ret); &#125; inline int copy(int u)&#123; int v=++sz; maxs[v]=maxs[u]; tm[v]=tmcnt; ch[v][0]=ch[u][0]; ch[v][1]=ch[u][1]; return v; &#125;&#125;seg1,seg2;struct Lct&#123; int rev[N*2],ch[N*2][2],fa[N*2],val[N*2],tag[N*2],len[N*2],lenmax[N*2]; inline bool isroot(int u)&#123;return ch[fa[u]][0]!=u&amp;&amp;ch[fa[u]][1]!=u;&#125; inline int who(int u)&#123;return ch[fa[u]][1]==u;&#125; inline void update(int u)&#123; lenmax[u]=max(len[u],max(lenmax[ch[u][0]],lenmax[ch[u][1]])); &#125; inline void reverse(int u)&#123; rev[u]^=1; swap(ch[u][0],ch[u][1]); &#125; inline void maketag(int u,int x)&#123; tag[u]=x; val[u]=x; &#125; inline void rotate(int u)&#123; int f=fa[u],g=fa[f],c=who(u); if(!isroot(f)) ch[g][who(f)]=u; fa[u]=g; ch[f][c]=ch[u][c^1]; if(ch[f][c]) fa[ch[f][c]]=f; ch[u][c^1]=f; fa[f]=u; update(f); update(u); &#125; inline void pushdown(int u)&#123; if(rev[u])&#123; if(ch[u][0]) reverse(ch[u][0]); if(ch[u][1]) reverse(ch[u][1]); rev[u]=0; &#125; if(tag[u])&#123; if(ch[u][0]) maketag(ch[u][0],tag[u]); if(ch[u][1]) maketag(ch[u][1],tag[u]); tag[u]=0; &#125; &#125; inline void pd(int u)&#123; if(!isroot(u)) pd(fa[u]); pushdown(u); &#125; inline void splay(int u)&#123; pd(u); for(;!isroot(u);rotate(u)) if(!isroot(fa[u])) rotate(who(fa[u])==who(u)?fa[u]:u); &#125; inline void link(int a,int b)&#123; splay(a); fa[a]=b; &#125; inline void cut(int a)&#123; splay(a); if(ch[a][0])&#123; fa[ch[a][0]]=fa[a]; //!!! ch[a][0]=0; update(a); &#125; else fa[a]=0; &#125; inline int query(int u)&#123; pd(u); return val[u]; &#125; void access_special(int u,int nval)&#123; int v; for(v=0;u;v=u,u=fa[u])&#123; splay(u); ch[u][1]=0; update(u); //!!! int r2=val[u],maxlen=lenmax[u]; if(r2&amp;&amp;maxlen)&#123; seg1.insert(seg1.rt[nval-1],seg1.rt[nval],1,_n+m,1,r2-maxlen,maxlen); seg2.insert(seg2.rt[nval-1],seg2.rt[nval],1,_n+m,r2-maxlen+1,r2,r2); &#125; ch[u][1]=v; update(u); &#125; maketag(v,nval); &#125;&#125;lct;struct Sam&#123; int last,sz,len[N*2],trans[N*2][26],link[N*2]; void init()&#123; last=sz=1; len[1]=link[1]=0; &#125; void expand(int c)&#123; int u=++sz,p=last; len[u]=len[p]+1; lct.len[u]=len[u]; for(;p&amp;&amp;!trans[p][c];p=link[p]) trans[p][c]=u; if(!p) link[u]=1,lct.link(u,1); else&#123; int q=trans[p][c]; if(len[q]==len[p]+1) link[u]=q,lct.link(u,q); else&#123; int v=++sz; len[v]=len[p]+1; lct.len[v]=len[v]; lct.val[v]=lct.query(q); for(int i=0;i&lt;26;i++) trans[v][i]=trans[q][i]; lct.cut(q); lct.link(q,v); lct.link(u,v); lct.link(v,link[q]); link[v]=link[q]; link[q]=link[u]=v; for(;trans[p][c]==q;p=link[p]) trans[p][c]=v; &#125; &#125; last=u; &#125;&#125;sam;inline void addchar(int c)&#123; n++; sam.expand(c); seg1.rt[n]=seg1.rt[n-1]; seg2.rt[n]=seg2.rt[n-1]; seg1.step(); seg2.step(); lct.access_special(sam.last,n);&#125;inline int query(int l,int r)&#123; int ret=0; ret=max(ret,seg1.query(seg1.rt[r],1,_n+m,l,0)); ret=max(ret,seg2.query(seg2.rt[r],1,_n+m,l,0)-l+1); return ret;&#125;int main()&#123; freopen("input.in","r",stdin); online=rd(); scanf("%s",str+1); n=strlen(str+1); m=rd(); _n=n; n=0; sam.init(); for(int i=1;i&lt;=_n;i++) addchar(str[i]-'a'); int opt,x,y; char inp[2]; for(int i=1;i&lt;=m;i++)&#123; opt=rd(); if(opt==1)&#123; scanf("%s",inp); inp[0]=(inp[0]-'a'+ans*online)%26+'a'; addchar(inp[0]-'a'); &#125; else&#123; x=(rd()-1+ans*online)%n+1; y=(rd()-1+ans*online)%n+1; write(ans=query(x,y)); putchar('\n'); &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[链上求和]]></title>
    <url>%2F2018%2F01%2F13%2F%E9%93%BE%E4%B8%8A%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[Solution​ 对于每一条链，如果把权值从大到小拿出来排个序，记为$a1,a_2…a_n$ ，那么这条链对答案的贡献为：$\sum{i=1}^n\sum{j=1}^ia_j=\sum{i=1}^n a_i*(n-i+1)$。每一个值$a$，被计算的次数等于小于$a$的数的数量加1。 ​ 由于每个点贡献次数和路径上权值小于它的节点有关，现在对所有点按照权值由小到大排序，一个一个地加入并计算每一个点$x$在树中所有链中的贡献次数$time$，对答案的贡献即$a_x*time$。 ​ 考虑经过$x$的路径]]></content>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3309】DZY Loves Math]]></title>
    <url>%2F2018%2F01%2F07%2F%5BBZOJ3309%5D%2F</url>
    <content type="text"><![CDATA[Description 对于正整数n，定义f(n)为n所含质因子的最大幂指数。例如f(1960)=f(2^3 5^1 7^2)=3, f(10007)=1, f(1)=0 给定正整数a,b，求$\sum{i=1}^a \sum{j=1}^b f(gcd(i,j))$ $T&lt;=10000\;\;1&lt;=a,b&lt;=10^7$ Solution \begin{aligned} ans&=\sum_{i=1}^a\sum_{j=1}^bf(gcd(i,j))\\ &=\sum_{x=1}^{min(n,m)}f(x)*sum(x) &sum(x)为x=gcd(i,j)的(i,j)对数，满足i和j在a和b范围内\\ &=\sum_{x=1}^{min(n,m)}f(x)\sum_{x|d}\mu(\frac dx)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor\\ &=\sum_{x=1}^{min(n,m)}f(x)\sum_{k=1}^{\lfloor min(n,m)/x\rfloor}\mu(k)\lfloor\frac n{kx}\rfloor\lfloor\frac m{kx}\rfloor\\ &=\sum_{T=1}^{min(n,m)}\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor\sum_{d|T}f(d)\mu(\frac Td)\\ &=\sum_{T=1}^{min(n,m)}\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor g(T) &令g(x)=\sum\limits_{d|x}f(d)\mu(\frac xd) \end{aligned} 现在关键是求解$g$函数，完事后求$g$的前缀和，一样分块求$ans$. 当$x$为质数时，$g(x)=f(1)\mu(x)+f(x)\mu(1)=0+1=1$ 当筛到$x=p*i$时，分解质因数$x=p_1^{q_1}p_2^{q_2}…p_k^{q_k}$，$\frac xd=p_1^{a_1}p_2^{a_2}…p_k^{a_k}$，显然$a_i=0或1$，才能对$g(x)$有贡献，不然$\mu({\frac xd})=0$. 现在只考虑满足$a_i=0或1$的因数$d$ \begin{aligned} g(x)&=\sum_{d|x}f(d)\mu(\frac xd)\\ &=f(x)\sum_{d|x且f(d)=f(x)} \mu(\frac xd)+[f(x)-1]\sum_{d|x且f(d)\ne f(x)}\mu(\frac xd)\\ &=-\sum_{d|x且f(d)\ne f(x)}\mu(\frac xd) \end{aligned} 要满足$f(d)\ne f(x)$，所有$q_i=f(x)$的$p_i$的指数在$d$中都要变成$q_i-1$. 如果所有$q_i=f(x)$，那么$a_i$全部取1，则$g(x)=-\mu(p_1p_2…p_k)=-(-1)^k=(-1)^{k+1}$,这里有个特殊情况，如果$i$为$p$的完全平方数，即$i=p^{a_i}$，（这里的$a$是最后提到的那个$a$数组），那么$x=p^{a_i+1}$,则$g(x)=-\mu(p)=1$ 否则若存在$q_i\ne f(x)$，$g(x)=0$. 记$A={i\mid q_i=f(x)},B={i\mid q_i\ne f(x)}$. 对于$A$中的$i$，$a_i$必须取1，而$B$中的$a_i$取0或1都可以，那么 \begin{aligned} g(x)&=-\sum\mu((\prod_{i\in A}p_i)*(\prod_{j\in B}(p_j或1))\\ &=-\mu(\prod_{i\in A}p_i)\sum\mu(\prod_{j\in B}(p_j或1))\\ &=-(-1)^{|A|}*0&\prod_{i\in B}(p_j或1)有奇数个质数和偶数个质数的情况次数一样，正负抵消\\ &=0 &大快人心 \end{aligned} 线性筛时，维护一个$ai$表示$i$的最小质因子$p{min}$的指数，$bi$表示$p{min}^{a_i}$. 由于每次循环的$p$都是$x$的最小质因子，故每次更新时比较$a_i$和$a_x$是否相同，如果相同就更新，如果不相同直接等于0，这样就可以保证每一个数$x$如果存在质因子指数不同的情况，$g(x)$立即等于0. 详情见代码. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=1e7+1;int vis[N],lis[N],cnt;ll g[N],a[N],b[N];inline void swap(int &amp;x,int &amp;y)&#123;int t=x;x=y;y=t;&#125;inline int min(int x,int y)&#123;return x&lt;y?x:y;&#125;void init()&#123; for(int i=2;i&lt;N;i++)&#123; if(!vis[i])&#123; lis[++cnt]=i; a[i]=1; b[i]=i; g[i]=1; &#125; for(int j=1;j&lt;=cnt&amp;&amp;i*lis[j]&lt;N;j++)&#123; int x=i*lis[j],p=lis[j]; vis[x]=1; if(i%p==0)&#123; //d是i去除p后的数，i=d*p^ai, x=d*p^(ai+1) 故ax=ai+1,bx相应乘上p a[x]=a[i]+1; b[x]=b[i]*p; int d=i/b[i]; if(d==1) g[x]=1; //特殊情况（边界情况）i是p的幂 else g[x]=(a[x]==a[d])?-g[d]:0; //若x满足所有指数相同，g(x)=g(d)乘上-1，否则为0 break; &#125; a[x]=1; b[x]=p; g[x]=a[i]==1?-g[i]:0; //原理同上 &#125; &#125; for(int i=2;i&lt;N;i++) g[i]+=g[i-1];&#125;int main()&#123; freopen("input.in","r",stdin); init(); int T,a,b; ll ans; scanf("%d",&amp;T); while(T--)&#123; scanf("%d%d",&amp;a,&amp;b); if(a&gt;b) swap(a,b); ans=0; for(int i=1,j;i&lt;=a;i=j+1)&#123; j=min(a/(a/i),b/(b/i)); ans+=1LL*(a/i)*(b/i)*(g[j]-g[i-1]); &#125; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BZOJ3529】【SDOI2014】数表]]></title>
    <url>%2F2018%2F01%2F07%2F%5BBZOJ3529%5D%5BSDOI2014%5D%E6%95%B0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Description 有一张$n×m$的数表，其第i行第j列（$1 \le i \leq n，1 \le j \le m$）的数值为能同时整除$i$和$j$的所有自然数之和。给定$a$，计算数表中不大于$a$的数之和。 Solution 先忽略$a$的条件。 令$f(n)$表示$n$的所有约数之和, $sum(x)$表示$x=gcd(i,j),1\le i \le n且1\le j \le m$的数对数量. 按照之前的反演，$sum(x)=\sum\limits_{x\mid d}\mu(\frac dx)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor$ \begin{aligned} ans&=\sum_{i=1}^n\sum_{j=1}^m\sum_{d|i且d|j}d\\ &=\sum_{i=1}^n\sum_{j=1}^mf(gcd(i,j))\\ &=\sum_{d=1}^{min(n,m)}f(d)sum(d)\\ &=\sum_{d=1}^{min(n,m)}f(d)\sum_{x|d}\mu(\frac dx)\lfloor\frac nd\rfloor\lfloor\frac md\rfloor\\ &=\sum_{d=1}^{min(n,m)}f(d)\sum_{k=1}^{\lfloor min(n,m)/d\rfloor}\mu(\frac {kx}x)\lfloor\frac n{kx}\rfloor\lfloor\frac m{kx}\rfloor\\ &=\sum_{T=1}^{min(n,m)}\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor\sum_{d|T}f(d)\mu(\frac Td)\\ &=\sum_{T=1}^{min(n,m)}\lfloor\frac nT\rfloor\lfloor\frac mT\rfloor g(T) &令g(x)=\sum_{d|x}f(d)\mu(\frac xd) \end{aligned} 其实$g(x)$是可以暴力求解的…因为$x$的因数个数不是很多。但是我们不能直接算完，因为有$a$的限制。由此要引入树状数组。 回头看$a$的条件，从第三行等式来看，只有$d\leq a$的$f(d)$才能有贡献。 我们用一个树状数组来维护$g(x)$的前缀和，那么对于询问，按照$a$排序，将所有$x\le a$的$f(x)$，枚举$x\mid y$的$y$，更新$g(y)+=f(x)\mu(\frac yx)$。 这样按照分块的套路求解$ans$即可. $f$函数求解 $f(x)=\sum\limits_{d\mid x}d$ $f(x)​$是积性函数，可以用线性筛求解： $x$是质数时，$f(x)=1+x$ 循环$i$与$p$筛到$x$， $x$=$p*i$. 若$i\nmid p$，则$i$与$p$互质，那么$f(x)=f(i)f(p)=f(i)*(p+1)$. 若$i\mid p$，记$i$去除所有$p$因子后的数为$a$. 则$f(x)=f(i)*p+f(a)$. 记$i=p1^{q_1}p_2^{q_2}…p_k^{q_k}$，则$x=p_1^{q_1}p_2^{q_2}…p{loc}^{q{loc}+1}…p_k^{q_k}$，$a=p_1^{q_1}..p{loc-1}^{q{loc-1}}p{loc+1}^{q{loc}+1}…p_k^{q_k}$.不严谨地，这里$p{loc}$和$q_{loc}$分别代表的是$p$，与$p$在质因数分解中的指数。 \begin{aligned} f(i)*p&=(1+p1+...+p1^{q1})...(1+p_{loc}+...+p_{loc}^{q_{loc}})...(1+p_k+...+p_k^{q_k})*p\\ &=(p_{loc}+p_{loc}^2+..+p_{loc}^{q_{loc}+1})f(a)\\ \therefore f(i)*p&+f(a)=(1+p_{loc}+p_{loc}^2+...+p_{loc}^{q_{loc}+1})f(a)=f(x) \end{aligned}]]></content>
      <categories>
        <category>BZOJ</category>
      </categories>
      <tags>
        <tag>数论---莫比乌斯反演</tag>
      </tags>
  </entry>
</search>
