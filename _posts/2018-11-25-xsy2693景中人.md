---
layout: post
mathjax: true
title: 景中人
date: 2018-11-25-18:10:00
tag: [方案特征,DP,记忆化搜索,好题]
category: 2018冬令营模拟测试赛
---
* content
{:toc}
# Description

　　在二维坐标系的第一象限有$n$个整点$(x,y)$

　　求最少需要使用多少个面积不超过$S$的、下底边紧贴$x$轴的矩形，才能覆盖所有整点？

　　本题有多组数据，数据组数为$T$

　　$T \le 10,\ n \le 100,\ x \le 3*10^6,\  1\le y \le S \le 2*10^5$



# Solution

　　首先，对于横坐标相同的点，显然只有纵坐标最大的点是必要的，其余的点显然可以删去

　　考虑最优解中任意两个矩形的性质：

* 不存在一个矩形完全包含另一个矩形的情况
* 若一个矩形的横坐标包含另一个矩形的横坐标、或两个矩形完全相离：无特殊性质
* 若两个矩形的横坐标相交：我们完全可以将两个矩形相交的部分向两端拨开，简化方案

　　所以总是存在这样一个最优解，满足所有矩形横坐标范围之间的关系只有相离或内含，也就是父子关系构成一棵树

　　离散化纵坐标并去除冗余点，按横坐标排序后，可以通过下标直接作为横坐标的离散化

　　我们考虑一个DP：$f_{l,r}$表示覆盖第$l$个横坐标到第$r$个横坐标的最高点所需的最少矩形数

　　转移如下：

1. $[l,r]$可能由多个不相交的矩形（即有多个后继）共同完成，我们枚举分界点$mid$，用$f_{l,mid}+f_{mid+1,r}$更新
2. $[l,r]$只有一个矩形（只有一个后继），这个矩形的横坐标必然是$[l,r]$（如不是，则该情况属于1.），贪心地想，这个矩形必然是越高越好，因此我们可以算出最高高度为$\lfloor\frac S{r-l}\rfloor$，用$[该矩形下方有关键点]+f_{l,r}$更新

　　此时，我们发现状态表示出了问题：状态并没有体现高度。所以我们必须多加一维：设$f_{l,r,h}$表示：覆盖$[l,r]$范围内的、高度不超过$h$的关键点最少需要多少矩形，则转移变为：

$$
f_{l,mid,h}+f_{mid+1,r,h}\rightarrow f_{l,r,h}\\
[\frac S{r-l}及以下、h及以上还有未被覆盖的关键点]+f_{l,r,\frac S{r-l}+1}\rightarrow f_{l,r,h}
$$

　　由于转移顺序比较难考虑，使用记忆化搜索实现即可



# Code

```c++
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int INF=1e9;
const int N=110;
const int S=200010;
int n,s;
struct Point{
    int x,y;
}a[N];
inline void applyMin(int &x,int y){
    if(y<x)
        x=y;
}
void readData(){
    scanf("%d%d",&n,&s);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&a[i].x,&a[i].y);
}
bool cmpXY(const Point &a,const Point &b){
    if(a.x!=b.x)
        return a.x<b.x;
    return a.y>b.y;
}
int d[N],dcnt;
int diz[S];
bool g[N][N][N];
void init(){
    sort(a+1,a+1+n,cmpXY);
    int cnt=0;
    for(int i=1,j;i<=n;i=j){
        a[++cnt]=a[i];
        for(j=i;j<=n&&a[j].x==a[i].x;j++);
    }
    n=cnt;
    dcnt=0;
    for(int i=1;i<=n;i++)
        d[++dcnt]=a[i].y;
    sort(d+1,d+1+dcnt);
    dcnt=unique(d+1,d+1+dcnt)-d-1;
    for(int i=0;i<dcnt;i++)
        for(int j=d[i];j<d[i+1];j++) diz[j]=i;
    for(int j=d[dcnt];j<S;j++) diz[j]=dcnt;
    for(int i=1;i<=n;i++)
        a[i].y=lower_bound(d+1,d+1+dcnt,a[i].y)-d;
    for(int l=1;l<=n;l++){
        for(int r=l;r<=n;r++){
            for(int h=1;h<=dcnt;h++) g[l][r][h]=g[l][r-1][h];
            g[l][r][a[r].y]=true;
            for(int h=1;h<=dcnt;h++) g[l][r][h]|=g[l][r][h-1];
        }
    }
}
int f[N][N][N];
int dp(int l,int r,int h){
    if(h>dcnt)
        return 0;
    if(f[l][r][h]!=-1)
        return f[l][r][h];
    int res=INF;
    if(l==r)
        res=(h<=a[l].y);
    else{
        int maxh=s/(a[r].x-a[l].x);
        if(diz[maxh]>=h){
            maxh=diz[maxh];
            res=g[l][r][maxh]+dp(l,r,maxh+1);
        }
        for(int mid=l;mid<r;mid++)
            applyMin(res,dp(l,mid,h)+dp(mid+1,r,h));
    }
    return f[l][r][h]=res;
}
int main(){
    int cases;
    scanf("%d",&cases);
    for(int i=1;i<=cases;i++){
        readData();
        init();
        memset(f,-1,sizeof f);
        printf("%d\n",dp(1,n,1));
    }
    return 0;
}
```

