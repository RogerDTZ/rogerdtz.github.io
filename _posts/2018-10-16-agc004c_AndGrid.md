---
layout: post
mathjax: true
title: 【AGC004C】AND Grid
date: 2018-10-16-15:16:00
tag: [构造,可做未做]
category: 2017国家集训队作业
---
* content
{:toc}
# Description

　　给一个$n\times m$的网格，每个格子都是#或者一个点$.$

　　请你构造出另外两张$n\times m$的网格，满足：

* 原网格上有#的位置，另外两张的相应位置都必须要有
* 原网格上没有#的位置，另外两张的相应位置不能都有
* 两张新网格的#构成恰好一个连通块

　　我们保证原网格的边界没有#

　　请输出一个合法方案

　　$3 \le n,m \le 500$



# Solution

　　注意到题目保证的性质——原网格的最外围一圈都是空的。既然这么特别地提出来了，肯定要利用这个性质带来的机会

　　原来想的是：一张图填满最外边一圈，然后每个#在填完自己后，向最近的边界一直拉；另一张图就填满剩下的部位。这样的做法的保证是第一张图的填法不可以切割整张图，然而实际上这种情况的确会发生。

　　难道又要什么费用流？这个“安排走线”的做法太过玄学，考虑一种人为规定的、有规律的填法

　　既然要求所有#构成一个连通块，我们像第一个思路一样，尝试先把所有#连到一个中枢一样的存在。中枢放在地图中间肯定很难想，我们不妨题目给出的性质，将最左一列作为第一张图的中枢，最右一列作为第二张图的中枢

　　剩下的问题就是，怎么在不重复使用某一个格的情况下，将每个#在两张图中都连到最左一列和最右一列。最直接的想法就是对于每一个#，在一张图向左一直连，在另一张图向右一直连，但这样会冲突。一种巧妙的做法是，第一张图将奇数行填满，第二张图将偶数行填满（除了最左和最右两列）。可以发现，在这种涂色方案下，每个#要么通过同一行到达中枢，要么通过上边或者下边与它贴着的一行到达中枢，即每张图的每个元素都是连通的，因此这是一种合法方案



# Summary

　　对于构造题，决策太多、感觉要考虑的东西很多、想法太杂，不妨往某些有规律的、形式简单的方案上想



# Code

```c++
#include <cstdio>
using namespace std;
const int N=510;
int n,m;
char a[N][N];
void readData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
}
void print(){
    for(int i=1;i<=n;i++,puts("")){
        putchar('#');
        for(int j=2;j<m;j++)
            if(a[i][j]=='#') putchar('#');
            else putchar((i&1)?'#':'.');
        putchar('.');
    }
    puts("");
    for(int i=1;i<=n;i++,puts("")){
        putchar('.');
        for(int j=2;j<m;j++)
            if(a[i][j]=='#') putchar('#');
            else putchar(!(i&1)?'#':'.');
        putchar('#');
    }
}
int main(){
    readData();
    print();
    return 0;
}
```

 