---
layout: post
mathjax: true
title: 【AGC001C】Squared Graph
date: 2018-09-29-15:11:00
tag: [转化,计数问题,分类讨论]
category: 2017国家集训队作业
---
* content
{:toc}
# Description

　　有一个$n$个点的无向图，这个图中有$m$条边$(u_i,v_i)$且无自环或重边

　　高桥君现在要用这个图构建一个有$n^2$个点的新图，新图中的每个节点的编号为有序数对$(a,b)(1\leq a,b\leq n)$

　　新图的边按照以下规则生成

　　点$(a,b)$和点$(a',b')$有边当且仅当原图中存在边$(a,a'),(b,b')$

　　那么新图中有多少个联通块呢

　　$ 2\le n \le 10^5$

　　$0 \le m \le 2 * 10^5$



# Solution

　　又是这种组织概念的玄乎题

　　每一个新的点都由两个点组成。我们可以考虑将原图复制一份出来，记为$A$和$B$。那么每一个新点就可以实体化为在$A$上的某个点$a$和在$B$上的某个点$b$组成的点对，或者说叫一个状态$(a,b)$

　　那么$(a,b)$能直接走到$(a',b')$，当且仅当在$A$中$a$和$a'$有边直接相邻、在$B$中$b$和$b'$有边直接连接

　　关键的一步扩展：$(a,b)$能走到$(a',b')$，当且仅当$a$走到$a'$的某条路径长度奇偶性与$b$走到$b'$的某条路径长度奇偶性相同？为什么？先往那边走，如果有一者先到达了终点，那么它可以来回在终点折返；由于奇偶性相同，某个时刻它折返回终点时另一者也会到达

　　由于新点的移动和单点的移动有一定关系，因此单点移动的范围是比较关键的划分。单点移动的范围即其所处连通块，我们考虑每个单点处在的连通块的特征

　　现在考虑如何把这些抽象的“点”的连通块刻画出来：只要从某个状态出发遍历足够多的情况，就可以遍历完其所在的整个连通块

　　所以当下我们考虑某一个点对$(a,b)$能走到其他哪一些点对

　　首先，如果$a$或$b$某一个点是一个单点，此时另一个点不论所处情况如何，点对$(a,b)$都根本走不动。因此只要一个点对中某一个点为孤立点，那么这个点对在新图上也是孤立的

　　单点考虑完毕，我们去除掉它们。下面考虑的$a$和$b$的所处位置都不是单点

　　由于上述提到长度奇偶性相同就可以互达的结论，可联想到二分图，我们将连通块按是否为二分图来分类

　　如果$a$和$b$都处于某个二分图中，不妨记两个二分图的两部分分别为$L_a,R_a,L_b,R_b$，则我们发现$(L_a,L_b)\cup(R_a,R_b)$这些全部可以互达，因为这些点对的两点对应路径的长度奇偶性都一样；同理$(L_a,R_b)\cup (L_b,R_a)$也是。这两个点集已经覆盖了当下所有点对，因此这种情况会贡献恰好2个连通块。

　　如果只有某一个处于二分图中，则没有这个性质；但结论是两点分别在两个连通块内的所有点对都属于一个连通块。因为一旦某一个图不是二分图，就意味着存在奇环，即存在调整路径长度奇偶性的机会。这个结论保证了任意两点都可以互达。这种情况会贡献1个连通块

　　记原图单点数量为$a$，非二分图连通块数量为$b$，二分图连通块数量为$c$，总点数为$n$

　　则答案为

$$
a^2+2a(n-a)\\
+
\\c^2+2cb+2b^2
$$

# Summary

　　如果新元素是由原本的元素组成二元组、或者其他形式得到，尝试通过复制等方式迎合这个概念，构造出一个具体的模型、或者思考角度

　　图上玄学计数，一般是分类讨论搞出来的，存在一些结论可以归并大部分情况。一般都是对某个性质分类，比如此题的是不是二分图

　　之所以联想到二分图，是因为点对互达的条件是二者对应点路径长度奇偶性相同。这要求我们联想到二分图上，处于某一种出发状态的两点走来走去路径长度奇偶性始终相同、且到达位置的情形和出发点类似这一个特征

# Code

```c++
#include <cstdio>
using namespace std;
typedef long long ll;
const int N=100010,M=200010;
int n,m;
int h[N],tot;
struct Edge{
	int v,next;
}e[M*2];
bool vis[N];
int col[N];
bool flag;
// sum
ll single,nobi,bi;
void addEdge(int u,int v){
	e[++tot]=(Edge){v,h[u]}; h[u]=tot;
	e[++tot]=(Edge){u,h[v]}; h[v]=tot;
}
void readData(){
	scanf("%d%d",&n,&m);
	int u,v;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		addEdge(u,v);
	}
}
void paint(int u){
	vis[u]=true;
	if(!h[u])
		throw 0;
	for(int i=h[u],v;i;i=e[i].next){
		v=e[i].v;
		if(!vis[v]){
			col[v]=(col[u]^1);
			paint(v);
		}
		else if((col[u]^col[v])!=1)
			flag=false;
	}
}
void calcNum(){
	for(int u=1;u<=n;u++)
		if(!vis[u]){
			try{
				flag=true;
				paint(u);
			}
			catch(int e){
				single++;
				continue;
			}
			if(flag)
				bi++;
			else
				nobi++;
		}
}
int main(){
	readData();
	calcNum();
	printf("%lld\n",(single*single+2*single*(n-single))+nobi*nobi+2*nobi*bi+2*bi*bi);
	return 0;
}
```


