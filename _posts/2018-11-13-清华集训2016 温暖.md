---
layout: post
mathjax: true
title: 【清华集训2016】温暖会指引我们前行
date: 2018-11-13-15:05:00
tag: [最小生成树,数据结构---动态树]
category: 清华集训
---
* content
{:toc}
# Description

　　给一张无向图，已经有$n$个点，请顺序支持$m$次操作，每次操作都是以下三种中的某一种：

* 加入一条温度为$t$、长度为$l$的无向边
* 更改某一条已加入的无向边的长度$l$
* 给出$x$和$y$，询问从$x$走到$y$的关于$t$字典序最大的路径的长度是多少（字典序定义有更改，如果$A$是$B$的前缀反而$A$更大）

　　$n\le 10^5,\ m\le 3*10^5$

# Solution

　　一看就感觉很玄乎，图上询问路径，还要找到字典序最大的路径

　　联系之前总结的经验，图上路径最值问题，想一想最小生成树：考虑任意两点在最大生成树上的路径是否一定是我们要定位的路径，经过简单感受和推理发现其的确是字典序最大的路径

　　于是我们直接用LCT维护最大生成树，支持查询两点距离即可

　　没想太多直接看题解去了，后来才发现这道题是T1，如果是场上的话可能可以逼迫自己做出来，毕竟写过相关总结；不过现在做散题时联想经验的意识会相对薄弱，需要纠正态度

　

# Code

```
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
const int INF=1e9;
const int N=100010,M=300010;
int n,m;
int record[M][2];
int temwho[M];
namespace LCT{
    const int S=N+M;
    int ch[S][2],fa[S];
    int rev[S];
    int tem[S],minTem[S];
    LL val[S],sum[S];
    inline bool isRoot(int u){
        return ch[fa[u]][0]!=u&&ch[fa[u]][1]!=u;
    }
    inline int who(int u){
        return ch[fa[u]][1]==u;
    }
    inline void pushup(int u){
        minTem[u]=(u>n)?tem[u]:INF;
        sum[u]=val[u];
        if(ch[u][0]){
            minTem[u]=min(minTem[u],minTem[ch[u][0]]);
            sum[u]+=sum[ch[u][0]];
        }
        if(ch[u][1]){
            minTem[u]=min(minTem[u],minTem[ch[u][1]]);
            sum[u]+=sum[ch[u][1]];
        }
    }
    inline void reverse(int u){
        rev[u]^=1;
        swap(ch[u][0],ch[u][1]);
    }
    inline void pushdown(int u){
        if(rev[u]){
            if(ch[u][0])
                reverse(ch[u][0]);
            if(ch[u][1])
                reverse(ch[u][1]);
            rev[u]=0;
        }
    }
    void pd(int u){
        if(!isRoot(u))
            pd(fa[u]);
        pushdown(u);
    }
    inline void rotate(int u){
        int f=fa[u],g=fa[f],c=who(u);
        if(!isRoot(f))
            ch[g][who(f)]=u;
        fa[u]=g;
        ch[f][c]=ch[u][c^1];
        if(ch[f][c])
            fa[ch[f][c]]=f;
        ch[u][c^1]=f;
        fa[f]=u;
        pushup(f);
        pushup(u);
    }
    inline void splay(int u){
        pd(u);
        for(;!isRoot(u);rotate(u))
            if(!isRoot(fa[u]))
                rotate(who(u)==who(fa[u])?fa[u]:u);
    }
    inline void access(int u){
        for(int v=0;u;v=u,u=fa[u]){
            splay(u);
            ch[u][1]=v;
            pushup(u);
        }
    }
    inline void makeRoot(int u){
        access(u);
        splay(u);
        reverse(u);
    }
    bool isConnect(int a,int b){
        makeRoot(a);
        access(b);
        splay(b);
        return fa[a]!=0;
    }
    void link(int a,int b){
        makeRoot(a);
        fa[a]=b;
    }
    void cut(int a,int b){
        makeRoot(a);
        access(b);
        splay(b);
        ch[b][0]=fa[a]=0;
        pushup(b);
    }
    void addNewEdge(int id,int u,int v,int t,int l){
        id+=(n+1);
        tem[id]=t;
        temwho[t]=id;
        val[id]=l;
        if(!isConnect(u,v)){
            link(u,id);
            link(id,v);
        }
        else{
            makeRoot(u);
            access(v);
            splay(v);
            int x=temwho[minTem[v]];
            if(t>minTem[v]){
                cut(record[x-(n+1)][0],x);
                cut(x,record[x-(n+1)][1]);
                link(u,id);
                link(id,v);
            }
        }
    }
    LL query(int a,int b){
        if(a==b)
            return 0;
        if(!isConnect(a,b))
            return -1;
        makeRoot(a);
        access(b);
        splay(b);
        return sum[b];
    }
    void modifyEdge(int id,int l){
        id+=(n+1);
        splay(id);
        val[id]=l;
        pushup(id);
    }
}
void answerQuery(){
    scanf("%d%d",&n,&m);
    static char opt[10];
    int id,u,v,t,l;
    for(int i=1;i<=m;i++){
        scanf("%s",opt);
        if(opt[0]=='f'){
            scanf("%d%d%d%d%d",&id,&u,&v,&t,&l);
            u++; v++;
            record[id][0]=u; record[id][1]=v;
            LCT::addNewEdge(id,u,v,t,l);
        }
        else if(opt[0]=='m'){
            scanf("%d%d",&u,&v);
            u++; v++;
            printf("%lld\n",LCT::query(u,v));
        }
        else{
            scanf("%d%d",&id,&l);
            LCT::modifyEdge(id,l);
        }
    }
}
int main(){
    answerQuery();
    return 0;
}
```

