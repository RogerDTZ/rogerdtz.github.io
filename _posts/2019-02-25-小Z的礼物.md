---
layout: post
mathjax: true
title: 小Z的礼物
date: 2019-02-25-19:17:00
tag: [容斥原理---Min-Max,DP---轮廓线DP]
category: [2018集训队作业]
---
* content
{:toc}
# Description

　　有一个$N \times M$的网格图，其中一些点为关键点，其余点为平凡点

　　每一时刻，你可以随机染黑两个相邻的格子。求所有关键点被染黑的期望时间

　　$N \le 6, M \le 100$



　　

# Solution

　　对于所有关键点的集合$S$，答案$ans=\sum_{T \subseteq S}(-1)^{\mid T \mid -1}\frac {n(m-1)+m(n-1)} {f(T)}$，其中$f(T)$为单次染色染到$T$内元素的方案数

　　我们直接对$T$进行DP：分母需要给一维，而$-1$可以统一化处理。转移体现在新添加一个元素时，新产生了多少方案。为此，我们使用轮廓线DP：设$f_{i,j}$表示当前轮廓线状态为$i$（01序列，表示每个元素是否在$T$内），$f(T)=j$的所有$T$的$\sum (-1)^{\mid T \mid -1}$.有了轮廓线，新产生的方案数就可以随便算了

　　总之，这是一道很简单的题，但由于我受了之前的许多题影响，现在我看到此类题时，第一反应都是那个扩展Min-Max的鬼畜DP，从而产生不可做的感觉。事实上，直接使用普通Min-Max就做完了

　　

# Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#define INV(x) fastPow(x,MOD-2)
using namespace std;
const int MOD=998244353;
const int N=100;
const int M=6;
inline void apply(int &x,int y){
	(x+=y)%=MOD;
}
inline int bas2(int i){
	return 1<<i;
}
inline int bit2(int s,int i){
	return (s>>i)&1;
}
int fastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}
int n,m;
int a[N][M];
void readData(){
	scanf("%d%d",&m,&n);
	for(int j=0;j<m;j++){
		static char str[N];
		scanf("%s",str);
		for(int i=0;i<n;i++)
			a[i][j]=(str[i]=='*');
	}
}
void dp(){
	static int f[2][1<<M][N*M*4];
	int stateCnt=(1<<m);
	int sum=0;
	int u=0,v=1;
	f[u][0][0]=-1;
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++){
			for(int s=0;s<stateCnt;s++){
				for(int k=0;k<=sum*4;k++)
					apply(f[v][s&(stateCnt-1-bas2(j))][k+(i>0&&bit2(s,j))+(j>0&&bit2(s,j-1))],f[u][s][k]);
				if(a[i][j]){
					for(int k=0;k<=sum*4;k++)
						apply(f[v][s|bas2(j)][k+(i>0)+(j>0)],-f[u][s][k]);
				}
			}
			sum+=a[i][j];
			swap(u,v);
			memset(f[v],0,sizeof(f[v]));
		}
	int ans=0;
	int tot=n*(m-1)+m*(n-1);
	for(int k=1;k<=sum*4;k++){
		int e=1ll*tot*INV(k)%MOD;
		for(int s=0;s<stateCnt;s++)
			apply(ans,1ll*e*f[u][s][k]%MOD);
	}
	printf("%d\n",ans>=0?ans:ans+MOD);
}
int main(){
	readData();
	dp();
	return 0;
}
```

