---
layout: post
mathjax: true
title: 黑暗
date: 2018-12-10-10:24:50
tag: [切比雪夫距离,计数问题,容斥原理]
---
* content
{:toc}
# Description

　　有$n$个机器人，标号$[1,a]$的为红色，标号$(a,a+b]$的为绿色，其余为蓝色。我们保证每种颜色都至少有一个机器人

　　初始时，第$i$个机器人在二维坐标系上的$(x_i,y_i)$处。每过1个时刻，每个机器人可以且仅可以走向四相邻中的某一个格子，不可以原地不动。我们要求在$m$个时刻后，所有机器人满足：

* 相同颜色的机器人在同一个位置
* 不同颜色的机器人不可以在同一个位置

　　问总共有多少种合法方案。两个合法方案不同，当且仅当某种颜色的机器人的终止位置不同，或者某一个机器人的行进路线不同。答案对$10^9+7$取模



　　　　


# Solution

　　先假设我们能够快速地计算一个函数：$f_0(c)$表示颜色为$c$的所有机器人在$m$个时刻之后全部走到某一个终点$(x,y)$的方案数之和

　　基于这个函数，我们可以得到一个较为直接的思路：枚举合法情况下三种颜色各自的终止位置并统计方案即可

　　观察到颜色数量很少，猜想可以使用容斥原理快速统计

　　先求一个总方案：$f_0(0)f_0(1)f_0(2)$，其中包含了不合法的情况，于是：

　　减去钦定某两种颜色终止位置相同，剩余颜色终止位置的随意时的方案数$f_1(x,y)f_0(z)$。容斥系数为$-1$

　　再加上三种颜色终止位置相同的情况$f_2(x,y,z)$。容斥系数为$+2$

　　这个做法的时间复杂度只和枚举坐标以及计算$f$的速度相关；$f_1$和$f_2$的定义也与$f_0$相似

　　回头考虑一下$f$的计算：对于二维坐标走格子的问题，我们可以将坐标转化为切比雪夫坐标，将两个维度独立处理，具体来讲：

* 原来的一个点$(x,y)$，转化后为$(x+y,x-y)$
* 原来一个点可以走到$(x\pm 1,y),(x,y\pm 1)$，转化后一个点可以走到$(x\pm 1, y\pm 1)$

　　注意到一个点在切比雪夫坐标意义下移动时两维都要变化，这很好地简化了原坐标系中“到底走哪一维”的决策

　　考虑计算$f_0(c)$，其余两个函数同理：对于某一个颜色为$c$的机器人的坐标，我们先将其转化为切比雪夫距离，则原来所有颜色为$c$的机器人都走到$(x,y)$如今等价于：（所有$x_i'=x_i+y_i$通过加减一$m$次变为$x+y$的方案数）乘以（所有$y_i'=x_i-y_i$通过加减一$m$次变为$x-y'$的方案数）。我们只需要对于每一维，在枚举该维在切比雪夫意义下的终点，计算所有机器人该维走到该终点的方案数，求和，最后用两个维度的答案相乘，就可以得到所有机器人走到所有可能的终点的方案数之和

　　单次计算复杂度为$O(\mid c\mid (xrange+yrange))$

　　$a$通过加减一$m$次变为$b$的方案数为${m \choose \frac{\mid b-a\mid}2}$

　　总时间复杂度为$O(n(xrange+yrange))$



　　

# Summary

　　二维坐标的行走问题，不妨在切比雪夫坐标意义下再考虑考虑：我们可以通过切比雪夫坐标独立计算两个维度的决策，将二者相乘以计算总方案。这种方法在时间复杂度的意义上有某种质的飞跃



# Code

```c++
#include <cstdio>
using namespace std;
const int INF=1e9;
const int MOD=1e9+7;
const int N=1010;
int n;
int a,b;
int m;
struct Point{
    int x,y;
}p[N];
int mnx,mxx,mny,mxy;
inline int abs(int x){
    return x>=0?x:-x;
}
inline int max(int x,int y){
    return x>y?x:y;
}
inline int min(int x,int y){
    return x<y?x:y;
}
int fastPow(int x,int y){
    int res=1;
    for(;y;x=1ll*x*x%MOD,y>>=1)
        if(y&1)
            res=1ll*res*x%MOD;
    return res;
}
int fact[10010],iact[10010];
void initFact(int n){
    fact[0]=1;
    for(int i=1;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;
    iact[0]=iact[1]=1;
    iact[n]=fastPow(fact[n],MOD-2);
    for(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
}
inline int C(int n,int m){
    return (0<=m&&m<=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;
}
void readData(){
    scanf("%d%d%d%d",&n,&a,&b,&m);
    mnx=INF; mxx=-INF;
    mny=INF; mxy=-INF;
    int x,y;
    for(int i=1;i<=n;i++){
        scanf("%d%d",&x,&y);
        p[i]=(Point){x+y,x-y};
        mnx=min(mnx,p[i].x-m);
        mxx=max(mxx,p[i].x+m);
        mny=min(mny,p[i].y-m);
        mxy=max(mxy,p[i].y+m);
    }
}
int calc1(int l,int r){
    int sumx=0,sumy=0;
    for(int x=mnx;x<=mxx;x++){
        int t=1;
        for(int i=l;i<=r;i++)
            t=1ll*t*(((x-p[i].x)&1)==(m&1)?C(m,(m-abs(x-p[i].x))>>1):0)%MOD;
        (sumx+=t)%=MOD;
    }
    for(int y=mny;y<=mxy;y++){
        int t=1;
        for(int i=l;i<=r;i++)
            t=1ll*t*(((y-p[i].y)&1)==(m&1)?C(m,(m-abs(y-p[i].y))>>1):0)%MOD;
        (sumy+=t)%=MOD;
    }
    return 1ll*sumx*sumy%MOD;
}
int calc2(int l1,int r1,int l2,int r2){
    int sumx=0,sumy=0;
    for(int x=mnx;x<=mxx;x++){
        int t=1;
        for(int i=l1;i<=r1;i++)
            t=1ll*t*(((x-p[i].x)&1)==(m&1)?C(m,(m-abs(x-p[i].x))>>1):0)%MOD;
        for(int i=l2;i<=r2;i++)
            t=1ll*t*(((x-p[i].x)&1)==(m&1)?C(m,(m-abs(x-p[i].x))>>1):0)%MOD;
        (sumx+=t)%=MOD;
    }
    for(int y=mny;y<=mxy;y++){
        int t=1;
        for(int i=l1;i<=r1;i++)
            t=1ll*t*(((y-p[i].y)&1)==(m&1)?C(m,(m-abs(y-p[i].y))>>1):0)%MOD;
        for(int i=l2;i<=r2;i++)
            t=1ll*t*(((y-p[i].y)&1)==(m&1)?C(m,(m-abs(y-p[i].y))>>1):0)%MOD;
        (sumy+=t)%=MOD;
    }
    return 1ll*sumx*sumy%MOD;
}
int calc3(int l1,int r1,int l2,int r2,int l3,int r3){
    int sumx=0,sumy=0;
    for(int x=mnx;x<=mxx;x++){
        int t=1;
        for(int i=l1;i<=r1;i++)
            t=1ll*t*(((x-p[i].x)&1)==(m&1)?C(m,(m-abs(x-p[i].x))>>1):0)%MOD;
        for(int i=l2;i<=r2;i++)
            t=1ll*t*(((x-p[i].x)&1)==(m&1)?C(m,(m-abs(x-p[i].x))>>1):0)%MOD;
        for(int i=l3;i<=r3;i++)
            t=1ll*t*(((x-p[i].x)&1)==(m&1)?C(m,(m-abs(x-p[i].x))>>1):0)%MOD;
        (sumx+=t)%=MOD;
    }
    for(int y=mny;y<=mxy;y++){
        int t=1;
        for(int i=l1;i<=r1;i++)
            t=1ll*t*(((y-p[i].y)&1)==(m&1)?C(m,(m-abs(y-p[i].y))>>1):0)%MOD;
        for(int i=l2;i<=r2;i++)
            t=1ll*t*(((y-p[i].y)&1)==(m&1)?C(m,(m-abs(y-p[i].y))>>1):0)%MOD;
        for(int i=l3;i<=r3;i++)
            t=1ll*t*(((y-p[i].y)&1)==(m&1)?C(m,(m-abs(y-p[i].y))>>1):0)%MOD;
        (sumy+=t)%=MOD;
    }
    return 1ll*sumx*sumy%MOD;
}
void solve(){
    int t[3];
    t[0]=calc1(1,a);
    t[1]=calc1(a+1,a+b);
    t[2]=calc1(a+b+1,n);
    int ans=1ll*t[0]*t[1]%MOD*t[2]%MOD;
    (ans-=1ll*t[2]*calc2(1,a,a+1,a+b)%MOD)%=MOD;
    (ans-=1ll*t[1]*calc2(1,a,a+b+1,n)%MOD)%=MOD;
    (ans-=1ll*t[0]*calc2(a+1,a+b,a+b+1,n)%MOD)%=MOD;
    (ans+=2ll*calc3(1,a,a+1,a+b,a+b+1,n)%MOD)%=MOD;
    printf("%d\n",ans>=0?ans:ans+MOD);
}
int main(){
    readData();
    initFact(10000);
    solve();
    return 0;
}
```

