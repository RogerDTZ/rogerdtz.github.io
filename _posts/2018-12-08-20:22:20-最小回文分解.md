---
layout: post
mathjax: true
title: 最小回文分解
date: 2018-12-08-20:22:20
tag: 字符串---回文自动机
category: Learning
---
* content
{:toc}
# 目标

　　给定一个字符串$S$，你需要将其分割成若干个连续子串，使得每一个连续子串都是回文串

　　求最小分割段数



 　　

# 朴素做法$O(n^2)$

　　考虑DP：$f_i$表示$S$中前$i$个字符构成的字符串的最小分割段数，则有转移：

$$
\begin{aligned}
f_0&=0\\
f_i&=\min\{f_j+1\mid S_{j+1}...S_i为回文串\}
\end{aligned}
$$

　　实现上，一边DP一边同步构造前$i$个字符的回文自动机，从末端节点开始不断跳fail即可获取所有可转移的回文后缀，利用$\text{len}$计算出相应的$j$即可

```c++
for(int u=last;u!=0;u=fail[u])
    f[end]=min(f[end],f[end-len[u]]+1);
```

　　

# 更优的做法$O(n \log n)$

　　我们还是采用上述的DP式子，一边DP一边构造前缀的回文自动机，并考虑如何优化转移

## 需要维护的值

　　首先，自动机的每个节点$u$需要额外维护两个值：

* $\text{diff}[u]=\text{len}[u]-\text{len}[\text{fail}[u]]$
* $\text{slink}[u]=$$u$在fail树上深度最大的祖先$anc$，满足$\text{diff}[u]\neq\text{diff}[anc]$

　　维护方式是显然的，每插入一个节点时$O(1)$计算即可

## 两个定理

　　为了引出算法，我们需要先了解两个定理：

　　**定理1**：对于fail树上的任意一个节点$u$，其通过$u=\text{slink}[u]$迭代至多$O(\log n)$次后会到达树根。

　　可以发现，对于$u$往上一直到$\text{slink}[u]$的这些点，父子长度的差值都相等。因此，**定理1**也可以理解为任意一点往上走，长度减小的变化量至多有$O(\log n)$个

　　**定理2**：若当前已构造出了前$i$个字符的后缀自动机，最后停留点为$u$，且$u$不为所在等差长度链的链顶（若$u$恰为链顶，我们会在后面提及处理方案），$\text{fail}[u]$代表的回文串为$p$，则有：

1. $\text{fail}[u]$倒数第二次出现的结束位置必定为$i-\text{diff}[u]$，也即该位置之右、$i$之左不可能出现$p$
2. 在前$i-\text{len}[u]$个字符构成的回文自动机的fail树中，$\text{fail}[u]$与所有后继的长度之差皆不等于$\text{diff}[\text{fail}[u]]$，也即$u$为其所在等差长度链的链底

　　1.的证明很显然：首先，由于回文串的特殊性，$p$在$u$代表的回文串的前端也会出现；其次，假设在那个范围中出现了$p$的结束位置，我们总可以引出比$p$更长的回文串，因此$\text{fail[u]}$不应该对应$p$，矛盾

　　2.的话，暂且先不详细讲了

## 算法本体

　　与刚才的暴力枚举fail树上的祖先不同，我们依次$O(1)$计算一条等差长度链上的点的贡献，总共有$O(\log n)$条链，因此单次更新的时间复杂度为$O(\log n)$

```c++
for(int u=last;u!=0;u=slink[u])
    // 使用u所在的等差长度链的每一个长度len,用f[i-len]更新f[i]
```

　　注释所写的是算法效果，而非具体实现

　　为何要将长度等差的回文串放在一起转移呢？因为等差可以带来非常巧妙的转化：

　　考虑第一个等差长度链，后续的等差长度链同理：

　　设公差为$d$，则可用于转移回文串的长度为$\text{len}[u],\text{len}[u]-d,\text{len}[u]-2d,\dots,\text{len}[u]-kd$，它们都是$u$代表的回文串的某一个后缀

　　除去第一项，我们将其余回文串翻转到$u$的回文串的前方，此时可以发现：除了$\text{len}[u]-kd$这个转移长度，我们曾经在计算前$i-d$个字符的答案递归并迭代到$\text{fail}[u]$时（必定会迭代到$\text{fail}[u]$)，已经将$f[i-\text{len}[u]],f[i-\text{len}[u]-d],\dots$取过最小值。我们只需要额外考虑上$\text{len}[u]-kd$即可

　　整个过程利用了等差的性质，当前的转移位置绝大部分都是翻转后的转移位置，虽然不一一对应，但是集合几乎相等

　　且根据**定理2**，我们没有考虑$(i-d,i)$这段区间的必要，可以直接跳过——因为在这里结尾的回文串无一与我们要考虑的回文串相关

　　考虑对于每一个点$u$维护一个值$g[u]$，表示上一次迭代到$u$时，记总进程的前缀长度为$i'$，$u$提供给当时的$f_{i'}$的最优值是多少（即下述伪代码中第5行的"g[u]"）

　　则最终可得一个基于继承的优秀算法：

```c++
for(int u=last;u!=0;u=slink[u]){
    g[u]=f[i-(len[slink[u]]+diff[u])]; // 额外考虑len[u]-kd这个长度的转移
    if(diff[u]==diff[fail[u]])
        g[u]=min(g[u],g[fail[u]]); // 可以继承大量的最小值
    f[i]=min(f[i],g[u]+1);
}
```

　　总时间复杂度$O(n \log n)$

　　

# Tips

　　实现上，对于回文自动机的两个特殊根，我们并不需要做什么特判——两个特殊根的$\text{len}$可以很好地适应本算法