---
layout: post
mathjax: true
title: 【GDOI2018】巡逻
date: 2018-10-05-16:19:00
tag: [最短路]
tag: GDOI
---

# Description

　　给定一个无向图，每条边有一个长度

　　每次询问从某一个点出发的最小环

　　同时，你需要支持停用或者启用某一些点。一个点停用时，不可以被经过

　　$n \le 400$



# Solution

　　我一开始总想着怎么对于每一个点直接维护其最小环，结果完全行不通

　　但考虑数据范围较小，我们完全可以在每次询问的时候枚举这个最小环，而不需要实时维护

　　看来自己的“维护”思想太过头了

　　每次询问时，要找一个从$x$出发的最小环。我们不妨枚举某一个点$y \neq x$，钦定最小环一定要经过$y$。我们只要统计出$y$走到$x$的最短路，加上$y$走到$x$的另一条、走入$x$之前的接口点与前者不同的尽可能短的路，加起来，就可以形式化地作为“$x$走到$y$，再从$y$走到$x$构成的环“的环长

　　这样做，我们可以保证环在$x$的那一端不会重合，至少会打开一个“口”；但我们却无法保证环在$y$的一端不会重合。没关系，我们只需要对每一个$y$的答案取$\min$就可以了。因为即使$y$的答案路径有重合，在枚举到重合的第一个点$y'$时其答案显然会比$y$更优

　　对于修改操作，我们直接修改状态，由于不需要维护什么东西，这一步没什么难度

　　对于查询操作，我们要对于所有的$y$事先算出每个距离。算法容忍我们单次询问$O(n^2)$的复杂度，在考虑到我们在完全图上求最短路，首先想到Dijkstra。稍微转化一下，对于上述的两条路径，我们只需要算出从$x$出发到每一个点$y$的、第一个走出的点不同的两条最短路径即可，这样更好计算也更好考虑。具体实现上，要对Dijkstra进行一定的改造：每个点的距离数据记录的是两个不同出口的路径，每个记录是一个pair，表示距离和出口编号。确定锚点更新时，枚举锚点的两条路径，按边长转移后，直接像维护最大值次大值一样将新的pair推进转移点的两个pair以直接更新，而不需要考虑锚点的每一条路径是否要对应地转移到转移点的某一条路径

# Summary

　　看数据范围行事。维护虽然强大，但也有干不了的事情。如果数据范围较小，不妨针对每次询问都直接做一遍，问题或许就会变得很显然了



# Code

```c++
#include <cstdio>
#include <utility>
#define mp make_pair
#define FR first
#define SE second
using namespace std;
typedef pair<int,int> pii;
const int N=410;
const int INF=1e9;
int n;
int a[N][N];
bool enable[N];
pii dis[N][2];
bool vis[N];
inline int min(int x,int y){
	return x<y?x:y;
}
void readData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&a[i][j]);
}
void init(){
	for(int i=1;i<=n;i++) 
		enable[i]=true;
}
void update(int u,pii &p){
	if(p.FR<=dis[u][0].FR){
		if(p.SE!=dis[u][0].SE)
			dis[u][1]=dis[u][0];
		dis[u][0]=p;
	}
	else if(p.FR<dis[u][1].FR){
		if(p.SE!=dis[u][0].SE)
			dis[u][1]=p;
	}
}
int solve(int x){
	for(int i=1;i<=n;i++){
		vis[i]=false;
		dis[i][0]=dis[i][1]=mp(INF,-1);
	}
	dis[x][0]=mp(0,0);
	for(int i=1;i<=n;i++){
		int u=-1;
		for(int v=1;v<=n;v++)
			if(enable[v]&&!vis[v]&&(u==-1||dis[v][0].FR<dis[u][0].FR))
				u=v;
		if(u==-1)
			break;
		vis[u]=true;
		pii t;
		for(int v=1;v<=n;v++)
			if(enable[v]&&!vis[v]&&a[u][v]!=-1)
				for(int k=0;k<2;k++){
					t=mp(dis[u][k].FR+a[u][v],(u==x)?v:dis[u][k].SE);
					update(v,t);
				}
	}
	int res=INF;
	for(int u=1;u<=n;u++)
		if(u!=x)
			res=min(res,dis[u][0].FR+dis[u][1].FR);
	return res<INF?res:-1;
}
void answerQuery(){
	int q,opt,x;
	scanf("%d",&q);
	for(int i=1;i<=q;i++){
		scanf("%d%d",&opt,&x);
		if(opt==0)
			printf("%d\n",solve(x));
		else
			enable[x]^=1;
	}
}
int main(){
	readData();	
	init();
	answerQuery();
	return 0;
}
```

