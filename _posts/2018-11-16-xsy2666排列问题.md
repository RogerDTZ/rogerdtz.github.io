---
layout: post
mathjax: true
title: 排列问题
date: 2018-11-16-10:39:00
tag: [DP---计数,数论---组合数学,生成函数,分治,FFT,容斥原理]
---
* content
{:toc}
# Description

　　现有$m$个球，每一个球都涂着$n$种颜色中的某一种，第$i$种颜色有$a_i$个球。显然，$\sum{a_{i}}=m$。对于颜色相同的球，我们认为它们没有差别

　　现在给出$q$个询问。每一个询问给出一个参数$x$，你需要求出总共有多少种将$m$个球排成一行的方案，使得相邻两个球颜色相同的对数恰好为$x$

　　$n \le 10^4,\ m \le 2*10^5,\; q \le 10^4,\ 0 \le x < m$




# Solution

　　如果从相邻两个球颜色相同或不相同的对数入手，其实是不好做的，因为每一对球之间可能会相互影响，譬如考虑三个球时，对于这两对球，我们很难在统计时判断它们各自的颜色，钦定的方法也可能产生矛盾

　　既然不能从断点做，那么我们考虑从一段的角度入手。我们可以将这些球分成若干个非空段，每一段内的颜色相同，而相邻两段的颜色不同。如果能计算出$ans$数组，其中$ans_i$表示有多少种方案能将所有球按上述方式划分成恰好$i$段，我们即可$O(1)$回答所有询问

　　注意到我们很难在统计时满足最后一个限制（相邻两段颜色不同）。如果能计算出忽略此性质后计算出来的数组$g$，我们就可以使用容斥原理计算每一个$g_j$对每一个$ans_i\ (j\le i)$的贡献：

$$
ans_i=g_i-\sum_{j=1}^{i-1}{m-j \choose i-j}ans_j
$$

　　其中${m-j \choose i-j}$表示：一个恰好有$j$段的合法方案（即相邻段颜色不同），它于忽略掉这个限制意义下分成$i$段的方案总数之中被计算的次数，即在当前分段位置的基础上，还可以再在相邻两球相同的各个位置再挑$i-j$个位置切分，并在$g_i$中被统计

　　再通过传递展开，可得

$$
ans_i=\sum_{j=1}^i(-1)^{i-j}{m-j \choose i-j}
$$

　　拆项后，一遍FFT计算即可，复杂度$O(m \log m)$

　　如何计算$g$呢？

　　每一种划分方案可以唯一对应一个数组$s_{1...n}$，其中$s_i$表示第$i$种颜色在方案中被划分了多少段，则每一个数组$s$对应着$\frac{(\sum s_i)!}{\prod (s_i!)}$种方案，即把所有段排列并忽略相同颜色的段的相对顺序后的结果

　　我们使用DP同步这个分式计算方案数，如何体现状态和值得关系？设$f_{i,j}$表示考虑完前$i$种颜色后，已经分的段数为$j$时（即分母$\sum_{k=1}^is_k=j$），分母的乘积之和

　　转移第$i$种颜色时，枚举此颜色分成$k$段，则有

$$
f_{i,j}\leftarrow f_{i-1,j-k}{a_i-1\choose k-1}\frac{1}{k!}\ \ \ \ \ k=1\dots a_i
$$

　　我们可以从中发现生成函数的形式：偏移一段距离后乘上一个系数并贡献。记母函数$F_i(x)[x^j]=f_{i,j}$，则每次转移$i$相当于乘上一个转移函数$T_i(x)$：

$$
F_i(x)=F_{i-1}(x)*T_i(x)\\
T_i(x)=\sum_{k=1}^{a_i}{a_i-1\choose k-1}\frac 1{k!}x^k
$$

　　注意到$\sum a_i=m$，因此使用分治FFT求出$\prod_{i=1}^n T_i(x)$即可得到$F_n(x)$，并得到$f_{n,j}$。时间复杂度$O(m \log m \log n)$

　　最后，我们把状态表示和DP值结合算出$g$即可：$g_i=j!f_{n,j}$

　　总时间复杂度$O(m \log m \log n + q)$



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
namespace IO{
    const int L=10000000;
    char inBuf[L];
    int inPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
const int MOD=998244353,G=3;
const int N=10010,M=200010;
int n,m;
int num[N],pre[N];
int fact[M],iact[M];
int *f,g[M];
int ans[M];
int fastPow(int x,int y){
    int res=1;
    for(;y;x=1ll*x*x%MOD,y>>=1)
        if(y&1)
            res=1ll*res*x%MOD;
    return res;
}
void initFact(int n){
    fact[0]=1;
    for(int i=1;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;
    iact[0]=iact[1]=1;
    iact[n]=fastPow(fact[n],MOD-2);
    for(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
}
inline int C(int n,int m){
    return (0<=m&&m<=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;
}
namespace NTT{
    const int S=530000;
    int n,invn,bit;
    int rev[S];
    int W[20][S][2];
    void build(){
        int iG=fastPow(G,MOD-2);
        for(int i=0;i<=19;i++){
            int x=fastPow(G,(MOD-1)/(1<<i));
            int y=fastPow(iG,(MOD-1)/(1<<i));
            W[i][0][0]=W[i][0][1]=1;
            for(int j=1;j<(1<<i);j++){
                W[i][j][0]=1ll*W[i][j-1][0]*x%MOD;
                W[i][j][1]=1ll*W[i][j-1][1]*y%MOD;
            }
        }
    }
    void init(int _n){
        for(n=1,bit=0;n<_n;n<<=1,bit++);
        invn=fastPow(n,MOD-2);
        for(int i=0;i<n;i++) rev[i]=(rev[i>>1]>>1)|((i&1)<<(bit-1));
    }
    void ntt(int *a,int f){
        for(int i=0;i<n;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);
        int u,v,w;
        for(int i=2,il=1;i<=n;i<<=1,il++){
            for(int j=0;j<n;j+=i)
                for(int k=0;k<(i>>1);k++){
                    w=W[il][k][f];
                    u=a[j+k];
                    v=1ll*w*a[j+(i>>1)+k]%MOD;
                    a[j+k]=(u+v)%MOD;
                    a[j+(i>>1)+k]=(u-v)%MOD;
                }
        }
        if(f)
            for(int i=0;i<n;i++) a[i]=1ll*a[i]*invn%MOD;
    }
}
void polyMul(int n,int *a,int m,int *b,int *c,bool dirUse=false){
    int newlen=n+m-1;
    NTT::init(newlen);
    if(!dirUse){
        static int ta[NTT::S],tb[NTT::S];
        for(int i=0;i<n;i++) ta[i]=a[i];
        for(int i=n;i<NTT::n;i++) ta[i]=0;
        for(int i=0;i<m;i++) tb[i]=b[i];
        for(int i=m;i<NTT::n;i++) tb[i]=0;
        NTT::ntt(ta,0);
        NTT::ntt(tb,0);
        for(int i=0;i<NTT::n;i++) ta[i]=1ll*ta[i]*tb[i]%MOD;
        NTT::ntt(ta,1);
        for(int i=0;i<newlen;i++) c[i]=ta[i];
    }
    else{
        for(int i=n;i<NTT::n;i++) a[i]=0;
        for(int i=m;i<NTT::n;i++) b[i]=0;
        NTT::ntt(a,0);
        NTT::ntt(b,0);
        for(int i=0;i<NTT::n;i++) a[i]=1ll*a[i]*b[i]%MOD;
        NTT::ntt(a,1);
        for(int i=0;i<newlen;i++) c[i]=a[i];
    }
}
void readData(){
    n=getInt();
    for(int i=1;i<=n;i++){
        num[i]=getInt();
        pre[i]=pre[i-1]+num[i];
    }
    m=pre[n];
}
inline int getLen(int l,int r){
    return pre[r]-pre[l-1]+1;
}
int mem[8000010];
int *pmem=mem;
void divide1(int l,int r,int *&a){
    a=pmem;
    pmem+=getLen(l,r);
    if(l==r){
        a[0]=0;
        for(int k=1;k<=num[l];k++)
            a[k]=1ll*C(num[l]-1,k-1)*iact[k]%MOD;
        return;
    }
    int mid=(l+r)>>1;
    int *la,*ra;
    int len=getLen(l,r),lenl=getLen(l,mid),lenr=getLen(mid+1,r);
    divide1(l,mid,la);
    divide1(mid+1,r,ra);
    polyMul(lenl,la,lenr,ra,a);
}
void calcAnswer(){
    divide1(1,n,f);
    for(int i=1;i<=m;i++)
        g[i]=1ll*fact[i]*f[i]%MOD;
    static int ta[NTT::S],tb[NTT::S];
    ta[0]=0;
    for(int i=1;i<=m;i++) ta[i]=1ll*g[i]*fact[m-i]%MOD;
    for(int i=0;i<=m;i++) tb[i]=((i&1)?-1ll:1ll)*iact[i];
    polyMul(m+1,ta,m+1,tb,ta);
    for(int i=1;i<=m;i++) ans[i]=1ll*iact[m-i]*ta[i]%MOD;
}
void answerQuery(){
    int q,k;
    q=getInt();
    for(int i=1;i<=q;i++){
        k=m-getInt();
        printf("%d\n",ans[k]>=0?ans[k]:ans[k]+MOD);
    }
}
int main(){
    IO::load();
    NTT::build();
    initFact(200000);
    readData();
    calcAnswer();
    answerQuery();
    return 0;
}
```

