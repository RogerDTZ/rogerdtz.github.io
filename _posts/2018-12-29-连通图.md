---
layout: post
mathjax: true
title: 连通图
date: 2018-12-29-19:28:00
tag: [并查集,好题]
---
* content
{:toc}
# Description

　　给定一个两部分的大小都为$n$、共有$m$条带权边的二分图$G$，第$i$条边的边权为$w_i$

　　定义$G^k$如下：

* $G^1$即$G$
* 对于$\forall k>1$，$G^k$为$G$重复$k$次并左右拼接得到的图，即上一层的右部分与下一层的左部分的对应节点是同一个节点

　　给定$q$，求$G_1\dots G_q$各自的最小生成树大小

　　$n \le 10^5,\ m \le 2*10^5, \ 0 \le  w \le 30, \ q \le 10^5$

　　

# Solution

　　考虑到边权数量不多，我们可以尝试将权值和问题转化为枚举判定问题：对于$i=0 \dots w$，仅仅考虑边权不超过$i$的那些边时，每一个$G_k$各有几条边？每次我们将当前的答案与$i-1$的答案作差，就可以知道边权为$i$的边对于每一个$G_k$的贡献了

　　于是问题变为：给定$G$的一些边，显然$G_1 \dots G_q$都会有各自的边集（从$G$中复制若干次）。对于每一个$G_k$，问在只能形成森林的情况下最多能加几条边

　　对于$G_1$，我们用一个并查集维护两排点的连通性即可

　　对于$G_2$，我们不可能将整张图的连通性再计算一遍。考虑到$G_2$是由$G_1$右边多拼一个$G$得到的图，我们尝试对$G_1$的并查集做适当修改来得到$G_2$中最后两排点的连通性——之所以只要维护最后两排，是因为从倒数第二排往前的所有点连通性已经固定，当下我们要知道的只有接口的信息：倒数第二排这$n$个节点的连通性。

　　我们记录下$G_1$中新增的第二排点的连通性信息，每一条信息形如$(u,v)$，表示第二排中$u$和$v$刚刚被我联通了。当我们处理到$G_2$时，最后两排点的大部分连通性与倒数第二第三排的连通性大致相同，我要考虑的是上一层给我的那些信息$(u,v)$，显然我们要枚举它们并做出尝试连接当下倒数第二排的$u$和$v$的举动：若二者本身就在一个连通块内，由于左边的连通性已经给定锁死不可协调，我们必须断掉$u$到$v$路径上的某一条边，我们将$delta_i$减1——$delta_i$表示第$i$块图内部有几条边；若成功连接，我们只需要合并并查集即可，同时，我们要判断本次连接是否新连通了最后一排的两部分点，并将这些信息记录下来供计算下一层时使用

　　最后，我们只需要对$delta$做两次前缀和即可：第一次前缀和后$delta_i$就是每一块的边数，第二次前缀和后$delta_i$就是前$i$块的总边数是多少，这就对应了我们开头要求的东西

　　时间复杂度$O(w(m+n\alpha))$，其中$\alpha$为并查集复杂度

　　好神的题啊！



# Code

```c++
#include <cstdio>
#include <utility>
#include <vector>
#define MP make_pair
#define FR first
#define SE second
#define PB push_back
using namespace std;
typedef long long LL;
inline void swap(int &x,int &y){
	x^=y^=x^=y;
}
namespace IO{/*{{{*/
	const int LEN=10000000;
	char *inBuf,*outBuf,*outPos;
	void init(){
		inBuf=new char[LEN];
		outBuf=new char[LEN];
		outPos=outBuf;
		fread(inBuf,1,LEN,stdin);
	}
	void flush(){
		fwrite(outBuf,1,outPos-outBuf,stdout);
	}
	char getChar(){
		return *inBuf++;
	}
	char writeChar(char c){
		*outPos=c;
		outPos++;
	}
	int getInt(){
		char c=getChar();
		int x=0,f=1;
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
		while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
		return x*f;
	}
	void writeInt(LL x,char end='\n'){
		if(!x)
			writeChar('0');
		else{
			static int digit[30],len;
			for(len=0;x;x/=10) digit[++len]=x%10;
			for(;len;len--) writeChar('0'+digit[len]);
		}
		writeChar(end);
	}
}/*}}}*/
using IO::getInt;
using IO::writeInt;
const int N=100000+10;
const int Q=100000+10;
const int W=30+10;
int n,m,q;
struct Array{
	int n;
	int a[N*2][2];
	Array(){
		reset();
	}
	void reset(){
		n=0;
	}
	void insert(int x,int y){
		n++;
		a[n][0]=x;
		a[n][1]=y;
	}
}edge[W];
void readData(){
	n=getInt(); q=getInt(); m=getInt();
	int u,v,w;
	for(int i=1;i<=m;i++){
		u=getInt(); v=getInt(); w=getInt();
		for(int j=w;j<=30;j++)
			edge[j].insert(u,v);
	}
}
int dsu[N*2];
int findDSU(int x){
	return (dsu[x]==x)?x:(dsu[x]=findDSU(dsu[x]));
}
void solve(){
	static LL ans[Q];
	for(int w=1;w<=30;w++){
		static LL sum[Q],lastSum[Q];
		static Array f[2];
		for(int i=1;i<=q;i++) sum[i]=0;
		for(int i=1;i<=n*2;i++) dsu[i]=i;
		f[0].reset(); f[1].reset();
		for(int i=1;i<=edge[w].n;i++){
			int fu=findDSU(edge[w].a[i][0]),fv=findDSU(n+edge[w].a[i][1]);
			if(fu==fv)
				continue;
			sum[1]++;
			if(fu>n&&fv>n)
				f[0].insert(fu-n,fv-n);
			if(fu>fv)
				swap(fu,fv);
			dsu[fu]=fv;
		}
		int x=0,y=1;
		for(int i=2;i<=q&&f[x].n;i++,x^=y^=x^=y,f[y].reset()){
			for(int j=1;j<=f[x].n;j++){
				int fu=findDSU(f[x].a[j][0]),fv=findDSU(f[x].a[j][1]);
				if(fu!=fv){
					if(fu>n&&fv>n)
						f[y].insert(fu-n,fv-n);
					if(fu>fv)
						swap(fu,fv);
					dsu[fu]=fv;
				}
				else
					sum[i]--;
			}
		}
		for(int i=2;i<=q;i++) sum[i]+=sum[i-1];
		for(int i=2;i<=q;i++) sum[i]+=sum[i-1];
		for(int i=1;i<=q;i++) ans[i]+=(sum[i]-lastSum[i])*w;
		for(int i=1;i<=q;i++) lastSum[i]=sum[i];
	}
	for(int i=1;i<=q;i++) writeInt(ans[i]);
}
int main(){
	IO::init();
	readData();
	solve();
	IO::flush();
	return 0;
}
```

