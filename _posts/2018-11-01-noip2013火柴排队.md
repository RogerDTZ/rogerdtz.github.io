---
layout: post
mathjax: true
title: 【NOIP2013】火柴排队
date: 2018-11-01-21:05:00
tag: [贪心,模拟,线段树,逆序对,答案特征]
category: NOIP
---
* content
{:toc}
# Description

 　　略　　



# Solution

　　显然是按照大小顺序对位匹配

　　然后是怎么移动的问题

　　脑子一热的我直接fou掉了“只在一边交换相邻两个，和原来的操作是等价的”，于是我就直接用了一个鬼畜的模拟：考虑两个序列最左边的元素，如果互相匹配则OK，将它们从左边删除；否则，选匹配点离左边较近的那一个人，删掉它和它的匹配点。具体实现用线段树维护下标，但是细节什么的实在是太烦人了，要是在考场上那得耗掉不少时间，可能就凉了

　　实际上，以某一边固定不动为模板、用最优方案操作另一边的方法的确是最优解的一种。因此，参考冒泡排序交换次数的恰好是逆序对个数这个结论，我们只需要求两个序列的相对逆序对即可



# Summary

　　涉及双边操作和多边操作时，看看只考虑单边操作是否能得到最优解



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int INF=1e9;
const int MOD=99999997;
const int N=100010;
int n;
int a[N],b[N];
void readData(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
}
int mat[2][N];
bool cmpA(const int &x,const int &y){
	return a[x]<a[y];
}
bool cmpB(const int &x,const int &y){
	return b[x]<b[y];
}
void match(){
	static int ida[N],idb[N];
	for(int i=1;i<=n;i++) ida[i]=idb[i]=i;
	sort(ida+1,ida+1+n,cmpA);
	sort(idb+1,idb+1+n,cmpB);
	for(int i=1;i<=n;i++){
		mat[0][ida[i]]=idb[i];
		mat[1][idb[i]]=ida[i];
	}
}
namespace SEG{
	const int S=N*2;
	int rt[2],sz;
	int ch[S*2][2];
	int tag[S*2];
	void build(int &u,int l,int r){
		u=++sz;
		if(l==r)
			return;
		int mid=(l+r)>>1;
		build(ch[u][0],l,mid);
		build(ch[u][1],mid+1,r);
	}
	inline void makeTag(int u,int x){
		tag[u]+=x;
	}
	void segAdd(int u,int l,int r,int ml,int mr,int x){
		if(ml>mr)
			return;
		if(ml<=l&&r<=mr){
			makeTag(u,x);
			return;
		}
		int mid=(l+r)>>1;
		if(mr<=mid)
			segAdd(ch[u][0],l,mid,ml,mr,x);
		else if(mid<ml)
			segAdd(ch[u][1],mid+1,r,ml,mr,x);
		else{
			segAdd(ch[u][0],l,mid,ml,mid,x);
			segAdd(ch[u][1],mid+1,r,mid+1,mr,x);
		}
	}
	int queryPoint(int u,int l,int r,int p,int tagSum=0){
		tagSum+=tag[u];
		if(l==r)
			return l+tagSum;
		int mid=(l+r)>>1;
		if(p<=mid)
			return queryPoint(ch[u][0],l,mid,p,tagSum);
		else
			return queryPoint(ch[u][1],mid+1,r,p,tagSum);
	}
}
bool del[2][N];
void solve(){
	SEG::build(SEG::rt[0],1,n);
	SEG::build(SEG::rt[1],1,n);
	int i=1,j=1,pi,pj;
	int ans=0;
	while(i<=n||j<=n){
		while(i<=n&&del[0][i]) i++;
		while(j<=n&&del[1][j]) j++;
		pi=pj=INF;
		if(i<=n&&mat[0][i])
			pi=SEG::queryPoint(SEG::rt[1],1,n,mat[0][i]);
		if(j<=n&&mat[1][j])
			pj=SEG::queryPoint(SEG::rt[0],1,n,mat[1][j]);
		if(pi==INF||pj==INF){
			SEG::segAdd(SEG::rt[0],1,n,i+1,n,-1);
			SEG::segAdd(SEG::rt[1],1,n,j+1,n,-1);
			i++; j++;
			continue;
		}
		if(pi<=pj){
			(ans+=pi-1)%=MOD;
			SEG::segAdd(SEG::rt[0],1,n,i+1,n,-1);
			SEG::segAdd(SEG::rt[1],1,n,mat[0][i]+1,n,-1);
			del[1][mat[0][i]]=true;
			i++;
		}
		else{
			(ans+=pj-1)%=MOD;
			SEG::segAdd(SEG::rt[1],1,n,j+1,n,-1);
			SEG::segAdd(SEG::rt[0],1,n,mat[1][j]+1,n,-1);
			del[0][mat[1][j]]=true;
			j++;
		}
	}
	printf("%d\n",ans);
}
int main(){
	readData();
	match();
	solve();
	return 0;
}
```

 