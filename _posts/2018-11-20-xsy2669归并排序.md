---
layout: post
mathjax: true
title: 归并排序
date: 2018-11-18-07:45:00
tag: [适应,数据结构---树状数组]
---
* content
{:toc}
# Description

　　给一个长度为$n$的排列$a$，其中$n$为2的整数次幂

　　现将其进行归并排序。特别地，当分治区间长度为2时，有$\frac 12$的概率排序错误，即对于$x<y$有可能会排序成$y,x$

　　请支持$q$次操作：

* 交换$a$中的某两个数
* 给出两个数$i,j$，将$a$归并排序得到$a'$后，询问$a'_i=a_j$的概率

　　$n \le 2^{16},\ q \le 10^5$


# Solution

　　对于某一个长度为2的分治区间，设两个数分别为$x,y(x<y)$，可以发现：

* 如果排序后结果为$x,y$，则它们在之后的归并排序中没有特别的问题
* 如果排序后结果为$y,x$，根据归并排序的特性，我们可以发现：在之后的归并过程中，$x$总是会紧紧贴在$y$后面

　　我们可以对所谓的排序错误做一个等价转化：对于底层的一组数$a_i,a_j(a_i<a_j)$，$a_j$的值稳定不变，而$a_i$的值有$\frac 12$的概率变为$a_j+0.5$。为了简化问题，我们可以把稳定的数也看做不稳定的数，使其两个值都等于原值。

　　考虑询问：求排序后第$i$个数为$a_j$的情况数，即小于$a_j$的数恰好有$i-1$个的情况数，除以$2^{\frac n2}$即可。

1. 先两个值皆小于$a_j$的数的个数$s_1$，这$s_1$个数稳定地占去了$s_1$个位置，若$s_1>i-1$则无解，否则此时还剩下$i-1-s_1$个位置需要填入

2. 记一个数的两个值为一个数对$(x,y),\ (x<y)$，我们统计满足$x<a_j<y$的数对个数$s_2$。我们可以从$s_2$个数中挑选$i-1-s_1$个数，让它们取较小的值，填入剩余位置，且令剩余的数取较大的值，放在$a_j$之后。这一个过程贡献的情况数为

$$
	{s2 \choose i-1-s_1}{2^{sum}}
$$

　　其中，$sum$为当下除了$a_j$所属的数对（可能是）以及$s_2$个数对以外，有多少数对满足$x!=y$。这些数对的取值对我们的限制没有任何影响。$sum$可以通过$\frac n2-s_2$再通过微调（考虑$a_j$所属数对是不是）得到

　　如何求$s_1$和$s_2$？我们记录以$x'$为$x$的数对有多少个，再记录以$y'$为$y$的数对有多少个，使用两个树状数组维护这两个信息及其前缀和，分别记为$A$与$B$。$s_1$显然等于$B$中$a_j-1$的前缀和，而$s_2$可以通过容斥得到：$A$中$a_j-1$的前缀和减去$s_2$即可

　　交换操作没有什么难度，先删去涉及数对，再加入新数对即可

　　时间复杂度$O(q \log n)$



# Summary

　　通过适应的思想，赋予某些元素新的定义，使得其既能用原算法或模型计算，又能体现题目的要求



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
const int MOD=1e9+7;
const int N=66000;
int n;
int a[N];
int fact[N],iact[N],mi2[N];
int fastPow(int x,int y){
    int res=1;
    for(;y;x=1ll*x*x%MOD,y>>=1)
        if(y&1)
            res=1ll*res*x%MOD;
    return res;
}
void initFact(int n){
    fact[0]=fact[1]=1;
    for(int i=2;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;
    iact[0]=iact[1]=1;
    iact[n]=fastPow(fact[n],MOD-2);
    for(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
    mi2[0]=1;
    for(int i=1;i<=n;i++) mi2[i]=(mi2[i-1]<<1)%MOD;
}
inline int C(int n,int m){
    return (0<=m&&m<=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;
}
struct BIT{
    int n;
    int a[N*2];
    void setRange(int range){
        n=range;
    }
    void add(int u,int x){
        for(;u&&u<=n;u+=u&-u)
            a[u]+=x;
    }
    int que(int u){
        int res=0;
        for(;u;u-=u&-u)
            res+=a[u];
        return res;
    }
}bitx,bity;
void readData(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
        a[i]<<=1;
    }
}
void addPair(int x,int y,int sgn){
    bitx.add(x,sgn);
    bity.add(y,sgn);
}
void consider(int u,int v,int sgn){
    if(u>v)
        swap(u,v);
    addPair(u,v+1,sgn);
    addPair(v,v,sgn);
}
void buildBIT(){
    bitx.setRange(n*2+1);
    bity.setRange(n*2+1);
    for(int i=0;i<n;i+=2)
        consider(a[i],a[i+1],1);
}
void exchange(int x,int y){
    if(x==y)
        return;
    consider(a[x],a[x^1],-1);
    if((x>>1)!=(y>>1))
        consider(a[y],a[y^1],-1);
    swap(a[x],a[y]);
    consider(a[x],a[x^1],1);
    if((x>>1)!=(y>>1))
        consider(a[y],a[y^1],1);
}
int calc(int val,int other,int num){
    int sumx=bitx.que(val-1)-(other<=val-1); 
    int sumy=bity.que(val-1);
    sumx-=sumy;
    if(sumy>num)
        return 0;
    return 1ll*C(sumx,num-sumy)*mi2[(n>>1)-(sumx+(val!=other))]%MOD;
}
int query(int x,int y){ // how many situation satisfy a'[y]=a[x]
    int res=0;
    if(a[x]>a[x^1]) // single value
        res=calc(a[x],a[x],y);  
    else
        res=(calc(a[x],a[x^1]+1,y)+calc(a[x^1]+1,a[x],y))%MOD;
    res=1ll*res*fastPow(mi2[n>>1],MOD-2)%MOD;
    return res>=0?res:res+MOD;
}
void answerQuery(){
    int q;
    int opt,x,y;
    scanf("%d",&q);
    for(int i=1;i<=q;i++){
        scanf("%d%d%d",&opt,&x,&y);
        x--; y--;
        if(opt==1)
            exchange(x,y);
        else
            printf("%d\n",query(x,y));
    }
}
int main(){
    initFact(65536);
    readData();
    buildBIT();
    answerQuery();
    return 0;
}
```

