---
layout: post
title: 多项式
date: 2018-07-27
mathjax: true
categories: Learning
tag: 多项式
---
* content
{:toc}
# 多项式全家桶

> 欢迎订购~~KFC~~多项式全家桶

　　

# 约定的记号

　　对于一个多项式$A(x)$，若其最高次系数不为零的项是$x^k$，则该多项式的**次数**为$k$.

　　记为$\text{deg}(A)=k$

　　对于$x\in(k,+ \infty)​$，称$x​$都为$A(x)​$的**次数界**. 但一般地，我们都使用$k+1​$作为$A(x)​$的**次数界**。

　　

# 取模意义下的多项式运算

　　这里要消除一下疑惑：当我们把两个次数界为$n$的多项式在模$x^n$意义下相乘时，虽然NTT后我们得到的是一个次数界为$2n-1$的多项式，但是$x^n....x^{2n-1}$的系数没有意义，答案就是$x^0...x^{n-1}$描述的多项式

　　求分式同理，$\frac {F(x)}{G(x)}\pmod {x^n}$的答案，就是$F(x)*G^{-1}(x)$的前$n$个项

　　模$x^n$等价于截高位，即将指数不小于$n$的项的系数直接设为0

　　

## 一个好的函数

　　由于运算过程涉及各种指针操作，为了避免出现越界修改的情况，我们通常要对数组进行复制，复制的时候还要考虑清零，十分头疼。因此，我们对这个操作进行一下封装：

```c++
// target:目标数组指针
// source:源数组指针 
// len:从source开始复制的长度 
// cut:复制完成后，target的后续部分需要清空到多少（-1表示不需要清空）
void copy(int *target,int *source,int len,int cut=-1){
    memcpy(target,source,sizeof(int)*len);
    if(cut!=-1)
    	memset(target+len,0,sizeof(int)*(cut-len));
}
```

　　

## 加减乘

　　略，加减复杂度为$\mathcal O(n)$，乘法用NTT$\mathcal O(n \log n)$计算

　　两个多项式的单纯乘法封装为如下函数：

```c++
// a,b: 两个多项式的指针
// c: 答案多项式的指针
// n,m: a和b的次数界
// out: 答案只取结果的前out位，默认全部取
void polyMul(int *a,int *b,int *c,int n,int m,int out=INF){
    static int f[NTT::LEN],g[NTT::LEN];
    int len=n+m-1;
    NTT::init(len);
    copy(f,a,n,NTT::n);
    copy(g,b,m,NTT::n);
    NTT::ntt(f,1);
    NTT::ntt(g,1);
    for(int i=0;i<NTT::n;i++) f[i]=1ll*f[i]*g[i]%MOD;
    NTT::ntt(f,-1);
    copy(c,f,min(len,out));
}
```

　　

## 求逆 

　　已知一个多项式$A(x)$，求一个多项式$B(x)$，使得


$$
\begin{equation}
A(x)B(x)\equiv1 \pmod {x^n} \ \ \ \ \ \ \ \ \ \ \ (1)
\end{equation}\\
$$

　　

　　采用倍增思路向上倍增模数并求解

　　当$n=1$时，$A(x)$与$B(x)$各自只剩下一个常数项，因此$B(x)$的常数项恰好等于$A(x)$常数项的逆元。多项式有无逆元也取决于这个常数是否有逆元

　　当$n > 1$时，假设我们已经求得$A(x)$在模$x^{\lceil\frac n 2\rceil}$意义下的逆元$B'(x)$

$$
\begin{equation}
A(x)B'(x)=1 \pmod{x^{\lceil\frac n 2\rceil}}\ \ \ \ \ \ \ \ \ \ \ (2)
\end{equation}
$$

　　而$(1)$放在模$x^{\lceil\frac n 2\rceil}$意义下同样成立，即

$$
\begin{equation}
A(x)B(x)\equiv1 \pmod {x^{\lceil\frac n 2\rceil}}\ \ \ \ \ \ \ \ \ \ \ \ (3)
\end{equation}
$$

　　将$(3)-(2)$，除去$A(x)$后可得	

$$
\begin{equation}
B(x)-B'(x)\equiv 0 \pmod {x^{\lceil\frac n 2\rceil}} \ \ \ \ \ \ \ \ \ \ \ (4)
\end{equation}
$$

　　平方得到

$$
\begin{equation} B^2(x)-2B(x)B'(x)+B'^2(x)\equiv 0 \pmod {x^n}  \end{equation}
$$

　　模数同时平方的原因是：$(4)$左边模$x^{\lceil\frac n 2\rceil}$为$0$，说明$x^0,x^1,\dots,x^{\lceil \frac n2 \rceil-1}$项的系数为$0$；平方后这些$0$系数会导致$x^0,x^1,\dots, x^{2\lceil \frac n2 \rceil}$项系数为$0$。注意到$2\lceil \frac n2 \rceil \ge n$，因此平方后的结果模$x^n$也为$0$。这也是倍增时使用上取整的原因——如果我们使用下取整，模数将不可顺利转化

　　两边同乘$A(x)$，消去$B(x)$并移项，得到

$$
B(x) \equiv 2B'(x) - A(x)B'^2(x) \pmod {x^n}
$$

　　至此我们可以得到一个倍增算法，代码如下：

```c++
void polyInv(int *a,int *b,int n){ // a是要求逆元的多项式，b是在模x^n意义下的a的逆元
    if(n==1){
        b[0]=INV(a[0]);
        return;
    }
    int m=(n+1)>>1;
    polyInv(a,b,m);
    static int f[NTT::LEN],g[NTT::LEN];
    NTT::init(2*m+n); // 注意长度
    copy(f,a,n,NTT::n);
    copy(g,b,m,NTT::n);
    NTT::ntt(f,1);
    NTT::ntt(g,1);
    for(int i=0;i<NTT::n;i++) f[i]=(2ll*g[i]-1ll*g[i]*g[i]%MOD*f[i]%MOD)%MOD;
    NTT::ntt(f,-1);
    copy(b,f,n);
}
```

　　时间复杂度$O(n \log n)$，不过我不知道怎么证。

　　

## 除法及取模

　　给定多项式$A(x)$和多项式$B(x)$，求两个多项式$D(x)$与$R(x)$，使得

$$
\begin{equation}  A(x)=D(x)B(x)+R(x) \ \ \ \ \ (1)
\end{equation}
$$

　　$A(x)$是被除数，$B(x)$是除数，$D(x)$是商，$R(x)$是余数

　　其中，$\text{deg}(A)>=\text{deg}(B)$ , $\text{deg}(D)\leq \text{deg}(A)-\text{deg}(B)$，$\text{deg}(R)<\text{deg}(B)$
　　

　　除法是用一些巧妙的变化来解决的

　　引入一个翻转多项式的概念：对于一个次数为$n$的多项式$A(x)$，定义

$$
A^R(x)=x^nA(\frac 1 x)
$$

　　你会发现$A^R(x)$的系数与$A(x)$的系数是镜像关系

　　将$(1)$的$x$换成$\frac 1 x$，并在两边同乘$x^n$；记$n=\text{deg}(A),\ m=\text{deg}(B),\  \text{deg}(D)=n-m, \ \text{deg}(R)=m-1$（注意此处$\text{deg}(D)$和$\text{deg}(R)$都默认取了最大次数），则有：

$$
\begin{aligned}
x^nA(\frac1x)&=x^{n-m}D(\frac1x)x^mB(\frac1x)+x^{n-m+1}x^{m-1}R(\frac1x)\\
A^R(x)&=D^R(x)B^R(x)+x^{n-m+1}R^R(x)
\end{aligned}
$$

　　如果把上式放在模$x^{n-m+1}$意义下，我们会发现$x^{n-m+1}R^R(x)$被完全模掉了！

　　于是

$$
\begin{aligned}
A^R(x)&\equiv D^R(x)B^R(x)\pmod{x^{n-m+1}}\\
D^R(x)&\equiv A^R(x)({B^R})^{-1}(x)\pmod{x^{n-m+1}}
\end{aligned}
$$

　　我们只需要求出$B^R$的逆元即可

```c++
void polyDiv(int *a,int *b,int *d){// a和b对应上文的A和B，d是上文的D，是答案
  	if(deg(a)<deg(b)) "令d为一个0多项式，返回";
	reverse(a);
  	reverse(b);
  	static int invb[];
  	polyInv(b,invb,deg(b)+1); //b次数界是\text{deg}(b)+1
  	d=a*invb;
  	reverse(d);
}
```

　　如果你还要求$R(x)$，带回最初的式子直接算就好，多项式乘法用*直接代替了

```c++
void polyMod(int *a,int *b,int *r){
  	if(deg(a)<deg(b)) "令r为a，返回";
  	static int d[];
  	polyDiv(a,b,d);
  	r=a-d*b;
}
```

　　

## 求$\ln$

　　已知一个多项式$f(x)$，并知关系$f(x)=e^{g(x)}$，求多项式$g(x)=\ln f(x)$

　　两边求导，得到

$$
g'(x)=\frac {f'(x)}{f(x)}
$$

　　所以

$$
g(x)=\int\frac{f'(x)}{f(x)}
$$

　　先对$f$求导（$\mathcal O(n)$），再与$f$的逆多项式相乘（都是$\mathcal O(n \log n)$），对结果再积分（$\mathcal O(n)$），得到$g(x)$

```c++
void polyDeri(int *a,int *b,int n){//计算一个次数界为n的多项式a的导数，放入b
	for(int i=0;i<n-1;i++) b[i]=1LL*(i+1)*a[i+1]%MOD;
	b[n-1]=0;
}
void polyInte(int *a,int *b,int n){//计算一个次数界为n的多项式a的积分，放入b
	for(int i=n-1;i>0;i--) b[i]=1LL*a[i-1]*inv[i]%MOD;
	b[0]=0;
}
void polyLn(int *f,int *g,int n){//整体计算于模x^n意义下进行
	static int t1[NTT::LEN],t2[NTT::LEN];
	polyDeri(f,t1,n);//求导，放入t1
	polyInv(f,t2,n);//求逆，放入t2
    polyMul(t1,t2,t1,n,n);
	polyInte(t1,g,n);//积分，放入g
}

```

　　

## 多项式牛顿迭代法

　　已知一个多项式$g(x)$，求$f(x)$使得$g(f(x))\equiv0\pmod{x^n}$

　　做法：倍增模数$x^n$。

　　当$n=1$时，根据$g(x)$的常数项解一下$f(x)$的常数项即可

　　假设已知$f_0(x)$使得

$$
g(f_0(x))\equiv0\pmod{x^{\lceil \frac n2\rceil}}
$$

　　根据泰勒展开@%#……&￥，可以构造$f(x)$

$$
f(x)\equiv f_0(x)-\frac{g(f_0(x))}{g'(f_0(x))}\pmod{x^n}
$$

　　使得$f(x)$可满足$g(f(x))\equiv0\pmod{x^n}$

　　

## 求exp

　　已知一个多项式$f(x)$，并知关系$g(x)\equiv e^{f(x)}\pmod{x^n}$，求$g(x)$

　　前置技能：多项式牛顿迭代法。

　　先化一波式子：

$$
\begin{aligned}
g(x)-e^{f(x)}&\equiv 0\pmod{x^n}\\
\ln g(x)-f(x)&\equiv 0 \pmod{x^n}
\end{aligned}
$$

　　其实就是要解多项式方程

$$
H(g(x))=\ln g(x)-f(x)\pmod{x^n}
$$

　　的根。其中$g(x)$是自变量，$f(x)$是常多项式。

　　套用多项式牛顿迭代，假设已知多项式$g_0(x)$满足

$$
\ln g_0(x)-f(x)\equiv 0\pmod{x^{\lceil \frac n2\rceil}}
$$

　　则可以构造$g(x)$

$$
\begin{aligned}
g(x)&\equiv g_0(x)-\frac{\ln g_0(x)-f(x)}{\frac 1 {g_0(x)}}\\
&\equiv g_0(x)*(1-\ln g_0(x)+f(x))\pmod{x^n}
\end{aligned}
$$

　　使得$g(x)$满足$\ln g(x)-f(x)\equiv 0\pmod{x^{n}}$。

　　向上倍增即可。 

```c++
void polyEXP(int *f,int *g,int n){
	if(n==1){
		g[0]=1;
		return;
	}
	static int t[S];
	polyEXP(f,g,(n+1)>>1);//求得g0，放在g中
	polyLn(g,t,n);//求g0的ln，放在t中
	for(int i=0;i<n;i++) t[i]=(f[i]-t[i])%MOD;//构造后面一个括号的多项式，还是放在t中
	t[0]++;
    polyMul(t,g,g,n,n,n);
}
```
