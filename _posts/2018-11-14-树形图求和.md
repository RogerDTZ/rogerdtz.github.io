---
layout: post
mathjax: true
title: 树形图求和
date: 2018-11-14-20:07:00
tag: [计数问题,矩阵树定理,数论---线性代数]
---
* content
{:toc}
# Description

　　给定一张$n$个点、$m$条边的有向图，每一条边有一个边权。我们保证这张图不存在自环，但可能有重边

　　请对于所有以$n$为根的内向树形图，求出它们的权值之和。一个内向树形图的权值定义为所有树边的边权之和

　　$n \le 300, m \le 100000$




# Solution

　　要知道一般的矩阵树定理只能计算生成树个数，却处理不了权值相关的统计。因此，我们得把求和的过程和生成树个数建立一些联系。

　　我们可以考虑每一条边$(u,v,w)$的贡献：如果我们能计算出使用这条边的生成树有多少个，我们就能知道$w$在答案中贡献了多少次

　　强制选边很难，考虑换一种方式：我们用原本的树形图个数，减去不含有这条边的树形图个数即可计算贡献次数。计算不含某一条边的树形图个数，只需要把这条边从原图中删去，再用矩阵树定理计算一次即可

　　但是这样复杂度太高。考虑删去某一条边$(u,v)$时，基尔霍夫矩阵$K$仅仅是$K_{u,v}$处加一，$K_{u,u}$处减一，两个更改位置处于同一行。我们将$K$按第$u$行展开得$\det K=\sum_{j=1}^nK_{i,j}A_{i,j}$，如果我们知道$A_{u,v}$和$A_{u,u}$两个代数余子式的值，我们就可以$O(1)$地在原方案数的基础上将其迅速调整为删去$(u,v)$后的图的方案数。

　　换句话说，我们能不能预处理所有代数余子式$A_{i,j}$呢？这个是有经典方法的。在推导矩阵的逆时，曾经引入了伴随矩阵，即
$$
\begin{aligned}
K^{-1}&=\frac{K^*}{\mid K\mid}\\
K^*&=|K|K^{-1}
\end{aligned}
$$
　　而转置矩阵$K^*$就是一个$\det K$所有代数余子式的一个表，我们只需要用高斯约当消元计算$K$的逆以及$K$的行列式意义下的值$\mid K\mid$，即预处理所有$A_{i,j}$

　　时间复杂度$O(n^3+m)$

　　BTW，最后计算时我们发现，其实调整的两个值之和就是包含那一条边的生成树个数



# Summary

　　矩阵树定理一般只能处理“生成树个数”问题；但如果要统计权值之和，可以用矩阵树定理辅助计算某一个元素的贡献次数

　　善用微调思想

　　正难则反，考虑用总数减去另一部分的值来计算需要的东西，可能更符合模型的能力范围



# Code

```c++
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MOD=1e9+7;
const int N=310,M=100010;
int n,m;
int edge[M][3];
int a[N][N],b[N][N];
int detVal;
int fastPow(int x,int y){
	int res=1;
	for(;y;x=1ll*x*x%MOD,y>>=1)
		if(y&1)
			res=1ll*res*x%MOD;
	return res;
}
void readData(){
	scanf("%d%d",&n,&m);
	int u,v,w;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&u,&v,&w);
		edge[i][0]=u; edge[i][1]=v; edge[i][2]=w;
		a[u][u]++;
		a[u][v]--;
	}
}
void GaussJordan(int n){
	for(int i=1;i<=n;i++) 
		b[i][i]=1;
	detVal=1;
	for(int i=1;i<=n;i++){
		int r;
		for(r=i;r<=n;r++)
			if(a[r][i])
				break;
		if(i!=r)
			for(int k=1;k<=n;k++){
				swap(a[i][k],a[r][k]);
				swap(b[i][k],b[r][k]);
			}
		detVal=1ll*detVal*a[i][i]%MOD;
		int inv=fastPow(a[i][i],MOD-2);
		for(int k=1;k<=n;k++){
			a[i][k]=1ll*a[i][k]*inv%MOD;
			b[i][k]=1ll*b[i][k]*inv%MOD;
		}
		for(int j=1;j<=n;j++)
			if(j!=i){
				int t=a[j][i];
				for(int k=1;k<=n;k++){
					(a[j][k]-=1ll*a[i][k]*t%MOD)%=MOD;
					(b[j][k]-=1ll*b[i][k]*t%MOD)%=MOD;
				}
			}
	}
}
void initCofT(int n){
	for(int i=1;i<n;i++)
		for(int j=i+1;j<=n;j++)
			swap(b[i][j],b[j][i]);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			b[i][j]=1ll*b[i][j]*detVal%MOD;
}
void solve(){
	int ans=0;
	int u,v,w;
	for(int i=1;i<=m;i++){
		u=edge[i][0]; v=edge[i][1]; w=edge[i][2];
		int noVal=detVal;
		(noVal+=b[u][v]%MOD)%=MOD;
		(noVal-=b[u][u]%MOD)%=MOD;
		(ans+=1ll*((detVal-noVal)%MOD)*w%MOD)%=MOD;
	}
	printf("%d\n",ans>=0?ans:ans+MOD);
}
int main(){
	readData();
	GaussJordan(n-1);
	initCofT(n-1);
	solve();
	return 0;
}
```

