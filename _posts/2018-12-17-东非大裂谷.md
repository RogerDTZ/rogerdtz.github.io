---
layout: post
mathjax: true
title: 东非大裂谷
date: 2018-12-17-20:26:00
tag: [DP---树形DP,方案特征,可做未做]
---
* content
{:toc}
# Description

　　有一棵树，每一个节点有一个权值

　　你要将所有节点分成若干个非空组，满足每一个组的元素都为祖先关系

　　定义一个组的权值为组内权值极差。求所有组的权值值和的最大值

　　$n \le 10^5$



　　

# Solution

　　$n^2$做法显然：设$f_u$表示考虑完$u$及其子树时，权值之和的最大值。转移时枚举$u$子树内的某一条由根出发的路径作为新的一组以转移

　　我们需要维护所有到根路径的最大值，但发现其并没有进一步优化的空间

　　考虑最优分组的性质，看看其是否能简化DP过程：

* 对于某一个组，最大值和最小值一定在祖先链的两端：如果两个极值不在路径两端，显然我们可以将路径向中间缩短直至顶住极值。这样做不会使得该组的权值更劣，反而还能为其他组留下更多考虑空间
* 对于某一个组，权值由浅到深要么不减，要么不增：如果出现不单调的情况，我们可以将路径分为至少两组，且这两组的权值之和必定优于当前组

　　有了最优分组的性质，我们的DP就有了着落：设$f_{u,0/1}$表示考虑完$u$的子树，$u$所在组由浅到深递增/递减时，子树内部的组的权值值和最大值为多少。显然有转移：

$$
sum=\sum_v\max(f_{v,0},f_{v,1})\\
f_{u,0}=\max\{sum-max(f_{v,0},f_{v,1})+f_{v,0}\mid w_u\le w_v\}\\
f_{u,1}=\max\{sum-max(f_{v,0},f_{v,1})+f_{v,1}\mid w_u\ge w_v\}\\
$$

　　答案即为$\max(f_{1,0},f_{1,1})$

　　时间复杂度$O(n)$

　　　　　　

# Code

```c++
#include <cstdio>
using namespace std;
typedef long long LL;
namespace IO{
    const int L=50000000;
    char inBuf[L],outBuf[L];
    int inPos,outPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    void flush(){
        fwrite(outBuf,1,outPos,stdout);
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        for(;c<'0'||c>'9';c=getChar()){if(c=='-')f=-1;}
        for(;'0'<=c&&c<='9';c=getChar()){x=x*10+c-'0';}
        return x*f;
    }
}
using IO::getInt;
inline LL max(LL x,LL y){
    return x>y?x:y;
}
inline void applyMax(LL &x,LL y){
    if(y>x)
        x=y;
}
const int N=100010;
int n;
int w[N];
namespace T{
    int h[N],tot;
    struct Edge{
        int v,next;
    }e[N];
    LL f[N][2];
    void addEdge(int u,int v){
        e[++tot]=(Edge){v,h[u]}; h[u]=tot;
    }
    void dp(int u){
        LL sum=0;
        for(int i=h[u],v;i;i=e[i].next){
            v=e[i].v;
            dp(v);
            sum+=max(f[v][0],f[v][1]);
        }
        f[u][0]=f[u][1]=sum;
        for(int i=h[u],v;i;i=e[i].next){
            v=e[i].v;
            if(w[u]<=w[v])
                applyMax(f[u][0],(sum-max(f[v][0],f[v][1]))+f[v][0]+(w[v]-w[u]));
            if(w[u]>=w[v])
                applyMax(f[u][1],(sum-max(f[v][0],f[v][1]))+f[v][1]+(w[u]-w[v]));
        }
    }
    void solve(){
        dp(1);
        printf("%lld\n",max(f[1][0],f[1][1]));
    }
}
void readData(){
    n=getInt();
    for(int i=1;i<=n;i++) w[i]=getInt();
    int u,v;
    for(int i=1;i<n;i++){
        u=getInt(); v=getInt();
        T::addEdge(u,v);
    }
}
int main(){
    IO::load();
    readData();
    T::solve();
    return 0;
}
```

