---
layout: post
mathjax: true
title: 抢夺
date: 2018-11-02-19:47:00
tag: [网络流]
---
* content
{:toc}
# Description

　　给定一个网络，源点为$1$，汇点为$n$，每一条边都有一个流量限制，流量流过每一条边的时间都为1

　　现在源点有$K$的流量要流向汇点，求所有流量全部流到汇点的最短用时

　　$n \le 1000,\ m \le 5000$



# Solution

　　虽然这题使用的结论好像假了，但本题在如何具体化模型的方面还是很有启发性的，因为我从开场到改题之前都对这道题的模型没有半点想象能力，即使我知道这题是网络流

　　假设我们找到了一条增广路$path$，其费用（即长度）为$dis$、流量为$flow$。若这条增广路在最优解中，那么这条增广路肯定是从一开始时就每时每刻从源点$S$发出$flow$的流量，沿着$path$向汇点前进。

　　我们对原图跑最小费用最大流，每找到一条增广路$path$，我们就相应地将途径的边流过$flow$的流量，不断重复寻找增广路，直到其不存在为止。同时，我们记录下每一条增广路的$dis$和$path$。它们的意义是什么呢？仔细思考一下就可以发现，每一条增广路都是一条可供源点流量选择的旅行路径。若源点每一时刻都按照每一条增广路分别发送对应的流量，在经过足够长的时间后（每一条增广路的第一波流量都到达汇点后），运输效率将会达到顶峰

　　这其实模拟了原问题中最优秀的安排策略。我们不再思考流量会不会在中途停留的问题，也不再考虑每一时刻每一个位置究竟是不是囤积了流量；我们只需要找出若干条路径，使得如果这几条路径同时运作，它们之间将不会产生任何阻碍和冲突，且运输效率最大

　　考虑给定一个时刻$t$，如何判定此时$K$点流量都已经流到终点？我们尝试列出汇点接受流量总和关于$t$的表达式，并用不等号与目标连接：

$$
\sum_{p\in P}[t\ge dis_p]flow_p(t-dis_p+1)\ge K
$$

　　最不好处理的就是条件部分，为此，我们可以分别对每一段条件相同的$t$进行计算。我们将增广路按照$dis$排序（其实最小费用最大流跑出来增广路长度就是递增的），当$t$取相邻两条增广路的长度之间时（$t \in [dis_i,dis_{i+1})$），$i+1$及之后的增广路都对式子没有贡献（从原问题上理解，就是这些增广路的第一波流量还没到达汇点），因此考虑的$p$是一个前缀。我们发现式子左边是一个关于$t$的一次函数，我们直接解出$t$的最小值，并判定其是否在当前范围内即可





# Code

```c++
#include <cstdio>
#include <queue>
#include <cmath>
using namespace std;
const int INF=1e9;
const int N=1010,M=5010;
int n,m,o;
struct Road{
    int dis,flow;
}r[N*N];
int rcnt;
namespace F{
    int flowS,flowT;
    int h[N],tot;
    struct Edge{
        int v,f,c,next;
    }e[M*2];
    void reset(){
        tot=1;
        for(int i=1;i<=flowT;i++) h[i]=0;
    }
    void setST(int s,int t){
        flowS=s; flowT=t;
    }
    void addEdge(int u,int v,int f,int c){
        e[++tot]=(Edge){v,f,c,h[u]}; h[u]=tot;
        e[++tot]=(Edge){u,0,-c,h[v]}; h[v]=tot;
    }
    queue<int> q;
    bool inq[N];
    int dis[N];
    int from[N][2]; // {node,edge}
    bool spfa(){
        for(int i=1;i<=flowT;i++){
            inq[i]=false;
            dis[i]=INF;
        }
        while(!q.empty()) q.pop();
        q.push(flowS);
        dis[flowS]=0;
        while(!q.empty()){
            int u=q.front();
            q.pop();
            for(int i=h[u],v;i;i=e[i].next)
                if(e[i].f){
                    v=e[i].v;
                    if(dis[u]+e[i].c<dis[v]){
                        from[v][0]=u; from[v][1]=i;
                        dis[v]=dis[u]+e[i].c;
                    //  if(!inq[v]){
                        //  inq[v]=true;
                            q.push(v);
                    //  }
                    }
                }
        }
        return dis[flowT]!=INF;
    }
    void makeFlow(){
        int flow=INF;
        for(int u=flowT;u!=flowS;u=from[u][0])
            flow=min(flow,e[from[u][1]].f);
        r[++rcnt]=(Road){dis[flowT],flow};
        for(int u=flowT;u!=flowS;u=from[u][0]){
            int id=from[u][1];
            e[id].f-=flow;
            e[id^1].f+=flow;
        }
    }
    void EK(){
        while(spfa())
            makeFlow();
    }
}
bool readData(){
    if(scanf("%d%d%d",&n,&m,&o)==-1)
        return false;
    F::setST(n+1,n+2);
    int u,v,c;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&u,&v,&c);
        u++; v++;
        F::addEdge(u,v,c,1);
    }
    F::addEdge(F::flowS,1,o,0);
    F::addEdge(n,F::flowT,o,0);
    return true;
}
void reset(){
    rcnt=0;
    F::reset();
}
void solve(){
    int sum=0;
    for(int i=1;i<=rcnt;i++) sum+=r[i].flow;
    if(!sum){
        puts("No solution");
        return;
    }
    r[rcnt+1].dis=INF;
    int k=0,b=0,low;
    for(int i=1;i<=rcnt;i++){
        k+=r[i].flow;
        b+=(-r[i].dis+1)*r[i].flow;
        low=(int)ceil(1.0*(o-b)/k);
        if(r[i].dis<=low&&low<r[i+1].dis){
            printf("%d\n",low);
            return;
        }
    }
}
int main(){
    while(true){
        reset();
        if(!readData())
            break;
        if(!o){
            puts("0");
            continue;
        }
        F::EK();
        solve();
    }
    return 0;
}
```

 