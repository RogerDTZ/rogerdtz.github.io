---
layout: post
mathjax: true
title: 多线程
date: 2018-12-29-19:28:00
tag: [DP,单调栈,好题]
---
* content
{:toc}
# Description

　　给一个长度为$n$的序列$a$，保证没有两个元素是相同的

　　求有多少种将$a$划分成两个子序列的方式，满足第一个子序列单调递增，且第二个子序列单调递减

　　$T \le 10, \ n \le 5*10^5$



　　

# Solution

　　记上升栈为$A$，下降栈为$B$

　　先回顾一下暴力DP：$f_{i,j}$表示考虑完序列前$i$位，$A$栈顶为$a_i$、$B$栈顶为$j$时的方案数；同理，$g_{i,j}$为$B$栈顶为$a_i$、$A$栈顶为$j$时的方案数
$$
a_{i-1}<a_i:\left \{ \begin{aligned}
f_{i-1,j} &\rightarrow f_{i,j}\\
&\rightarrow g_{i,a_{i-1}} &(j>a_i)\\
g_{i-1,j} &\rightarrow f_{i,a_{i-1}} &(j<a_i)
\end{aligned} \right \}
\\ a_{i-1}>a_i:
\left\{
\begin{aligned}
    g_{i-1,j} &\rightarrow g_{i,j}\\
      &\rightarrow f_{i,a_{i-1}} &(j<a_i)\\
    f_{i-1,j} &\rightarrow g_{i,a_{i-1}} &(j>a_i)
\end{aligned}
\right \}
$$
　　直接用两棵线段树搞一下就行

　　几个观察：

- 第二维是“一次性”的，仅在第一维的某一段区间有值
- 每次转移会抹除$g$/$f$中的大部分数据，只剩下一个位置有值，还是从$f$/$g$贡献过来的
- $A$和$B$的选择具有制约性，一者不选一个元素另一者就一定要选

　　对于某个$i$，考虑用两个数据结构维护$f_i$和$g_i$中有用的第二维及其值。拿$f_i$来说，我们只需要考虑$B$在这些位置结尾的答案即可，即只需要记录$j$为这些下标时的$f_{i,j}$：

1. 在$a$中，以$a_{i-1}$为结尾的极长连续上升栈中的每一个位置
2. 上述上升栈开头的前一个元素$a_p$

　　再往前的第二维就没用了：根据第3条观察，只要$B$的结束位置在$p$的左边，$a_{p+1}...a_{i}$显然不可能组成一个单调增的序列

　　$g_i$同理

　　注意到除了第一个元素，其余元素都是单调增或单调减的，因此我们使用两个单调栈分别记录有用的第二维，再特别地记录第一个元素即可。每一次发生转折就清空有冲突的栈并推入第一个元素

　　具体来说，记主栈为当前满足$a_{i-1}$和$a_i$关系的栈，副栈为另一个。第一条转移为继承，不予处理；第二条转移用主栈的第一个元素判定即可，显然只可能从那里过来；第三条转移，枚举副栈中元素即可，注意到它们会被立刻弹出，根据第一条观察，这一步有势能保障

　　时间复杂度$O(n)$

　　

# Code

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <utility>
#define MP make_pair
#define FR first
#define SE second
using namespace std;
const int INF_DANGER=2e9;
const int N=500000+10;
typedef pair<int,int> PII;
inline int max(int x,int y){
	return x>y?x:y;
}
namespace IO{
	const int LEN=80000000;
	char *inBuf;
	void init(){
		inBuf=new char[LEN];
		fread(inBuf,1,LEN,stdin);
	}
	char getChar(){
		return *(inBuf++);
	}
	int getInt(){
		int x=0,f=1;
		char c=getChar();
		while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
		while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
		return x*f;
	}
}
using IO::getInt;
int n;
int a[N];
void readData(){
	n=getInt();
	for(int i=1;i<=n;i++) a[i]=getInt();
}
void solve(){
	if(n==0){
		puts("1");
		return;
	}
	static PII s0[N],s1[N]; /* s0/ s1\ */
	static int top0,top1;
	static int ans0,ans1;
	s0[top0=0]=MP(+INF_DANGER,1);
	s1[top1=0]=MP(-INF_DANGER,1);
	ans0=ans1=1;
	for(int i=2;i<=n;i++)
		if(a[i-1]<a[i]){
			int t1=(s0[0].FR>a[i]?s0[0].SE:0);
			int t0=(s1[0].FR<a[i]?s1[0].SE:0);
			for(;top1;top1--) t0+=(s1[top1].FR<a[i]?s1[top1].SE:0);
			s0[++top0]=MP(a[i-1],t0);
			s1[top1=0]=MP(a[i-1],t1);
			ans0+=t0;
			ans1=t1;
		}else{ // a[i-1]>a[i]
			int t0=(s1[0].FR<a[i]?s1[0].SE:0);
			int t1=(s0[0].FR>a[i]?s0[0].SE:0);
			for(;top0;top0--) t1+=(s0[top0].FR>a[i]?s0[top0].SE:0);
			s1[++top1]=MP(a[i-1],t1);
			s0[top0=0]=MP(a[i-1],t0);
			ans1+=t1;
			ans0=t0;
		}
	printf("%d\n",ans0+ans1);
}
int main(){
	IO::init();
	for(int caseNum=getInt();caseNum;caseNum--){
		readData();
		solve();
	}
	return 0;
}
```

