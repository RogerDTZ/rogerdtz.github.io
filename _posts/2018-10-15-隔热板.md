---
layout: post
mathjax: true
title: 隔热板
date: 2018-10-15-20:42:00
tag: [转化,二分答案,倍增,可做未做]
---
* content
{:toc}
# Description

![img](http://xsy.gdgzez.com.cn/JudgeOnline/upload/201503/griqomvthnirqorwmithnqroiv.jpg)

　　$1 \le n \le 40000$



# Solution

　　看到题直接往二分答案上想

　　我们二分答案$r$，则每一条直线与原点的距离不得小于$r$。这等价于以原点为圆心作一个半径为$r$的圆，并保证所有直线与圆不相切

　　现在我们要判定是否存在一种方案，使得作$m$条直线后，外侧覆盖所有的点

　　我们观察到一个很显然的贪心：$m$条直线都最好贴在圆上，因为这样期望最优。因此，每一条直线都可以用圆上的某一个切点表示

　　现在的目标是使得直线外侧覆盖到所有的点。若直接考虑怎么选直线并覆盖到所有点非常困难，没有任何模型可以构建；我们转而考虑每一个点如何才能被覆盖：过这个点作圆的两条切线，观察得到的两个切点，我们发现：这个点能被覆盖，当且仅当有至少一条直线的切点在这两个切点之间

　　问题转化为：给一个圆，圆上有$n$个线段。你有$m$次机会，每次机会可以在圆上点一个点，并删去（满足）包含它的所有区间。问是否能删去所有区间？

　　我们转而考虑最少能用多少步删去所有区间。假设我们固定了开始区间，依照一个经典贪心策略，我们选择该区间的右端点，并将覆盖的区间全部删去，然后找到右边第一个未被删去的区间，重复上述过程。若加上枚举开始区间，直接做的复杂度将为$O(n^2)$；但我们注意到，对于某一个区间，对其进行删右端点的操作后，所谓的下一个区间是固定的。这启示我们用倍增加速判定的过程，即倍增求解最少使用多少步才能删去所有区间。这样单次判定的复杂度就降为了$O(n \log n)$

　　实现细节较多：

1. 环上区间问题：对$n$个初始区间排好序后，我们将所有区间复制一份后整体偏移$2\pi$作为另一份存在。这样在倍增的时候就比较好操作

2. 如何找到右边下一个区间：对所有区间按右端点为第一关键字、左端点为第二关键字排序，我们采用双指针直接扫描维护即可。可以证明，第二个指针指向的第一个未被第一个指针指向区间覆盖的区间，一定是必要的、最近的下一个区间

3. 区间涉及到边界突变问题：如果我们需要对区间判定某些性质（如2.），意外的$\pm 2\pi$可能会导致莫名其妙的BUG。因此必须对症下药：如2.，若右端点是合法、有序且无歧义，则左端点也必定是合法有序无歧义的，且满足2.的性质使得判定正确，因此我们应该按右端点整理，以右端点为标杆整理到$[0,2\pi)$内即可

4. 若区间互相包含：若一个大区间包含小区间，我们可以把大区间删去，这样可以减少问题规模并快上好几倍。一个非常隐蔽的问题是：切忌在1.复制区间后，判定包含并删除，这样可能会使得整个序列$a$不满足$a_i=a_{n+i}$（在区间意义上），从而导致在跳倍增的时候判定终点出现牛头不对马嘴的情况

	正确做法应该是在对初始区间排序后，直接删除不必要区间，再复制。这样就能保证前后是一一对应的



# Summary

　　题目要求我们选择某一些方案以满足要求时，如果直接考虑如何选方案才能满足所有要求很难，不妨反过来考虑：对于每一个要求，出现具有什么特征的方案时，自己才能被满足；并通过综合每个要求提供的特征，来构建全局选择方案的模型



# Code

```c++
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;
const int N=40010;
const int INF=1e9;
const double DINF=1e40;
const double PI=acos(-1.0);
int n,m;
struct Point{
    int x,y;
};
struct Segment{
    double l,r;
    void adjust(){
        while(r>=2*PI)
            l-=2*PI, r-=2*PI;
        while(r<0)
            l+=2*PI, r+=2*PI;
    }
    friend bool operator == (const Segment &a,const Segment &b){
        return a.l==b.l&&a.r==b.r;
    }
    friend bool operator < (const Segment &a,const Segment &b){
        return a.r!=b.r?(a.r<b.r):(a.l<b.l);
    }
};
Point p[N*2];
Segment s[N*2];
int len,cnt;
int trans[N*2][18];
void readData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d%d",&p[i].x,&p[i].y);
}
double getMinDis(){
    double res=DINF;
    for(int i=1;i<=n;i++)
        res=min(res,sqrt(p[i].x*p[i].x+p[i].y*p[i].y));
    return res;
}
void initSegment(double r){
    double dis,alpha,beta;
    for(int i=1;i<=n;i++){
        dis=sqrt(p[i].x*p[i].x+p[i].y*p[i].y);
        alpha=acos(p[i].x/dis);
        if(p[i].y<0)
            alpha=2*PI-alpha;
        beta=acos(r/dis);
        s[i]=(Segment){alpha-beta,alpha+beta};
        s[i].adjust();
    }
    sort(s+1,s+1+n);
    for(int i=1;i<n;i++)
        if(s[i].l>=s[i+1].l)
            s[i+1]=s[i];
    cnt=unique(s+1,s+1+n)-s-1;
    len=cnt*2;
    for(int i=1;i<=cnt;i++){
        s[cnt+i]=s[i];
        s[cnt+i].l+=2*PI;
        s[cnt+i].r+=2*PI;
    }
    for(int i=0;i<=17;i++) trans[len+1][i]=len+1;
    for(int i=1,j=1;i<=len;i++){
        while(j<=len&&s[j].l<=s[i].r)
            j++;
        trans[i][0]=j;
    }
    for(int j=1;j<=17;j++)
        for(int i=1;i<=len;i++)
            trans[i][j]=trans[trans[i][j-1]][j-1];
}
int calcStep(double r){
    initSegment(r);
    int res=INF;
    for(int start=1;start<=cnt;start++){
        int u=start,use=1,rest=cnt;
        for(int i=17;i>=0;i--)
            if(trans[u][i]<start+cnt&&trans[u][i]-u<rest){
                use+=(1<<i);
                rest-=trans[u][i]-u;
                u=trans[u][i];
            }
        res=min(res,use);
    }
    return res;
}
void solve(){
    double l=0,r=getMinDis(),mid;
    double stopEPS=1e-4;
    while(l+stopEPS<r){
        mid=(l+r)*0.5;
        if(calcStep(mid)<=m)
            l=mid;
        else
            r=mid;
    }
    printf("%.2lf\n",mid);
}
int main(){
    readData();
    solve();
    return 0;
}
```

