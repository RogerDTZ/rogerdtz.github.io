---
layout: post
mathjax: true
title: 杨柳
date: 2018-11-25-18:00:00
tag: [网络流---费用流,简化,可做未做]
category: 2018冬令营模拟测试赛
---
* content
{:toc}
# Description

　　略



# Solution

　　对于“同一时刻同一位置不可以有多于一个棋子”的条件，我们假象这样一个情况：棋子$A$去向目标时需要经过或停在位置$X$，而就在$A$走到$X$时，有另一个棋子$B$也要走到$X$以去向它的目的地。如果$A$是经过$X$，我们可以先让$A$走下一步，则$B$就可以继续前进；如果$A$停在$X$，我们完全可以让$A$走完$B$剩下要走的路去到$B$的目的地，而让$B$停留在$A$的目的地$X$

　　这样一番思考，我们发现：这个限制条件是没有任何意义的。无解情况会发生，当且仅当某一些棋子迫于障碍和边界无法到达某一个目的地

　　因此，我们只需要给每一个棋子安排走法，使得最后所有棋子都在某一个目的地上，且总步数最小

　　考虑费用流：

* 从源点$S$向每一个出发点连一条流量为1、费用为0的单向边
* 从每一个目的地向汇点$T$连一条流量为1、费用为0的单向边
* 对于任意两个可以互达的格子，连一条流量为$\infty$、费用为1的双向边

　　直接跑费用流即可。若未满流，则说明无解；若满流，最小费用即为最小步数



# Summary

　　对于调度问题而言，如果操作对象与目的地没有严格的对应关系，可以考虑使用交换后续方案的思想简化条件（类似的题还有自己组的题的T2）

　　整体进行的、感觉没办法逐步考虑的问题，考虑使用网络流解决



# Code

```c++
#include <cstdio>
#include <queue>
using namespace std;
const int INF=1e9;
const int RC=110;
const int N=10010;
int r,c,n,a,b;
int st[N][2],ed[N][2];
bool bad[RC][RC];
namespace F{
    int h[N],tot;
    struct Edge{
        int v,f,c,next;
    }e[N*300];
    int flowS,flowT;
    void addEdge(int u,int v,int f,int c){
        e[++tot]=(Edge){v,f,c,h[u]}; h[u]=tot;
        e[++tot]=(Edge){u,0,-c,h[v]}; h[v]=tot;
    }
    queue<int> q;
    int dis[N];
    bool inQueue[N];
    int cur[N];
    bool spfa(){
        for(int i=1;i<=flowT;i++){
            inQueue[i]=false;
            dis[i]=INF;
            cur[i]=h[i];
        }
        while(!q.empty()) q.pop();
        q.push(flowS);
        dis[flowS]=0;
        inQueue[flowS]=true;
        while(!q.empty()){
            int u=q.front();
            q.pop();
            inQueue[u]=false;
            for(int i=h[u],v;i;i=e[i].next)
                if(e[i].f&&dis[v=e[i].v]>dis[u]+e[i].c){
                    dis[v]=dis[u]+e[i].c;
                    if(!inQueue[v]){
                        q.push(v);
                        inQueue[v]=true;
                    }
                }
        }
        return dis[flowT]!=INF;
    }
    int costSum;
    bool inStack[N];
    int dfs(int u,int flow){
        if(u==flowT){
            costSum+=flow*dis[u];
            return flow;
        }
        inStack[u]=true;
        int res=0,get;
        for(int i=cur[u],v;i&&flow;i=e[i].next)
            if(e[i].f&&dis[v=e[i].v]==dis[u]+e[i].c&&!inStack[v]){
                get=dfs(v,min(flow,e[i].f));
                e[i].f-=get;
                e[i^1].f+=get;
                if(e[i].f)
                    cur[u]=i;
                flow-=get;
                res+=get;
            }
        inStack[u]=false;
        if(!res)
            dis[u]=-1;
        return res;
    }
    void MCF(){
        int res=0;
        while(spfa())
            res+=dfs(flowS,INF);
        if(res<n)
            puts("-1");
        else
            printf("%d\n",costSum);
    }
    void init(int s,int t){
        flowS=s; flowT=t;
        tot=1;
    }
}
void readData(){
    scanf("%d%d%d%d%d",&r,&c,&n,&a,&b);
    static char str[RC];
    for(int i=1;i<=r;i++){
        scanf("%s",str+1);
        for(int j=1;j<=c;j++)
            if(str[j]=='*')
                bad[i][j]=true;
    }
    for(int i=1;i<=n;i++)
        scanf("%d%d",&st[i][0],&st[i][1]);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&ed[i][0],&ed[i][1]);
}
inline int ID(int x,int y){
    return (x-1)*c+y;
}
inline void link(int id,int x,int y){
    if(x<1||x>r||y<1||y>c)
        return;
    if(bad[x][y])
        return;
    F::addEdge(id,ID(x,y),INF,1);
}
void builGraph(){
    F::init(r*c+1,r*c+2);
    for(int i=1;i<=n;i++){
        F::addEdge(F::flowS,ID(st[i][0],st[i][1]),1,0);
        F::addEdge(ID(ed[i][0],ed[i][1]),F::flowT,1,0);
    }
    for(int x=1;x<=r;x++)
        for(int y=1;y<=c;y++)
            if(!bad[x][y]){
                int cur=ID(x,y);
                link(cur,x-a,y-b);
                link(cur,x-a,y+b);
                link(cur,x+a,y-b);
                link(cur,x+a,y+b);
                link(cur,x-b,y-a);
                link(cur,x-b,y+a);
                link(cur,x+b,y-a);
                link(cur,x+b,y+a);
            }
}
int main(){
    readData();
    builGraph();
    F::MCF();
    return 0;
}
```

