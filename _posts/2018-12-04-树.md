---
layout: post
mathjax: true
title: 树
date: 2018-12-04-09:26
tag: [容斥原理,括号序列]
category: 
---
* content
{:toc}
# Description

　　![](http://xsy.gdgzez.com.cn/JudgeOnline/upload/attachment/image/20180612/20180612083209_99239.png)



# Solution

　　题目给出的模型很复杂，因此我们需要对题意先进行一步转化：

　　可以证明，一棵满二叉树不包含$m​$连树，当且仅当对于任意一条从根节点出发走到叶子节点的路径，向左走的次数都少于$m-1​$

　　证明如下：

* 先证必要性：使用反证法：若存在一条到叶路径满足向左走的次数不少于$m-1$，则显然可以找出一棵能操作得到的$m$连树。故必要性成立
* 再证充分性：提取一棵$m$连树的条件是原树中存在类似的树形。由于所有到叶路径的向左次数少于$m-1$，感性理解一下，我们无法从这种满二叉树中提出$m$连树

　　故二者满足充分必要性

　　考虑一棵满二叉树的括号序列表示：从只有根节点开始，左括号代表添加一个左儿子并进入，右括号代表回溯到DFS栈中最深的、没有右儿子的点，为其添加一个右儿子并进入。可以发现，一棵有$n$个叶子满二叉树，唯一对应了一个长度为$2(n-1)$的合法括号序列，反之也唯一对应

　　若把左右括号分别看成1和-1，一棵满二叉树的任意到叶路径向左走的次数皆少于$m-1$，当且仅当其对应的括号序列的任意前缀和小于$m-1$

　　问题转化为：有多少长度为$2n$的合法括号序列，满足任意前缀和小于$m-1$？（注意我们已经用$n$来表示原问题的$n-1$了）

　　首先，总方案数为$2n \choose n$

　　对于不合法的括号序列，考虑其特征：我们尝试减去那些碰到过$-1$和$m-1$的括号序列：考虑碰到过$-1$的括号序列，我们将第一个前缀和等于$-1$的位置之后的所有括号反转，则可以得到一个结束时前缀和等于$-2$的括号序列；可以发现，反转前的不合法序列，和反转后的序列唯一对应。后者的总数为${2n \choose n-1}$，则前者也为$2n \choose n-1$。这个组合数的原理是：总数的一半减去总和之差的一半，恰好等于某一个括号的数量，做组合数即可。同理，对于触碰到$m-1$的序列，我们将第一个前缀和等于$m-1$的位置之后的所有括号反转，可得结束时前缀和等于$2m-2$的序列，因此总数为${2n \choose m-1}$

　　问题在于，我们可能减去了先碰$-1$后碰$m-1$、以及先碰$m-1$后碰$-1$的那些序列，应该把他们加回来。我们已经可以看出容斥的影子：每一种不合法情况都可以表示为$0\rightarrow-1\rightarrow m-1\rightarrow -1 \rightarrow\dots \rightarrow 0$或者$0 \rightarrow m-1 \rightarrow -1 \rightarrow m-1 \rightarrow \dots\rightarrow 0$的形式，其长度决定了容斥系数。我们枚举长度，考虑该长度的两种形式的情况总数：我们用之前类似的思想不断反转序列，直到变为$0 \rightarrow x \rightarrow 0$的形式，那么方案数即为$2n \choose n+\frac x2$

　　时间复杂度为$O(n)$



# Code

```c++
#include <cstdio>
using namespace std;
typedef long long LL;
const int MOD=998244353;
const int N=10000010;
int n,m;
void readData(){
    scanf("%d%d",&n,&m);
    n--;
}
int fastPow(int x,int y){
    int res=1;
    for(;y;x=1ll*x*x%MOD,y>>=1)
        if(y&1)
            res=1ll*res*x%MOD;
    return res;
}
int fact[N*2],iact[N*2];
void initFact(int n){
    fact[0]=1;
    for(int i=1;i<=n;i++) fact[i]=1ll*fact[i-1]*i%MOD;
    iact[0]=iact[1]=1;
    iact[n]=fastPow(fact[n],MOD-2);
    for(int i=n-1;i>=2;i--) iact[i]=1ll*iact[i+1]*(i+1)%MOD;
}
inline int C(int n,int m){
    return (0<=m&&m<=n)?1ll*fact[n]*iact[m]%MOD*iact[n-m]%MOD:0;
}
inline int S(int delta){
    return C(n<<1,n+(delta>>1));
}
void calc(){
    LL ans=S(0);
    int s1=0,s2=0;
    for(int len=1,sgn=-1;s1<=(n<<1)||s2<=(n<<1);len++,sgn=-sgn){
        s1+=(len&1)?2:((m<<1)-2);
        ans+=sgn*S(s1);
        s2+=(len&1)?((m<<1)-2):2;
        ans+=sgn*S(s2);
    }
    ans%=MOD;
    printf("%lld\n",ans>=0?ans:ans+MOD);
}
int main(){
    readData();
    initFact(20000000);
    calc();
    return 0;
}
```

