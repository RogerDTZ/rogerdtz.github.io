---
layout: post
mathjax: true
title: 【AGC001D】Snuke 回文生日礼物
date: 2018-10-24-16:11:00
tag: [结论题]
category: 2017国家集训队作业
---
* content
{:toc}
# Description

　　给一个长度为$M$的数组$A$，满足元素之和为$N$

　　你可以将$A$任意排列。请你判断下面这种情况能否出现：

1. 有一某个长度为$N$的字符串$S$，其首$A_1$项、接下来$A_2$项、接下来$A_3$项...各自构成回文串
2. 是否存在另一个元素和为$N$、任意长度的数组$B$（元素全为正整数），强迫$S$首$B_1$项、接下来$B_2$项、接下来$B_3$项...各自构成回文串后，$S$必定是一个全部字符都相同的字符串

　　如果存在，输出$B$；否则输出"Impossible"

　　$N \le 10^5 \ M\le 100$



# Solution

　　$A$的要求等价于某一段字符串要对称，即对称的字符相等。确定完$A$的排列顺序后，我们可以在$S$的上方画出$A$的限制——两个相等的字符连一条边。可以发现，这些边构成了一些简单的上彩虹（不会一个彩虹内嵌套两个彩虹）。如果我们再对$B$构造出某一种画下彩虹的方案，使得所有$N$个点都处于一个连通块内，那么这个方案就是合法的

　　那么我们应该先考虑如何将$A$重排，然后考虑$B$的行为策略

　　首先必须发现一个性质：如果$A$中的元素全是偶数，即每个彩虹的正中心都不是一个单点，此时$B$总能使得全部点连通。具体做法是：对于$A$最左边的彩虹$A_1$，用一个宽度为$A_1-2$的下彩虹靠左覆盖它的一部分，再用一个宽度为1的彩虹覆盖接下来的一个元素（即$S_{A_1-1}$）。此时$A_1$这个彩虹的内部已经连通，并且在最右边的位置伸出了一个代表当前彩虹所有元素的接口。接下来，我们按顺序输出$A_2...A_{m-1}$作为$B$的接下来的彩虹宽度，错位连接$A_1,A_2,...,A_{m-1}$，每画一次下彩虹，总会留下一个代表了之前所有彩虹包含的元素的接口。最后，只需要考虑一下最后的情况，用一个偶数长度的下彩虹或者一个奇数长度的下彩虹加上一个单点就可以闭合。**可以发现**这样做总能将所有元素连接成一个连通块

　　其次，我们通过画彩虹来连通每一个元素的行为模式与一笔画问题十分相似。观察$A$中的每一个彩虹，如果其长度为奇数，那么其正中心会留下一个“端口”，这个端口不能继续延伸，只能接入。因此，如果$A$中奇数数量超过了2，我们就无法用一条只有两个端点的曲线一笔画，此时无解

　　现在剩余的情况只有奇数彩虹数目为1或2的情况了。我们提出一个简化的思想：将奇数彩虹提到$A$的最前和最后，再来构造B

　　可以发现，只要采取类似的操作使得第一个人只留下一个接口（若是偶数用前面的做法，若奇数显然直接用一个$A_1-1$的下彩虹即可），然后顺序输出$A_2\dots A_{m-1}$，最后特判如何闭合即可（偶数同前，奇数直接$A_m$）



# Summary

　　特殊的、决定全局的东西，构造和考虑时可以放到一个特殊的位置，简化考虑过程



# Code

```c++
#include <cstdio>
#include <algorithm>
#define LHX_BAOLING {puts("Impossible"); return 0;}
using namespace std;
const int N=100010,M=110;
int n,m;
int a[M];
int p1,p2;
int b[N],bcnt;
void readData(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d",&a[i]);
}
bool judge(){
    p1=p2=-1;
    for(int i=1;i<=m;i++)
        if(a[i]&1){
            if(p1==-1)
                p1=i;
            else if(p2==-1)
                p2=i;
            else return false;
        }
    return true;
}
void construct(){
    if(p1!=-1){
        swap(a[1],a[p1]);
        p1=1;
    }
    if(p2!=-1){
        swap(a[p2],a[m]);
        p2=m;
    }
    for(int i=1;i<=m;i++) printf("%d ",a[i]);
    puts("");
    if(m==1){
        if(a[1]&1){
            if(a[1]-1)
                b[++bcnt]=a[1]-1;
            b[++bcnt]=1;
        }
        else{
            if(a[1]-2)
                b[++bcnt]=a[1]-2;
            b[++bcnt]=2;
        }
    }
    else{
        if(a[1]&1){
            if(a[1]-1)
                b[++bcnt]=a[1]-1;
        }
        else{
            if(a[1]-2)
                b[++bcnt]=a[1]-2;
            b[++bcnt]=1;
        }
        for(int i=2;i<m;i++)
            b[++bcnt]=a[i];
    }
    int sum=0;
    for(int i=1;i<=bcnt;i++) sum+=b[i];
    if(n-sum){
        int x=n-sum;
        if(x&1){
            if(x-1)
                b[++bcnt]=x-1;
            b[++bcnt]=1;
        }
        else
            b[++bcnt]=x;
    }
    printf("%d\n",bcnt);
    for(int i=1;i<=bcnt;i++) printf("%d ",b[i]);
    puts("");
}
int main(){
    readData();
    if(!judge())
        LHX_BAOLING;
    construct();
    return 0;
}
```

 