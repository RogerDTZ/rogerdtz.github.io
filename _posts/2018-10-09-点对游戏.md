---
layout: post
mathjax: true
title: 点对游戏
date: 2018-10-09-16:00:00
tag: [概率与期望,点分治]
---
* content
{:toc}
# Description

　　有一棵$n$个点的树，边的长度皆为1

　　现在，有三个人轮流从未被选择的点中等概率地选择一个点占为己有，直到全部点都被选过为止

　　给定$m$个互不相同的幸运数

　　定义一个人的收益为：自己拥有的点中，有多少无序点对满足二者距离为幸运数

　　求每个人的期望收益

　　$n \le 10000, \ m \le 10$



# Solution

　　首先观察到，每一个人最终拥有的点数是固定的，记为$a_0,a_1,a_2$

　　再考虑到题目提到的”等概率“，很容易猜想到：每一个人其实都是独立随机地从$n$个点中选择$a$个点

　　总方案数显然是$n \choose a$，考虑计算每种方案的收益之和$\sum$，即可算出期望

　　自顶向下不好考虑，正难则反，每一个贡献都发生在一个合法点对上。考虑某一个满足$u$与$v$的距离为幸运数的合法点对，它在$\sum$中贡献的次数恰好是${n-2 \choose a-2}$

　　因此，若求得原树上合法点对数量为$plan$，则可以直接计算期望：

$$
\begin{aligned}
ans&=\frac{{n-2 \choose a-2} plan }{n \choose a}\\
&=plan*n(n-1)a(a-1)
\end{aligned}
$$

　　由于$m$较小，我们直接使用点分治计算每一个幸运数对应的合法点对数量，求和即为$plan$

# Summary

　　如果过程完全随机，不妨舍弃模拟原过程的思路，而单独考虑每一个对象本身，因为此时每一个对象得到的结果可以看做独立主观随机

# Code

```c++
#include <cstdio>
#include <algorithm>
#include <queue>
#define mp make_pair
#define FR first
#define SE second
using namespace std;
namespace IO{
    const int S=10000000;
    char buf[S];
    int pos;
    void load(){
        fread(buf,1,S,stdin);
        pos=0;
    }
    char getChar(){
        return buf[pos++];
    }
    int getInt(){
        int x=0,f=1;
        char c=getChar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
typedef long long ll;
typedef pair<int,int> pii;
const int N=50010,M=15;
const int INF=1e9;
int n,m;
int lucky[M];
ll sum[M];
int h[N],tot;
struct Edge{
	int v,next;
}e[N*2];
int fact[N],iact[N];
void addEdge(int u,int v){
	e[++tot]=(Edge){v,h[u]}; h[u]=tot;
	e[++tot]=(Edge){u,h[v]}; h[v]=tot;
}
void readData(){
	n=getInt(); m=getInt();
	for(int i=1;i<=m;i++) lucky[i]=getInt();
	int u,v;
	for(int i=1;i<n;i++){
		u=getInt(); v=getInt();
		addEdge(u,v);
	}
}
namespace P{ 
	bool cut[N];
	int size[N];
	int curbest,curval;
	int lis[N],cnt;
	void findRoot_dfs(int u,int fa,int cursize){
		size[u]=1;
		int maxsub=-1;
		for(int i=h[u],v;i;i=e[i].next)
			if((v=e[i].v)!=fa&&!cut[v]){
				findRoot_dfs(v,u,cursize);
				size[u]+=size[v];
				maxsub=max(maxsub,size[v]);
			}
		maxsub=max(maxsub,cursize-size[u]);
		if(maxsub<curval){
			curbest=u;
			curval=maxsub;
		}
	}
	int findRoot(int u,int cursize){
		curbest=-1; curval=INF;
		findRoot_dfs(u,0,cursize);
		return curbest;
	}
	void calc_collect(int u,int fa,int off){
		cnt=0;
		static int pre[N];
		pre[u]=fa;
		static queue<pii> q;
		while(!q.empty()) q.pop();
		q.push(mp(u,off));
		while(!q.empty()){
			int u=q.front().FR,dis=q.front().SE;
			q.pop();
			lis[++cnt]=dis;
			for(int i=h[u],v;i;i=e[i].next)
				if(!cut[v=e[i].v]&&v!=pre[u]){
					pre[v]=u;
					q.push(mp(v,dis+1));
				}
		}
	}
	void calc(int u,int fa,int off,int a){
		calc_collect(u,fa,off);
		for(int k=1,x;k<=m;k++){
			x=lucky[k];
			for(int i=1,j=cnt;i<j;){
				while(i<j&&lis[i]+lis[j]>x) j--;
				if(i>=j)
					break;
				int num=0;
				while(i<j&&lis[i]+lis[j]==x){
					num++;
					j--;
				}
				if(lis[i]*2==x){
					sum[k]+=1ll*a*num*(num+1)/2;
					break;
				}
				else{
					int t=i;
					while(lis[i]==lis[t]&&i<=cnt){
						sum[k]+=1ll*a*num;
						i++;
					}
				}
			}
		}
	}
	void solve(int x,int cursize){
		int u=findRoot(x,cursize);
		cut[u]=true;
		calc(u,0,0,1);
		for(int i=h[u],v;i;i=e[i].next)
			if(!cut[v=e[i].v])
				calc(v,u,1,-1);
		for(int i=h[u],v;i;i=e[i].next)
			if(!cut[v=e[i].v])
				solve(v,size[v]<size[u]?size[v]:cursize-size[u]);
	}
}
double calc(ll plan,ll a){
	return ((double)a*(a-1))/((double)n*(n-1))*plan;
}
void solve(){
	int num[3];
	if(n%3==0)
		num[0]=num[1]=num[2]=n/3;
	else if(n%3==1)
		num[0]=(n/3+1), num[1]=num[2]=n/3;
	else
		num[0]=num[1]=(n/3+1), num[2]=n/3;
	ll s=0;
	for(int i=1;i<=m;i++) s+=sum[i];
	for(int i=0;i<3;i++)
		printf("%.2lf\n",calc(s,num[i]));
}
int main(){
	IO::load();
	readData();
	P::solve(1,n);
	solve();
	return 0;
}
```

