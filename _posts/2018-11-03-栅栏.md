---
layout: post
mathjax: true
title: 栅栏
date: 2018-11-03-19:31:00
tag: [随机化,树状数组,好题]
---
* content
{:toc}
# Description

　　略



# Solution

　　要判定两个格子是否连通，形象地说，我们只需要判断两个格子相对于全局的拓扑关系是否一样，即两个格子所属的矩形构成的集合是否完全相同

　　我们可以为每一个矩形设定一个随机的权值。每加入一个矩形，我们就将这个矩形范围内的所有格点异或上这个矩形的权值，删除时再异或掉。此时，每一个格点的权值就是所属矩形的集合的体现，如果两个格点的权值相同，那么它们就是连通的

　　我们使用二维树状数组支持矩形异或、单点查询即可。矩形异或等价于四个单点打标记，而单点查询等价于询问$(1,1)...(x,y)$的标记异或和



# Summary

　　如果判定性问题能转化有关“两者的性质集合是否完全相等”的询问，尝试使用随机化加上异或的方式，处理集合相等判定问题



# Code

```c++
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <unordered_map>
using namespace std;
typedef unsigned long long ULL;
namespace IO{
    const int L=50000000;
    char inBuf[L];
    int inPos;
    void load(){
        fread(inBuf,1,L,stdin);
        inPos=0;
    }
    char getChar(){
        return inBuf[inPos++];
    }
    int getInt(){
        char c=getChar();
        int x=0,f=1;
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getChar();}
        while('0'<=c&&c<='9'){x=x*10+c-'0';c=getChar();}
        return x*f;
    }
}
using IO::getInt;
const ULL B[4]={1,2005ull,4020025ull,8060150125ull};
const int N=2010;
const int Q=100010;
int n,m,q;
struct Rect{
    int x1,y1,x2,y2;
}rect[Q];
int idCnt;
unordered_map<ULL,int> idmap;
ULL val[Q];
ULL getRectHash(int x1,int y1,int x2,int y2){
    return B[3]*x1+B[2]*y1+B[1]*x2+y2;
}
ULL getRandValue(){
    ULL res=0;
    for(int i=0;i<64;i++)
        res+=(rand()%2)*(1ull<<i);
    return res;
}
namespace BIT{
    ULL a[N][N];
    void add(int x,int y,ULL k){
        for(int i=x;i<=n;i+=i&-i)
            for(int j=y;j<=m;j+=j&-j)
                a[i][j]^=k;
    }
    ULL que(int x,int y){
        ULL res=0;
        for(int i=x;i;i-=i&-i)
            for(int j=y;j;j-=j&-j)
                res^=a[i][j];
        return res;
    }
    void addXor(Rect &r,ULL k){
        int x1=r.x1,y1=r.y1,x2=r.x2,y2=r.y2;
        add(x1,y1,k);
        add(x1,y2+1,k);
        add(x2+1,y1,k);
        add(x2+1,y2+1,k);
    }
}
bool query(int x1,int y1,int x2,int y2){
    return BIT::que(x1,y1)==BIT::que(x2,y2);
}
int main(){
    IO::load();
    srand(time(0));
    int opt,x1,y1,x2,y2;
    n=getInt(); m=getInt(); q=getInt();
    for(int i=1;i<=q;i++){
        opt=getInt(); x1=getInt(); y1=getInt(); x2=getInt(); y2=getInt();
        if(opt==3)
            puts(query(x1,y1,x2,y2)?"Yes":"No");
        else{
            ULL h=getRectHash(x1,y1,x2,y2);
            int id=idmap[h];
            if(!id){ // add
                idCnt++;
                idmap[h]=idCnt;
                rect[idCnt]=(Rect){x1,y1,x2,y2};
                val[idCnt]=getRandValue();
                BIT::addXor(rect[idCnt],val[idCnt]);
            }
            else{ // del
                idmap[h]=0;
                BIT::addXor(rect[id],val[id]);
            }
        }
    }
    return 0;
}
```

 