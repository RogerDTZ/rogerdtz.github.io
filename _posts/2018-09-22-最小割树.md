---
layout: post
title: 最小割树
date: 2018-09-22-08:00:00
mathjax: true
category: Learning
tag: [网络流---最小割树]
---
* content
{:toc}
# 问题

　　现在有一个$n$个点的无向图，内含$m$条带权边

　　断开一条边的代价为其边权

　　我们希望对于每一个无序点对$(u,v)$，计算出至少要花费多少代价，才能使二者不互通

　　$n \le 100$



# 暴力做法

　　枚举点对，并直接跑网络流

　　复杂度上界$\mathcal O(n^4m)$

　　这个复杂度显然是不行的　　

# 最小割树

## 目标

　　根据相关定理，我们可以构造出一棵树，满足：

- 这棵树有$n$个点
- 每一条树边都有一个边权
- $(u,v)$的最小割，等于最小割树上$u$到$v$路径上的最小值

## 构建方法

1. 初始时，先构造一棵菊花树，令1号点为树根，其余点的父亲都为1号点
2. 从2~n枚举每一个点$i$，计算$i$到父亲$pre_i$的最小割，其值记为$f$。此时$i$的父亲已经固定下来，连边$(pre_i,i,f)$
  3. 对于任意一个点$j$（$j>i$），若$j$的父亲与$i$的父亲相同，且在计算$f$时，$j$与$i$在同一割集中，则将$j$的父亲设为$i$
  4. 回到步骤2.

```c++
// 主流程代码
void buildMincutTree(){
    for(int i=1;i<=n;i++)
        pre[i]=1;
    for(int i=2;i<=n;i++){
        int f=getMincut(i,pre[i]);
        addEdge(pre[i],i,f);
        for(int j=i+1;j<=n;j++)
            if(pre[j]==pre[i]&&Flow::dis[j]!=-1) // j与i在同一割集中（体现为距离标号不为空）
                pre[j]=i;
    }
    initDoubly(); // 处理树上倍增
}
```

　　最终，我们会得到一棵带边权的树

　　查询也就变得十分容易，只需要使用倍增维护路径边权最小值即可

## 复杂度

　　根据算法流程，我们只会执行恰好$n$次网络流

　　由于每一次网络流都是在整张图上计算的，如果不排除奇妙因素导致计算范围缩减，其上界仍然是$\mathcal O(n^2m)$

　　因此总复杂度大约是$\mathcal O(n^3m)$

## 关于正确性证明

　　可能需要ORZ其他题解，在这里先放上链接

　　先暂时当一个黑箱使用吧

　　[证明1](https://blog.csdn.net/axxgo7/article/details/54619560)

　　[证明2](https://blog.csdn.net/qq_33229466/article/details/53290996)



