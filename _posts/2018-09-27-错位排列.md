---

layout: post
title: 错位排列
date: 2018-09-27-14:36:00
tag: [DP---计数,矩阵快速幂]
mathjax: true
---
* content
{:toc}
# Description

　　考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错位排列。

　　例如，当n=3时，它有两个错位排列 {3,1,2} 和 {2,3,1}

　　现在我们想计算n个元素能组成的错位排列的数量，并将答案对m取模。

　　$T \le 100$

　　$1 \le n \le 10^9$

　　$ 1 \le m \le 10^5$



# Solution

　　问题相当于：求有多少由$n$个点构成的环森林没有自环，即没有大小为1的环

## 想法1

　　使用容斥，设$f_i$表示至少有$i$个自环时的方案数，则

$$
\begin{aligned}
f_i&={n \choose i}(n-i)!\\
&=\frac{n!}{i!}
\end{aligned}
\\
\begin{aligned}
ans&=\sum_{i=0}^n(-1)^if_i \\
&=\sum_{i=0}^n(-1)^i \frac{n!}{i!}
\end{aligned}
$$

　　显然可以直接$O(n)$计算

　　但是接下来不会做了

　　我坚持这个想法，尝试优化这个式子。但事实上这个式子已经到了死胡同了：

1. 有正负系数的存在
2. 有无法处理到的阶乘存在

　　下次看到式子包含奇怪元素、但又已经简洁到不能进一步推导时，提醒自己大方向错了，应该有另一个方向的解法



## 想法2

　　我们观察到询问有$100$组数据，$n$为$10^9$，这题怎么看都不是个数论分块题，那单次询问的复杂度还能是什么，很可能是矩阵快速幂的复杂度

　　于是考虑构造线性递推式：

　　设$f_n$表示编号为$1...n$的点构成合法环森林的方案数，则易得递推式

$$
f_0=1\\
\begin{aligned}
f_n&=(n-1)f_{n-1}+(n-1)f_{n-2}\\
&=(n-1)(f_{n-1}+f_{n-2})
\end{aligned}
$$

　　前者是将$n$号点并入之前的某个环，而后者是将$n$与$1...n-1$的某个点组合成一个大小为2的新环

　　接下来使用矩阵乘法加速：

$$
A_1=
\begin{bmatrix}
1 &0
\end{bmatrix}
\\
A_n=
\begin{bmatrix}
f_{n-1} &f_n
\end{bmatrix}
\\
T_n=\begin{bmatrix}
0 &n\\
1 &n
\end{bmatrix}
\\
A_n=A_1\prod_{i=1}^{n-1}T_i
$$

　　问题来了，递推式中有一个系数$n-1$与转移次数有关。这意味着转移矩阵$T$不断在变化，怎么做？

　　一般情况下，可能做不了（待填）；我们已经换了一个方向，还不对么？这时候我们要回看一次数据范围：给出模数$m$的范围很小！利用模$m$后运算的数字只在$[0,m)$的这个性质，我们再看看原递推式可以做什么转化：乘上去的系数模一个$m$，也就是每$m$次的系数是相同的：

$$
f_n=((n-1)\mod m)(f_{n-1}+f_{n-2})
$$

　　则转移矩阵变成

$$
T_n=\begin{bmatrix}
0 &n\;\text{mod}\;m\\
1 &n\;\text{mod}\;m
\end{bmatrix}
$$

　　这意味着$T_i=T_{km+i}\;(1 \le i \le m,\;k \ge 0)$

　　所以在用$\prod$计算$A_n$时，如果将乘上去的$T$每$m$个分成一组，每组的形式和乘积都是一样的，因此总体可以用$(\prod_{i=1}^mT_i)^{\lfloor \frac{n-1}{m}\rfloor}$表示，用乘法+快速幂解决

　　而余下的$\prod_{i=1}^{(n-1)\;\text{mod}\;m}T_i$直接计算即可

　　

## Orz

　　  看起来有10行做法，我太弱了

# Summary

​	此题关键是利用模$m$的性质，成功构造并利用了一个同余模型，将大步快速处理，而余下的小步也在$m$步以内，可以直接处理

　　遇到极其间接但是含有阶乘等元素，计算复杂度降不下来时，一般是大体方向想偏了。尝试换一个大方向思考（结合数据范围猜测）

# Code

```c++
#include <cstdio>
using namespace std;
int n,mod;
struct Mat{
	int n,m;
	int a[2][2];
	Mat(){
		reset();
	}
	Mat(int _n,int _m){
		n=_n; m=_m;
		reset();
	}
	void reset(){
		a[0][0]=a[0][1]=a[1][0]=a[1][1]=0;
	}
	void setUnit(){
		a[0][0]=a[1][1]=1;
	}
	friend Mat operator * (Mat &u,Mat v){
		Mat res(u.n,v.m);
		for(int i=0;i<u.n;i++)
			for(int j=0;j<v.m;j++)
				for(int k=0;k<u.m;k++)
					(res.a[i][j]+=1ll*u.a[i][k]*v.a[k][j]%mod)%=mod;
		return res;
	}
};
Mat A,T;
void readData(){
	scanf("%d%d",&n,&mod);
}
void multi(Mat &s,int l,int r){
	static Mat cur(2,2);
	cur.a[1][0]=1;
	for(int i=l;i<=r;i++){
		cur.a[0][1]=cur.a[1][1]=i;
		s=s*cur;
	}
}
Mat fmi(Mat x,int y){
	Mat res(x.n,x.n);
	res.setUnit();
	for(;y;x=x*x,y>>=1)
		if(y&1)
			res=res*x;
	return res;
}
void solve(){
	if(n==0){
		puts("1");
		return;
	}
	n--;
	// A=[f0,f1]
	A=Mat(1,2);
	A.a[0][0]=1; A.a[0][1]=0;
	Mat sum(2,2);
	sum.setUnit();
	if(n/mod){
		multi(sum,1,mod-1);
		multi(sum,0,0);
		A=A*fmi(sum,n/mod);
		n%=mod;
	}
	multi(A,1,n);
	int ans=A.a[0][1];
	printf("%d\n",ans<0?ans+mod:ans);
}
int main(){
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;i++){
		printf("Case #%d: ",i);
		readData();
		solve();
	}
	return 0;
}
```

