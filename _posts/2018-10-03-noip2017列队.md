---
layout: post
mathjax: true
title: 【NOIP2017】列队
date: 2018-10-03-10:13:00
tag: 线段树
category: NOIP2017
---

* content
{:toc}
# Description

　　[题目链接](http://uoj.ac/problem/334)



# Solution

　　由于这个问题自身的规模过大、看起来无法记录，我们考虑使用不开满的数据结构维护这个队伍

　　鉴于最后一列的行进方向特殊，而每一行除去最后一列以后，其可以看做一个整体来维护，我们使用$n$棵动态开点线段树维护每一行的前$m-1$个元素，再用一棵线段树维护最后一行

　　操作分两种情况：

1. $y==m$:
	1. 在维护最后一列的线段树上查询第$x$个元素，将其删去，在线段树末加入这个元素
2. $y<m$:
	1. 在维护第$x$行的线段树上查询第$y$个元素$a$，将其删去
	2. 在维护最后一列的线段树上查询第$x$个元素$b$，将其删去
	3. 将$b$加到第$x$行的线段树末尾
	4. 将$a$加到最后一列的线段树末尾

　　这些看似是平衡树的操作其实可以用线段树模拟：我们维护区间有值点的个数$siz$。则删去一个点等价于将其所属叶子节点的$siz$设置为0，然后一路上推。查询第$k$个元素时利用$siz$二分即可。由于线段树要支持每次在其大小+1的位置插入一个数，而总操作数为$q$，因此我们可以预先将线段树的宽度开到$[1,n+q]$或者$[1,m-1+q]$

　　对于原始值的初始化问题，在模拟开始前，我们对每一棵线段树的$[1,n]$或者$[1,m-1]$区间打上相应的等差数列标记和以下省略标记（两者要么同时存在，要么同时清空）。在之后的所有操作中，我们都不再增加新的标记，而是直接使用单点修改，且之后加入的数显然都不会被一开始时打的任何标记所影响。

　　由于时空限制较宽，我们可以在$O((n+q)\log(n+q))$的时间内解决问题



# Summary

　　网格图警告

# 严重失误

　　回想去年，自己打的50分暴力在模拟两个看齐时，用来循环的变量$i$竟然打成了$x$

```c++
for(int j=y;j<m;j++) id[x][j]=id[x][j+1];
for(int i=x;i<n;i++) id[x][m]=id[x+1][m];
```

　　今年重写时，我在程序中多次将$n$和$m$打反，包括宽度高度打反、等差数列的首项和公差打混，而因为测试数据和手构的数据大多都是$n$等于$m$，这些错误一点都看不出来

　　当然，后者是在我懒得拍的情况下才会出现的失误。但不排除自己会脑袋一热，数据仍然构造成$n=m$

　　以此警戒自己：

1. 写网格矩阵题时，一定要复查代码中关于长和宽的语句是否有混淆，且手构小数据、对拍大数据时$n$和$m$要随机波动
2. 考场上越是简单的代码，越要详细看，越要保证其正确性，不要懒，构造一些数据出来跑一下；即使是那些已经不能再暴力的部分，也要仔细看清楚是否含有低级错误



# Code

```c++
#include <cstdio>
using namespace std;
typedef long long ll;
const int N=300010,Q=300010;
int n,m,q;
int pos[N];
namespace SEG{
	const int S=(N+Q)*18*2;
	int rt[N],sz;
	int ch[S][2];
	int siz[S];
	ll tag[S][2];
	void pushup(int u){
		siz[u]=siz[ch[u][0]]+siz[ch[u][1]];
	}
	void build(int &u,int l,int r,int up,ll a,ll b){
		u=++sz;
		if(r<=up){
			siz[u]=r-l+1;	
			tag[u][0]=a; tag[u][1]=b;
			return;
		}
		int mid=(l+r)>>1;
		build(ch[u][0],l,mid,up,a,b);
		if(mid<up)
			build(ch[u][1],mid+1,r,up,a+b*(mid-l+1),b);
		pushup(u);
	}
	void pushdown(int u,int l,int r){
		if(!tag[u][1])
			return;
		if(!ch[u][0])
			ch[u][0]=++sz;
		if(!ch[u][1])
			ch[u][1]=++sz;
		int lc=ch[u][0],rc=ch[u][1],mid=(l+r)>>1;
		tag[lc][1]=tag[rc][1]=tag[u][1];	
		tag[lc][0]=tag[u][0];
		tag[rc][0]=tag[u][0]+tag[u][1]*(mid-l+1);
		siz[lc]=mid-l+1;
		siz[rc]=r-mid;
		tag[u][0]=tag[u][1]=0;
	}
	void modify(int &u,int l,int r,int pos,ll val){
		if(!u)
			u=++sz;
		if(l==r){
			tag[u][0]=val;
			siz[u]=1;
			return;
		}
		int mid=(l+r)>>1;
		if(pos<=mid)
			modify(ch[u][0],l,mid,pos,val);
		else
			modify(ch[u][1],mid+1,r,pos,val);
		pushup(u);
	}
	ll query(int &u,int l,int r,int k){
		siz[u]--;
		if(l==r)
			return tag[u][0];
		pushdown(u,l,r);
		int mid=(l+r)>>1;
		if(k<=siz[ch[u][0]])
			return query(ch[u][0],l,mid,k);
		else
			return query(ch[u][1],mid+1,r,k-siz[ch[u][0]]);
	}
}
void initSeg(){
	for(int i=1;i<=n;i++){
		pos[i]=m-1;
		SEG::build(SEG::rt[i],1,m-1+q,m-1,1ll*(i-1)*m+1,1);
	}
	SEG::build(SEG::rt[n+1],1,n+q,n,m,m);
	pos[n+1]=n;
}
void answerQuery(){
	int x,y;
	ll id,in;
	for(int i=1;i<=q;i++){
		scanf("%d%d",&x,&y);
		if(y<m){
			id=SEG::query(SEG::rt[x],1,m-1+q,y);
			in=SEG::query(SEG::rt[n+1],1,n+q,x);
			SEG::modify(SEG::rt[x],1,m-1+q,++pos[x],in);
			SEG::modify(SEG::rt[n+1],1,n+q,++pos[n+1],id);
		}
		else{
			id=SEG::query(SEG::rt[n+1],1,n+q,x);
			SEG::modify(SEG::rt[n+1],1,n+q,++pos[n+1],id);
		}
		printf("%lld\n",id);
	}
}
int main(){
	scanf("%d%d%d",&n,&m,&q);
	initSeg();
	answerQuery();
	return 0;
}
```

