---
layout: post
title: 【NOIP2017】逛公园
date: 2018-09-22-21:21:16
category: NOIP2017
tag: [最短路,记忆化搜索]
mathjax: true
---
* content
{:toc}
# Description

　　[题目链接](http://uoj.ac/problem/331)

　　在一张有向图上，求$1$到$n$有多少条路径，满足其长度不超过$1$到$n$的最短路长度加上$K$

　　$1 \le n \le 10^5\;\;\;\;0 \le K \le 50$



# Solution

　　一年了，才回来补坑

　　首先肯定是把最短路先算出来（用SPFA已经心有余悸了，不过真香）

　　考虑到$K$很小，整道题又是计数题，因此考虑设计一个有关$K$的计数DP

　　DP的第一维是点的编号，这是必须的；考虑第二维，其应该和已走距离相关，然而却我们记录不下真实走过的长度。由于我们考虑的路径长度范围都在[最短路,最短路+$K$]这个范围，因此我们可以考虑记录走过路径相对于最短路增加了多少

　　设$f_{u,x}$表示：从$1$出发走到$u$的路径中，有多少条的长度不超过$dis_u+x$。其中$dis_u$表示$1$到$u$的最短路长度

　　考虑$f_{u,x}$的转移来源：我们考虑的任意一条$f_{u,x}$表示的路径，都应该从某一个点走过来。因此我们枚举有向边$(v,u,w)$，可以得到如下式子：

$$
f_{1,0}=1\\
f_{u,x}=\sum_{(v,u,w)\in E}f_{v,trans(u,v,x,w)}[0 \le trans(u,v,x,w)\le K]\\trans(u,v,x,w)=dis_u+x-w-dis_v\\
ans=\sum_{x=0}^Kf_{n,x}
$$

　　到目前为止，我们感觉无从下手。感性的理解一下，会不会出现循环转移，即自己调用自己的情况呢？其实是不会的。如果从$f_{n,x}$依转移来源往下搜索，那么我们其实是在反向走一条路径；将第二维表示的相对路径长度转成绝对路径来看，它在这个过程中不断减小。也就是说，即使在搜索$f_{n,x}$时多次访问到了$f_{n}$，在先不考虑零环的情况下，第二维肯定会减少。因此搜索是有界的。

　　既然提到了搜索，又无循环，我们自然而然地就使用记忆化搜索完成这个$f$的计算。

　　上述做法已经足以应付无零环的情况了；而有零环的做法又有什么区别呢？

　　如果我们在搜索的时候，搜索到了一个已经在搜索栈中的状态，这说明我们找到了一个在从$1$走到$n$的过程中能走到的零环，直接判无解。

　　还有另一种特殊情况，其在良心样例中已经给出。即零环套在$1$号点上。这会有什么问题呢？我们记忆化搜索前，已经为$f_{1,0}$赋定了初值。在搜索时一遇到就会直接返回1，甚至可能没有走完可能存在的零环。这意味着我们的“二次入栈”判定方法不再有效。实际上，我们可以在一开始的spfa中判掉这种情况，详情参见代码



# Code

```c++
#include <cstdio>
#include <queue>
using namespace std;
const int N=100010,M=200010,K=55;
const int INF=1e9;
int n,m,o,mod;
int h1[N],h2[N],tot;
struct Edge{
	int v,w,next;
}e[M*2];
deque<int> q;
int dis[N];
bool inq[N];
int f[N][K];
bool ins[N][K];
void addEdge(int u,int v,int w){
	e[++tot]=(Edge){v,w,h1[u]}; h1[u]=tot;
	e[++tot]=(Edge){u,w,h2[v]}; h2[v]=tot;
}
void reset(){
	tot=0;
	for(int i=1;i<=n;i++) h1[i]=h2[i]=0;
}
void readData(){
	scanf("%d%d%d%d",&n,&m,&o,&mod);
	int u,v,w;
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&u,&v,&w);
		addEdge(u,v,w);
	}
}
void spfa(){
	while(!q.empty()) q.pop_front();
	for(int i=1;i<=n;i++){
		dis[i]=INF;
		inq[i]=false;
	}
	q.push_front(1);
	dis[1]=0;
	inq[1]=true;
	while(!q.empty()){
		int u=q.front();
		q.pop_front();
		inq[u]=false;
		for(int i=h1[u],v;i;i=e[i].next){
			v=e[i].v;
			if(v==1&&dis[u]+e[i].w==0) // 判零环套在1号点的情况
				throw 0;
			if(dis[v]>dis[u]+e[i].w){
				dis[v]=dis[u]+e[i].w;
				if(!inq[v]){
					if(q.empty()||dis[v]<dis[q.front()])
						q.push_front(v);
					else
						q.push_back(v);
					inq[v]=true;
				}
			}
		}
	}
}
int search_dfs(int u,int x){
	if(f[u][x]!=-1)
		return f[u][x];
	if(ins[u][x])
		throw 0;
	ins[u][x]=true;
	int res=0,nx;
	for(int i=h2[u],v,w;i;i=e[i].next){
		v=e[i].v; w=e[i].w;
		nx=dis[u]+x-w-dis[v];
		if(0<=nx&&nx<=o)
			(res+=search_dfs(v,nx))%=mod;
	}
	ins[u][x]=false;
	f[u][x]=res;
	return res;
}
void solve(){
	for(int i=1;i<=n;i++)
		for(int j=0;j<=o;j++){
			f[i][j]=-1;
			ins[i][j]=false;
		}
	f[1][0]=1;
	int ans=0;
	for(int i=0;i<=o;i++)
		(ans+=search_dfs(n,i))%=mod;
	printf("%d\n",ans);
}
int main(){
	int cases;
	scanf("%d",&cases);
	while(cases--){
		reset();
		readData();
		try{
			spfa();
			solve();
		}
		catch(int e){
			puts("-1");
		}
	}
	return 0;
}
```

