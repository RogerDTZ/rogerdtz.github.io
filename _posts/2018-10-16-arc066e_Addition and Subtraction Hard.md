---
layout: post
mathjax: true
title: 【ARC066E】Addition and Subtraction Hard
date: 2018-10-18-15:03:00
tag: [DP,思考题,可做未做]
category: 2017国家集训队作业
---
* content
{:toc}
# Description

　　给一个只有整数、加减号的表达式，现在可以添加任意多对括号，请输出表达式结果的最大值

　　整数个数$n \le 10^5$



# Solution

## 做法1：DP

　　先考虑最外层括号的行为模式

　　左括号前面的运算符决定了括号内部运算符是否反转，因此显然左括号打在一个加号后面没有任何用处

　　考虑相应的右括号打在哪里：如果将原表达式按减号断开并分段，我们的表达式就会变成
$$
S_1-S_2-S_3-...-S_k
$$
　　其中，$S_i$的内部是若干个加号连接的数

　　左括号打在某一个$S_i$之前，则右括号的位置一定是某一个$S_j(j>i)$的最开始的元素的后面，因为将右括号继续右移一定会将原本是正贡献的数变负，造成不会更优的局面

　　于是我们的第一层括号的形式就是
$$
-(S_i-S_{i+1}-...-S_{j}[1,1])+S_j[2,\mid S_j\mid]-...
$$
　　由于这个括号整体计算完后是负贡献，显然我们应该要使括号内部的结果尽可能小。一个很显然的策略就是把中间的每个$S$都用括号括起来。不难发现，这就是在确定完最外层括号后，内部的最优策略：
$$
-(S_i-(S_{i+1})-...-(S_{j}[1,1]))+S_j[2,\mid S_j\mid]-...
$$
　　因此全局中，括号我们只需要考虑最多两层即可

　　一个数对最终答案的贡献相对于原来的翻转次数，等于它所在的括号层数

　　由于层数很小，我们可以直接使用线性DP：设$f_{i,j}$表示对于$1\dots i$的数字，当左边有$j$个未关闭的左括号时，当前表达式的最大值是多少。设当前第$i$个数带上其前边的符号后为$x$，则有转移：
$$
f_{i,j}=f_{i-1,j}+x*(-1)^j
$$
　　如果当前数是负数，我们在考虑完当前数之后，在当前数前边尝试加一个左括号（加不加对当前数的决策没有影响），则
$$
f_{i,2}=\max\{f_{i,1},f_{i,2}\}\\
f_{i,1}=\max\{f_{i,0},f_{i,1}\}\\
$$
　　还可以考虑关闭一个括号：
$$
f_{i,0}=\max\{f_{i,0},f_{i,1}\}\\
f_{i,1}=\max\{f_{i,1},f_{i,2}\}
$$
　　注意转移顺序；第一维可省略



## 做法2：贪心

　　确定一个外层括号后，从左到右第一段$S$会变成对全局的负贡献，对于之后的减号隔开的元素，我们总可以通过适当操作，将他们变成对全局的正贡献

　　这个过程等价于以第一段的变化为代价，将后边每一段的开头元素（也就是前面是减号）对全局的贡献由负变正

　　我们枚举每个段作为起始段，由于花一次代价就可以无限制地优化后方，我们不妨将整个后面括起来即可，这样可以使更多的负贡献变为正贡献。

　　

# Summary

　　除了时间不够，场上卡着的主要原因是尝试整一段转移，即枚举最外层大括号、计算内层最优值来跳着转移

　　事实上，遇到此类题目，大转移实现较困难，但如果观察到大转移的本质等价于逐一枚举每个元素，用当前大转移自身的条件确定内部元素贡献，条件允许情况下，我们可以尝试在状态中记录大转移提供的条件（形如”有多少个打开的左括号“这样的信息），逐个元素转移即可，这样实现的难度会大大降低

　　简化操作：有时候看起来可以干的事情很多，但实际上真正有用的步骤可能是某些形式十分简单的方案，所有复杂的方案都不会比其更优



# Code

```c++
#include <cstdio>
using namespace std;
typedef long long LL;
const LL LINF=1ll<<60;
int n;
int getInt(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while('0'<=c&&c<='9'){x=x*10+c-'0';c=getchar();}
    return x*f;
}
LL f[3];
inline LL max(LL x,LL y){
    return x>y?x:y;
}
int main(){
    int x;
    scanf("%d",&n);
    f[1]=f[2]=-LINF;
    for(int i=1;i<=n;i++){
        x=getInt();
        f[0]+=x;
        f[1]-=x;
        f[2]+=x;
        if(x<0){
            f[2]=max(f[2],f[1]);
            f[1]=max(f[1],f[0]);
        }
        f[0]=max(f[0],f[1]);
        f[1]=max(f[1],f[2]);
    }
    printf("%lld\n",f[0]);
    return 0;
}
```

 